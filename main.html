<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RF Online - Text-Based MMORPG</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-bg: #121212;
            --darker-bg: #0a0a0a;
            --panel-bg: #1e1e1e;
            --accent: #2a2a2a;
            --highlight: #3a3a3a;
            --text: #e0e0e0;
            --text-dim: #a0a0a0;
            --accent-color: #ff7a2f;
            --accent-hover: #ff8a4f;
            --danger: #ff4a4a;
            --success: #4aff7a;
            --warning: #ffb84a;
            --exp-color: #ff9c4a;
            --encounter-color: #ffaa00;
            --fp-color: #4a9cff;
            --gem-color: #ff4a6a;
            --equip-color: #9c4aff;
        }

        /* Custom Scrollbar Styling */
        /* Webkit browsers (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--accent);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--highlight);
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--highlight) var(--accent);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: var(--darker-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 215px;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            /* Allow items to wrap */
        }

        nav a {
            color: var(--text);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        nav a:hover,
        nav a.active {
            background-color: var(--accent);
            color: var(--accent-color);
        }

        .container {
            display: flex;
            flex: 1;
            padding: 1rem;
            gap: 1rem;
            height: calc(100vh - 80px);
            overflow: hidden;
            margin: 0 200px;
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .left-panel {
            width: 25%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .center-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .right-panel {
            width: 25%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: calc(100vh - 120px);
            overflow-y: visible;
        }

        .inventory {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .inventory-scrollable {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--accent);
            color: var(--accent-color);
        }

        .character-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: var(--text-dim);
        }

        .stats {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .stat-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
        }

        .stat {
            background-color: var(--accent);
            padding: 0.8rem;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .level-value {
            color: var(--accent-color);
        }

        .hp-value {
            color: var(--danger);
        }

        .fp-value {
            color: var(--fp-color);
        }

        .attack-value {
            color: var(--warning);
        }

        .defense-value {
            color: var(--success);
        }

        .exp-value {
            color: var(--exp-color);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .battle-log {
            background-color: var(--darker-bg);
            border-radius: 4px;
            padding: 1rem;
            padding: 1rem;
            height: 400px;
            /* Default desktop height */
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .log-time {
            color: var(--text-dim);
        }

        .log-damage {
            color: #ff4a4a;
            /* Standard Red for Monster */
        }

        .log-player-damage {
            color: #ff4a4a;
            /* Pale Red for Player */
        }

        .log-heal {
            color: var(--success);
        }

        .log-loot {
            color: var(--warning);
        }

        .log-exp {
            color: var(--exp-color);
        }

        .log-level {
            color: var(--accent-color);
        }

        /* Normal monster encounters */
        .log-encounter {
            color: #dab600;
            background-color: rgba(255, 170, 0, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Boss monster encounters - increased specificity */
        .log-entry span.log-boss-encounter {
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.5) !important;
            background-color: rgba(255, 107, 53, 0.1) !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
        }

        /* Boss victory messages */
        .log-entry span.log-boss-victory {
            color: #ffaa00;
            background-color: rgba(255, 107, 53, 0.1) !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
        }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            flex: 1;
        }

        .btn:hover {
            background-color: var(--accent-hover);
        }

        .btn:disabled {
            background-color: var(--accent);
            color: var(--text-dim);
            cursor: not-allowed;
        }

        /* Pulse Animation (Opacity & Scale) */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.85;
                transform: scale(0.99);
            }
        }

        .btn-pulsing {
            animation: pulse 0.66s infinite;
            background-color: var(--warning) !important;
            color: white !important;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: var(--success) !important;
            color: white !important;
        }

        .btn-secondary {
            background-color: var(--accent);
        }

        .btn-secondary:hover {
            background-color: var(--highlight);
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-modal:hover {
            color: var(--accent-color);
        }

        /* Map item hover effects for unlocked maps */
        .map-item.map-unlocked:hover {
            opacity: 0.8 !important;
            transform: translateY(-2px) !important;
            transition: all 0.2s ease !important;
        }

        /* Dropdown Styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropbtn {
            background-color: var(--accent);
            color: var(--text);
            padding: 0.5rem 1rem;
            font-size: 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--panel-bg);
            min-width: 160px;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
            z-index: 1;
            border-radius: 4px;
            border: 1px solid var(--accent);
            right: 0;
            /* Align to right of parent */
        }

        .dropdown-content button {
            color: var(--text);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 1px solid var(--accent);
        }

        .dropdown-content button:last-child {
            border-bottom: none;
        }

        .dropdown-content button:hover {
            background-color: var(--highlight);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* Panel Header for Battle Log */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--accent);
        }

        .panel-header .panel-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        /* Header Buttons in Dropdown */
        .btn-add-leaves {
            color: var(--success) !important;
        }

        .btn-reset {
            color: var(--danger) !important;
        }

        .btn-save {
            color: #4a9cff !important;
        }

        /* Instant Finish Button in Header */
        #instant-finish-btn {
            padding: 4px 8px;
            font-size: 0.8rem;
            background-color: var(--warning);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Header Buttons */
        .header-btn {
            padding: 5px 10px;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
        }

        .btn-add-leaves {
            background: var(--success);
        }

        .btn-reset {
            background: var(--danger);
        }

        .btn-instant {
            background: var(--warning);
        }

        #maps-main-btn {
            background-color: #4a9cff;
            /* Distinct blue color */
            color: white;
        }

        #maps-main-btn:hover {
            background-color: #3a8ce0;
        }

        .btn-equip {
            background-color: var(--success);
        }

        .btn-equip:hover {
            background-color: #6aff9a;
        }

        .btn-stop {
            background-color: var(--danger);
        }

        .btn-stop:hover {
            background-color: #ff6a6a;
        }

        .btn-sell {
            background-color: var(--warning);
        }

        .btn-sell:hover {
            background-color: #ffca4a;
        }

        .btn-upgrade {
            background-color: var(--equip-color);
        }

        .btn-upgrade:hover {
            background-color: #ac7aff;
        }

        .explore-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .explore-option {
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .inventory {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .currency {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            padding: 0.5rem;
            background-color: var(--accent);
            border-radius: 4px;
            margin-bottom: 0.1rem;
        }

        .currency-icon {
            color: var(--warning);
        }

        .items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .item-compact {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            border: 1px solid transparent;
        }

        .item-compact.equipped {
            border: 2px solid var(--accent-color);
        }

        .item-compact-info {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .item-compact-name {
            font-weight: bold;
            line-height: 1.2;
            font-size: 0.80rem;
        }

        .item-compact-stats {
            font-size: 0.8rem;
            color: var(--text);
            line-height: 1.2;
        }

        .item-compact-sell {
            font-size: 0.7rem;
            color: var(--warning);
            line-height: 1.2;
        }

        .item-compact-actions {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.3rem;
        }

        .btn-small {
            padding: 0.2rem 0.5rem;
            font-size: 0.7rem;
            flex: 1;
        }

        .empty-inventory {
            text-align: center;
            padding: 1rem;
            color: var(--text-dim);
            font-style: italic;
        }

        .material-item {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .inventory-limit {
            font-size: 0.8rem;
            color: var(--text-dim);
            text-align: left;
            margin-top: 0.2rem;
            margin-bottom: 0.5rem;
        }

        .explore-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            width: 100%;
            margin-top: -12px !important;
            /* Negative margin to reduce gap above */
            margin-bottom: -15px !important;
            /* Negative margin to reduce gap below */
        }

        #explore-timer {
            text-align: right;
            margin-left: auto;
        }

        #explore-selected-time {
            text-align: left;
            font-weight: normal;
            color: var(--text-dim);
        }

        #explore-map-players {
            text-align: center;
            font-weight: normal;
            color: var(--text-primary);
            flex: 1;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--darker-bg);
            border-radius: 4px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
        }

        .hp-bar {
            background-color: var(--danger);
        }

        .fp-bar {
            background-color: var(--fp-color);
        }

        .exp-bar {
            background-color: var(--exp-color);
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 0.3rem;
        }

        .gem-emoji {
            color: var(--gem-color);
        }

        .modal,
        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            position: relative;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-dim);
        }

        .form-input {
            width: 100%;
            padding: 0.8rem;

            /* Market Styles */
            .market-container {
                width: 100%;
            }

            .market-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .market-title {
                color: var(--accent-color);
                font-size: 1.5rem;
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-btn {
                padding: 0.75rem 1.25rem;
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .sell-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .market-mode {
                display: none;
            }

            .market-mode.active {
                display: block;
            }

            .back-btn {
                padding: 0.5rem 1rem;
                background: var(--darker-bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-primary);
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.9rem;
            }

            .back-btn:hover {
                background: var(--bg);
                border-color: var(--accent-color);
            }

            .view-header {
                display: flex;
                align-items: flex-start;
                gap: 1rem;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .view-title h3 {
                color: var(--accent-color);
                margin: 0 0 0.25rem 0;
                font-size: 1.3rem;
            }

            .view-description {
                color: var(--text-dim);
                margin: 0;
                font-size: 0.95rem;
            }

            .market-items,
            .my-listings {
                max-height: 500px;
                overflow-y: auto;
            }

            .market-item,
            .listing-item {
                display: flex;
                flex-direction: column;
                padding: 1.25rem;
                border: 1px solid var(--border);
                border-radius: 8px;
                margin-bottom: 0.75rem;
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }

            .market-item:hover,
            .listing-item:hover {
                border-color: var(--accent-color);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                transform: translateY(-1px);
            }

            .market-item::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 3px;
                background: linear-gradient(90deg, var(--accent-color), var(--success));
            }

            .market-item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.75rem;
            }

            .market-item-name,
            .listing-item-name {
                font-size: 1.1rem;
                font-weight: bold;
                color: var(--accent-color);
                margin: 0;
            }

            .market-item-price,
            .listing-item-price {
                font-size: 1.2rem;
                font-weight: bold;
                color: var(--success);
                display: flex;
                align-items: center;
                gap: 0.25rem;
            }

            .currency-icon {
                font-size: 0.9rem;
            }

            .market-item-stats {
                font-size: 0.9rem;
                color: var(--text-primary);
                margin-bottom: 0.75rem;
                padding: 0.5rem;
                background-color: rgba(255, 255, 255, 0.03);
                border-radius: 4px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .market-item-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .market-item-seller {
                font-size: 0.85rem;
                color: var(--text-dim);
                font-style: italic;
            }

            .market-item button,
            .listing-item button {
                padding: 0.6rem 1.2rem;
                border-radius: 6px;
                font-weight: 500;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .market-item button:hover,
            .listing-item button:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }

            .btn-success {
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                color: white;
            }

            .btn-success:hover {
                background: linear-gradient(135deg, #4CAF50, var(--success));
            }

            .btn-danger {
                background: linear-gradient(135deg, var(--danger), #f44336);
                border: none;
                color: white;
            }

            .btn-danger:hover {
                background: linear-gradient(135deg, #f44336, var(--danger));
            }

            .btn-icon {
                font-size: 0.9rem;
            }

            /* Simple Market Styles */
            .market-container {
                width: 100%;
            }

            .market-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .market-title {
                color: var(--accent-color);
                font-size: 1.5rem;
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-btn {
                padding: 0.75rem 1.25rem;
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .sell-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .market-mode {
                display: none;
            }

            .market-mode.active {
                display: block;
            }

            .sell-interface {
                padding: 1rem 0;
            }

            .sell-section {
                padding: 0;
            }

            .sell-header {
                text-align: center;
                margin-bottom: 2rem;
            }

            .sell-header h3 {
                color: var(--accent-color);
                margin-bottom: 0.5rem;
                font-size: 1.3rem;
            }

            .sell-description {
                color: var(--text-dim);
                font-size: 0.95rem;
                margin: 0;
            }

            .cancel-sell-btn {
                margin-top: 1rem;
                padding: 0.5rem 1rem;
                background: var(--darker-bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-primary);
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.9rem;
            }

            .cancel-sell-btn:hover {
                background: var(--bg);
                border-color: var(--accent-color);
            }

            .sell-item-display {
                padding: 1.25rem;
                background: linear-gradient(135deg, var(--bg) 0%, var(--darker-bg) 100%);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                margin-bottom: 1.5rem;
                min-height: 80px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .no-item-selected {
                color: var(--text-dim);
                font-style: italic;
            }

            .sell-price-input {
                margin-bottom: 2rem;
            }

            .sell-price-input label {
                display: block;
                margin-bottom: 0.75rem;
                color: var(--text-primary);
                font-weight: 500;
            }

            .price-input-wrapper {
                display: flex;
                align-items: center;
                background-color: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                overflow: hidden;
            }

            .price-input-wrapper .currency-icon {
                padding: 0.75rem 1rem;
                background-color: rgba(255, 255, 255, 0.05);
                border-right: 1px solid var(--border);
            }

            .sell-price-input input {
                flex: 1;
                padding: 0.75rem 1rem;
                background-color: transparent;
                border: none;
                color: var(--text-primary);
                font-size: 1rem;
                text-align: right;
            }

            .sell-price-input input:focus {
                outline: none;
            }

            .price-input-wrapper:focus-within {
                border-color: var(--accent-color);
                box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.75rem;
                margin-bottom: 2rem;
                max-height: 350px;
                overflow-y: auto;
                padding: 1rem;
                background-color: rgba(255, 255, 255, 0.02);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .inventory-item {
                padding: 0.75rem;
                border: 1px solid var(--border);
                border-radius: 6px;
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                cursor: pointer;
                text-align: center;
                transition: all 0.3s ease;
                position: relative;
            }

            .inventory-item:hover {
                border-color: var(--accent-color);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            .inventory-item.selected {
                border-color: var(--success);
                background: linear-gradient(135deg, rgba(76, 175, 80, 0.1) 0%, rgba(46, 125, 50, 0.1) 100%);
                box-shadow: 0 0 0 2px var(--success);
            }

            .inventory-item.selected::after {
                content: '✓';
                position: absolute;
                top: 5px;
                right: 5px;
                background-color: var(--success);
                color: white;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
            }

            .inventory-item-name {
                font-size: 0.85rem;
                font-weight: bold;
                margin-bottom: 0.5rem;
                color: var(--accent-color);
            }

            .inventory-item-stats {
                font-size: 0.75rem;
                color: var(--text-dim);
                line-height: 1.2;
            }

            .sell-form {
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                padding: 2rem;
                border-radius: 8px;
                border: 1px solid var(--border);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }

            .sell-preview h4,
            .sell-price-section h4 {
                color: var(--accent-color);
                margin-bottom: 1rem;
                font-size: 1.1rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-item-info {
                padding: 1.25rem;
                background: linear-gradient(135deg, var(--bg) 0%, var(--darker-bg) 100%);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                margin-bottom: 1.5rem;
                min-height: 80px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .no-item-selected {
                color: var(--text-dim);
                font-style: italic;
                text-align: center;
            }

            .sell-price-input {
                margin-bottom: 2rem;
            }

            .sell-price-input label {
                display: block;
                margin-bottom: 0.75rem;
                color: var(--text-primary);
                font-weight: 500;
            }

            .price-input-wrapper {
                display: flex;
                align-items: center;
                background-color: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                overflow: hidden;
            }

            .price-input-wrapper .currency-icon {
                padding: 0.75rem 1rem;
                background-color: rgba(255, 255, 255, 0.05);
                border-left: 1px solid var(--border);
            }

            .sell-price-input input {
                flex: 1;
                padding: 0.75rem 1rem;
                background-color: transparent;
                border: none;
                color: var(--text-primary);
                font-size: 1rem;
                text-align: right;
            }

            .sell-price-input input:focus {
                outline: none;
            }

            .price-input-wrapper:focus-within {
                border-color: var(--accent-color);
                box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            }

            .price-hint {
                font-size: 0.85rem;
                color: var(--text-dim);
                margin-top: 0.5rem;
                font-style: italic;
            }

            .sell-buttons {
                display: flex;
                gap: 1rem;
                justify-content: center;
                margin-top: 2rem;
            }

            .loading {
                text-align: center;
                color: var(--text-dim);
                padding: 3rem 1rem;
                font-style: italic;
            }

            .loading::before {
                content: '⏳';
                font-size: 2rem;
                display: block;
                margin-bottom: 1rem;
            }

            .empty-state {
                text-align: center;
                color: var(--text-dim);
                padding: 3rem 1rem;
            }

            .empty-icon {
                font-size: 3rem;
                margin-bottom: 1rem;
                opacity: 0.6;
            }

            .empty-state h3 {
                color: var(--accent-color);
                margin-bottom: 0.5rem;
                font-size: 1.2rem;
            }

            .empty-state p {
                margin: 0;
                font-size: 0.95rem;
                line-height: 1.4;
            }

            background-color: var(--darker-bg);
            border: 1px solid var(--accent);
            border-radius: 4px;
            color: var(--text);
        }

        .race-options,
        .class-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .race-option,
        .class-option {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .race-option:hover,
        .class-option:hover,
        .race-option.selected,
        .class-option.selected {
            background-color: var(--highlight);
            border: 1px solid var(--accent-color);
        }

        .gender-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .gender-option {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .gender-option:hover,
        .gender-option.selected {
            background-color: var(--highlight);
            border: 1px solid var(--accent-color);
        }

        .players-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            border-bottom: 1px solid var(--accent);
        }

        .player-rank {
            width: 30px;
            text-align: center;
            font-weight: bold;
        }

        .player-name {
            flex: 1;
        }

        .player-level {
            width: 60px;
            text-align: right;
        }

        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .upgrade-content {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .upgrade-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }

        .upgrade-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--accent);
            border-radius: 4px;
        }

        .upgrade-info {
            margin-bottom: 1rem;
        }

        .upgrade-cost {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--warning);
            margin-bottom: 1rem;
        }

        .upgrade-chance {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .upgrade-result {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }

        .upgrade-success {
            background-color: rgba(74, 255, 122, 0.2);
            color: var(--success);
        }

        .upgrade-failure {
            background-color: rgba(255, 74, 74, 0.2);
            color: var(--danger);
        }

        .small-title {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            margin-top: 0.8rem;
            color: var(--accent-color);
            border-bottom: 1px solid var(--accent);
            padding-bottom: 0.2rem;
        }

        .material-item-compact {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            flex-wrap: nowrap;
        }

        .material-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.8rem;
        }

        .material-price {
            color: var(--text-dim);
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .material-item-compact .btn-small {
            flex: 0 0 60px;
            max-width: 80px;
        }

        .stat-bars-container {
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .stat-bar-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-bar-label {
            width: 30px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .stat-bar-progress {
            flex: 1;
            height: 12px;
            background-color: var(--darker-bg);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar-value {
            width: 50px;
            text-align: right;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .character-details-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            margin-bottom: 1.5rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--accent);
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .highlight-detail {
            color: var(--accent-color);
            font-weight: bold;
            font-size: .1rem;
        }

        .level-detail {
            color: var(--accent-color);
            font-weight: bold;
            font-size: 1rem !important;
            /* !important to override .detail-value */
            /* ← Adjust this for Level size */
        }

        .exp-container {
            margin-bottom: 1.5rem;
        }

        .detail-label {
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .detail-value {
            font-weight: normal;
            color: var(--text);
            font-size: 0.9rem;
        }

        .combat-stats {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .combat-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inventory-item,
        .material-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 0.85rem;
            /* Reduced font size */
        }

        .inventory-item span,
        .material-item span {
            font-size: 0.8rem;
            /* Further reduce text size for items */
        }

        /* Specific style for Leaves/Currency if they appear in list */
        .currency-item {
            font-size: 0.8rem;
        }

        .combat-label {
            font-weight: normal;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .combat-value {
            font-size: 0.9rem;
            font-weight: normal;
        }

        .item-rarity-t1 {
            color: #ffd700 !important;
            /* Yellow */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        /* Mobile Optimization */
        @media (max-width: 720px) {
            header {
                margin: 0;
                padding: 0.5rem;
                flex-direction: row;
                /* Keep row for logo and nav */
                flex-wrap: wrap;
                justify-content: space-between;
                align-items: center;
                gap: 0.5rem;
            }

            .logo {
                margin-bottom: 0;
                font-size: 1.2rem;
                text-align: left;
            }

            nav {
                width: auto;
            }

            nav ul {
                justify-content: flex-end;
                gap: 0.5rem;
                padding: 0;
            }

            .dropdown-content {
                right: 0;
                min-width: 200px;
            }

            .container {
                margin: 0;
                flex-direction: column;
                height: auto;
                overflow-y: auto;
                padding: 0.5rem;
                gap: 1rem;
                /* Add gap between panels */
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
                height: auto;
                overflow: visible;
                padding: 1rem;
                /* Reduce padding slightly */
            }

            .right-panel {
                height: auto;
                max-height: 500px;
                overflow-y: auto;
            }

            .battle-log {
                height: 600px;
                /* Larger log on mobile as requested */
            }

            .stat-group {
                grid-template-columns: 1fr 1fr 1fr;
            }

            .actions {
                flex-direction: column;
                /* Stack actions vertically or wrap */
                gap: 0.5rem;
            }

            .action-buttons {
                flex-wrap: wrap;
                justify-content: space-between;
                /* Distribute buttons */
                gap: 0.5rem;
            }

            .btn {
                flex: 1 1 45%;
                /* Grow and shrink, basis 45% */
                min-width: 120px;
                /* Minimum width for touch targets */
                padding: 0.8rem 0.5rem;
                /* Adjust padding */
                font-size: 0.9rem;
            }
        }

        .crafting-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .crafting-content {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .recipe-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .recipe-item {
            background-color: var(--accent);
            padding: 1rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .recipe-item:hover {
            background-color: var(--highlight);
        }

        .recipe-item.selected {
            border-color: var(--accent-color);
            background-color: var(--highlight);
        }

        .recipe-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .recipe-requirements {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        .req-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.2rem;
        }

        .req-met {
            color: var(--success);
        }

        .req-missing {
            color: var(--danger);
        }

        /* Skills Section in Left Panel */
        .skills-group {
            margin-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 1rem;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .skills-header {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .skill-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
            font-size: 0.9rem;
            width: 100%;
        }

        .skill-label {
            color: var(--text-dim);
        }

        .skill-value {
            color: var(--text-color);
        }

        .skill-value.locked {
            color: var(--text-dim);
            font-style: italic;
        }

        .skill-value.unlocked {
            color: var(--accent-color);
        }

        /* Import Modal */
        .import-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .import-content {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .import-textarea {
            width: 100%;
            height: 150px;
            background-color: var(--bg-color);
            color: var(--text);
            border: 1px solid var(--accent);
            border-radius: 4px;
            padding: 0.5rem;
            resize: none;
            font-family: monospace;
        }

        .import-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        /* Encounter Tracker */
        .encounter-tracker {
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .encounter-item {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
        }

        .encounter-name {
            color: var(--text);
        }

        .encounter-count {
            color: var(--accent-color);
        }

        /* Loading Screen */
        #auth-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--accent);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 1.5rem;
            color: var(--text-dim);
            font-size: 1rem;
            text-align: center;
        }

        .loading-title {
            margin-bottom: 2rem;
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .force-clear-btn {
            margin-top: 2rem;
            padding: 0.8rem 2rem;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
        }

        .force-clear-btn:hover {
            background: #ff6a6a;
            transform: translateY(-2px);
        }

        .debug-info {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--panel-bg);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
            max-width: 500px;
            text-align: left;
            display: none;
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="auth-loading">
        <div class="loading-title">RF Online: Idle Crusade</div>
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Verifying authentication...</div>
        <button class="force-clear-btn" id="force-clear-btn" onclick="forceClearAndReload()">🧹 Force Clear All
            Data</button>
        <div class="debug-info" id="debug-info"></div>
    </div>
    <header>
        <div class="logo">RF Online: Idle Crusade</div>
        <nav>
            <ul>
                <li style="display: none;">
                    <div class="dropdown">
                        <button class="dropbtn">Debug Tools ▼</button>
                        <div class="dropdown-content">
                            <button id="add-leaves-btn" class="btn-add-leaves">+10k Leaves</button>
                            <button id="add-gems-btn" class="btn-save">+100 Gems</button>
                            <button id="add-gear-btn" class="btn-save">+Test Gear</button>
                            <button id="kill-arghol-btn" class="btn-reset">Kill Arghol Wasp</button>

                            <button id="reset-game-btn" class="btn-reset">Reset Game</button>
                            <button id="export-save-btn" class="btn-save">Export Save</button>
                            <button id="import-save-btn" class="btn-save">Import Save</button>
                        </div>
                    </div>
                </li>
                <li><a href="#" class="active">Game</a></li>
                <li><a href="#" id="players-btn">Players</a></li>
                <li><a href="#" id="maps-btn">Maps</a></li>
                <li><a href="#" id="market-btn">Market</a></li>
                <li><a href="#" id="settings-btn">Settings</a></li>
                <li>
                    <button id="auth-btn" class="btn"
                        style="background-color: var(--accent); font-size: 0.9rem;">Logout</button>
                </li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <!-- Left Panel - Character Details -->
        <div class="panel left-panel">
            <h2 class="panel-title">CHARACTER</h2>

            <!-- 1. HP and FP Bars -->
            <div class="stat-bars-container">
                <div class="stat-bar-row">
                    <div class="stat-bar-label" style="color: var(--danger)">HP</div>
                    <div class="stat-bar-progress">
                        <div class="progress-fill hp-bar" style="width: 100%"></div>
                    </div>
                    <div class="stat-bar-value hp-value" id="char-hp">100</div>
                </div>
                <div class="stat-bar-row">
                    <div class="stat-bar-label" style="color: var(--fp-color)">FP</div>
                    <div class="stat-bar-progress">
                        <div class="progress-fill fp-bar" style="width: 100%"></div>
                    </div>
                    <div class="stat-bar-value fp-value" id="char-fp">50</div>
                </div>
            </div>

            <!-- 2. Character Details -->
            <div class="character-details-list">
                <!-- Level and Exp -->
                <div class="detail-row">
                    <span class="detail-label">Level</span>
                    <span class="detail-value level-detail" id="char-level">1</span>
                </div>
                <div class="exp-container">
                    <div class="progress-bar" style="height: 8px; margin-top: 0.2rem; margin-bottom: 0.2rem;">
                        <div class="progress-fill exp-bar" style="width: 0%"></div>
                    </div>
                    <div style="text-align: right; font-size: 0.8rem; color: var(--text-dim);">
                        <span id="char-exp">0/100</span>
                    </div>
                </div>

                <!-- Name -->
                <div class="detail-row">
                    <span class="detail-label">Name</span>
                    <span class="detail-value highlight-detail" id="char-name">-</span>
                </div>

                <!-- Other Details -->
                <div class="detail-row">
                    <span class="detail-label">Race</span>
                    <span class="detail-value" id="char-race">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Gender</span>
                    <span class="detail-value" id="char-gender">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Class</span>
                    <span class="detail-value" id="char-class">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Location</span>
                    <span class="detail-value" id="char-location">-</span>
                </div>
            </div>

            <!-- 3. Combat Stats -->
            <div class="combat-stats">
                <div class="combat-stat">
                    <span class="combat-label">Attack</span>
                    <span class="combat-value attack-value" id="char-attack">10</span>
                </div>
                <div class="combat-stat">
                    <span class="combat-label">Defense</span>
                    <span class="combat-value defense-value" id="char-defense">5</span>
                </div>
                <div class="combat-stat">
                    <span class="combat-label">Crit Chance</span>
                    <span class="combat-value" id="char-crit" style="color: #ff4444;">5%</span>
                </div>
                <div class="combat-stat" id="lifesteal-stat-container" style="display: none;">
                    <span class="combat-label">Lifesteal</span>
                    <span class="combat-value" id="char-lifesteal" style="color: #00ff00;">0%</span>
                </div>
                <div class="combat-stat" id="dmg-red-stat-container" style="display: none;">
                    <span class="combat-label">Dmg Red.</span>
                    <span class="combat-value" id="char-dmg-red" style="color: #3498db;">0%</span>
                </div>
                <div class="combat-stat" id="speed-stat-container" style="display: none;">
                    <span class="combat-label">Speed</span>
                    <span class="combat-value" id="char-speed" style="color: #ffaa00;">0</span>
                </div>
            </div>

            <!-- 4. Skills -->
            <div class="skills-group">
                <div class="skills-header">Skills</div>
                <div class="skill-row">
                    <span class="skill-label">Basic</span>
                    <span class="skill-value" id="skill-basic">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Expert</span>
                    <span class="skill-value" id="skill-expert">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Elite</span>
                    <span class="skill-value" id="skill-elite">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Ultimate</span>
                    <span class="skill-value" id="skill-ultimate">Locked</span>
                </div>
            </div>
        </div>

        <!-- Center Panel - Battle Logs and Actions -->
        <div class="panel center-panel">
            <div class="panel-header">
                <h2 class="panel-title">BATTLE LOG</h2>
            </div>
            <div class="explore-status" id="explore-status" style="display: flex;">
                <span id="explore-selected-time">AFK</span>
                <span id="explore-map-players">Map Players: 0</span>
                <span id="explore-timer"></span>
            </div>
            <div class="battle-log" id="battle-log">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span> Welcome to RF Online! Start exploring to battle monsters
                    and gain experience.
                </div>
            </div>

            <div class="actions">
                <h3 class="panel-title small-title">ACTIONS</h3>
                <div class="action-buttons">
                    <button class="btn" id="explore-btn">Explore</button>
                    <button class="btn btn-secondary" id="maps-main-btn">Maps</button>
                    <button class="btn btn-stop" id="stop-btn" style="display: none;">Stop</button>
                </div>

                <div class="explore-options" id="explore-options" style="display: none;">
                    <!-- Time-based exploration (HQ, Sette Desert) -->
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-30">30 mins</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-60">1 hour</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-360">6 hours</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-720">12 hours</button>
                    </div>

                    <!-- Area-based exploration (Ether Platform) -->
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-wharf">Wharf</button>
                    </div>
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-white-hole">White Hole</button>
                    </div>
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-lures-lot">Lures Lot</button>
                    </div>
                </div>

                <!-- Monster Encounter Tracker -->
                <div id="encounter-tracker" style="display: none; margin-top: 1rem; font-size: 0.7rem;">
                    <div style="margin-bottom: 0.3rem; color: var(--text-dim);">Last Exploration:</div>
                    <div id="encounter-list"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Inventory -->
        <div class="panel right-panel">
            <div class="inventory">
                <div class="panel-header">
                    <h2 class="panel-title">INVENTORY</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <label
                            style="font-size: 0.75rem; display: flex; align-items: center; cursor: pointer; color: var(--text-dim); white-space: nowrap;">
                            <input type="checkbox" id="auto-potion-toggle" checked style="margin-right: 4px;"> Auto
                            Potion
                        </label>
                        <button class="btn btn-secondary" id="craft-btn"
                            style="background-color: #2ecc71; padding: 4px 12px; font-size: 0.8rem; width: auto; min-width: auto; flex: none;">Craft</button>
                    </div>
                </div>
                <div class="currency">
                    Leaves 🍃 <span id="currency-amount">0</span> &nbsp;|&nbsp; Coins 🪙 <span
                        id="coins-amount">0</span>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="panel-title small-title" style="margin-bottom: 0;">ITEMS</h3>
                    <div class="inventory-limit" id="inventory-limit" style="margin-bottom: 0;">0/15</div>
                </div>

                <!-- Scrollable Items Section -->
                <div class="inventory-scrollable">
                    <div class="items" id="inventory-items">
                        <!-- Items will be dynamically added here -->
                    </div>
                    <div class="empty-inventory" id="empty-inventory">Your inventory is empty</div>

                    <div class="upgrade-section">
                        <h3 class="panel-title small-title">OTHER MATERIALS</h3>
                        <div class="items" id="materials-items">
                            <!-- Materials will be dynamically added here -->
                        </div>
                        <div class="empty-inventory" id="empty-materials">No upgrade materials</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Registration Modal -->
    <div class="modal" id="registration-modal">
        <div class="modal-content">
            <h2 class="modal-title">CREATE CHARACTER</h2>
            <div class="form-group">
                <label class="form-label" for="char-name-input">Character Name</label>
                <input type="text" class="form-input" id="char-name-input" placeholder="Enter your character name">
            </div>

            <div class="form-group">
                <label class="form-label">Select Race</label>
                <div class="race-options">
                    <div class="race-option" data-race="Accretia">Accretia</div>
                    <div class="race-option" data-race="Bellato">Bellato</div>
                    <div class="race-option" data-race="Cora">Cora</div>
                </div>
            </div>

            <div class="form-group" id="gender-selection" style="display: none;">
                <label class="form-label">Select Gender</label>
                <div class="gender-options">
                    <div class="gender-option" data-gender="Male">Male</div>
                    <div class="gender-option" data-gender="Female">Female</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Select Class</label>
                <div class="class-options" id="class-options">
                    <!-- Classes will be dynamically populated based on race -->
                </div>
            </div>

            <button class="btn" id="create-character-btn">Create Character</button>
        </div>
    </div>

    <!-- Players Modal -->
    <div class="modal" id="players-modal">
        <div class="modal-content">
            <h2 class="modal-title">PLAYER RANKINGS</h2>
            <div class="players-list" id="players-list">
                <!-- Player rows will be dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Maps Modal -->
    <div class="modal" id="maps-modal">
        <div class="modal-content">
            <button class="close-modal"
                onclick="document.getElementById('maps-modal').style.display='none'">&times;</button>
            <h2 class="modal-title">MAPS</h2>
            <div class="maps-list" id="maps-list">
                <div class="map-item" id="hq-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; border: 2px solid var(--accent-color);">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">HQ</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 1-20</div>
                </div>
                <div class="map-item" id="sette-desset-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; opacity: 1;">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">Sette Desert</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 20+</div>
                </div>
                <div class="map-item" id="ether-platform-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; opacity: 1;">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">Ether Platform</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 30+ <span
                            style="color: var(--warning); font-size: 0.8rem;">(Cost: 1000 Leaves)</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Market Modal -->
    <div class="modal" id="market-modal">
        <style>
            .market-item-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0.75rem 1rem;
                margin-bottom: 0.5rem;
                border-radius: 6px;
                background: var(--panel-bg);
                border: 1px solid rgba(255, 255, 255, 0.1);
                transition: all 0.2s ease;
            }

            .market-item-row:hover {
                background: var(--bg);
                border-color: var(--accent);
                transform: translateX(2px);
            }

            .market-item-row.my-listing {
                background: linear-gradient(90deg, rgba(52, 152, 219, 0.15) 0%, var(--panel-bg) 100%);
                border-left: 3px solid var(--accent-color);
            }

            .market-item-row.my-listing:hover {
                background: linear-gradient(90deg, rgba(52, 152, 219, 0.2) 0%, var(--bg) 100%);
            }

            .market-item-info {
                display: flex;
                align-items: center;
                gap: 1.5rem;
                flex: 1;
            }

            .market-item-name {
                min-width: 200px;
                font-weight: 500;
                color: var(--text);
                font-size: 0.95rem;
            }

            .market-item-stats {
                min-width: 120px;
                color: var(--text-dim);
                font-size: 0.9rem;
            }

            .market-item-price {
                min-width: 100px;
                font-weight: 600;
                color: var(--success);
                font-size: 1rem;
            }

            .market-item-action {
                min-width: 100px;
                text-align: right;
            }
        </style>
        <div class="modal-content" style="max-width: 1000px;">
            <!-- Header with title, sell button, and close button -->
            <div
                style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 2rem; padding-right: 3rem;">
                <h2 class="modal-title" style="margin: 0;">🏪 GLOBAL MARKET</h2>
                <button class="btn btn-success" onclick="showSellMode()"
                    style="padding: 0.3rem 0.6rem; font-size: 0.8rem;">
                    <span class="btn-icon">💰</span> Sell Items
                </button>
            </div>
            <button class="close-modal" onclick="document.getElementById('market-modal').style.display='none'"
                style="top: 1.5rem; right: 1.5rem;">×</button>

            <!-- Single unified market view -->
            <div id="market-unified-view">
                <!-- My Listings Section -->
                <div id="my-listings-section" style="margin-bottom: 2rem;">
                    <h3
                        style="color: var(--accent-color); font-size: 0.8rem; margin-bottom: 1rem; padding-left: 0.5rem;">
                        📋 My Listings
                    </h3>
                    <div id="my-listings-container">
                        <!-- My listings will be loaded here -->
                    </div>
                </div>

                <!-- Market Items Section -->
                <div id="market-items-section">
                    <h3 style="color: var(--text); font-size: 0.8rem; margin-bottom: 1rem; padding-left: 0.5rem;">
                        🛒 Available Items
                    </h3>
                    <div id="market-items-container">
                        <!-- Market items will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Sell Mode (Modal within modal) -->
            <div id="market-sell-mode" style="display: none;">
                <div style="text-align: center; margin-bottom: 2rem;">
                    <h3 style="color: var(--accent-color); margin-bottom: 0.5rem;">💰 List an Item for Sale</h3>
                    <p style="color: var(--text-dim); font-size: 0.95rem; margin: 0;">Select an unequipped item from
                        your inventory</p>
                </div>

                <div class="inventory-grid" id="sell-inventory" style="margin-bottom: 2rem;">
                    <!-- Inventory items will be loaded here -->
                </div>

                <div class="sell-form" id="sell-form" style="display: none;">
                    <div
                        style="background: var(--panel-bg); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div id="sell-item-info" style="text-align: center; margin-bottom: 1.5rem;">
                            <!-- Selected item info -->
                        </div>

                        <div style="margin-bottom: 1.5rem;">
                            <label for="sell-price"
                                style="display: block; margin-bottom: 0.75rem; color: var(--text); font-weight: 500;">
                                Set Price (Leaves):
                            </label>
                            <div class="price-input-wrapper">
                                <input type="number" id="sell-price" placeholder="0" min="1" max="999999"
                                    pattern="[0-9]*" oninput="this.value = this.value.replace(/[^0-9]/g, '')"
                                    style="flex: 1; padding: 0.75rem 1rem; background-color: var(--darker-bg); border: 1px solid var(--accent); border-radius: 6px; color: var(--text); font-size: 1rem; text-align: right;">
                                <span class="currency-icon"
                                    style="padding: 0.75rem 1rem; background-color: rgba(255, 255, 255, 0.05); border-left: 1px solid var(--accent);">🍃</span>
                            </div>
                        </div>

                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="btn btn-secondary" onclick="showUnifiedView()"
                                style="padding: 0.8rem 1.5rem;">
                                Cancel
                            </button>
                            <button class="btn btn-success" id="confirm-sell-btn" style="padding: 0.8rem 1.5rem;">
                                <span class="btn-icon">📤</span> List for Sale
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div class="upgrade-modal" id="upgrade-modal">
        <div class="upgrade-content">
            <h2 class="upgrade-title">WEAPON UPGRADING</h2>
            <div class="upgrade-item" id="upgrade-item-info">
                <!-- Upgrade info will be dynamically added here -->
            </div>
            <div class="upgrade-result" id="upgrade-result" style="display: none;"></div>
            <div class="action-buttons">
                <button class="btn" id="upgrade-confirm-btn">Upgrade</button>
                <button class="btn btn-secondary" id="upgrade-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Crafting Modal -->
    <div class="crafting-modal" id="crafting-modal">
        <div class="crafting-content">
            <h2 class="modal-title">CRAFTING</h2>
            <div class="recipe-list" id="recipe-list">
                <!-- Recipes will be dynamically added here -->
            </div>
            <div class="action-buttons">
                <button class="btn" id="craft-confirm-btn" disabled>Craft</button>
                <button class="btn btn-secondary" id="craft-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="import-modal">
        <div class="import-content">
            <h2 class="panel-title">Import Save Data</h2>
            <p>Paste your save code below:</p>
            <textarea id="import-textarea" class="import-textarea" placeholder="Paste save string here..."></textarea>
            <div class="import-buttons">
                <button class="btn btn-secondary" id="import-cancel-btn">Cancel</button>
                <button class="btn" id="import-confirm-btn">Import</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Force Clear Function (must be global for onclick)
        window.forceClearAndReload = function () {
            console.log('🧹 FORCE CLEAR: Clearing all browser data...');

            // Clear all storage
            localStorage.clear();
            sessionStorage.clear();

            // Show confirmation
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                debugInfo.style.display = 'block';
                debugInfo.innerHTML = '✅ All data cleared!<br>📍 Redirecting to login page...';
            }

            // Redirect to index.html
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1000);
        };

        // Show Force Clear button after 3 seconds if still loading
        setTimeout(() => {
            const forceClearBtn = document.getElementById('force-clear-btn');
            const debugInfo = document.getElementById('debug-info');
            if (forceClearBtn && forceClearBtn.style.display !== 'block') {
                forceClearBtn.style.display = 'block';
                if (debugInfo) {
                    debugInfo.style.display = 'block';
                    debugInfo.innerHTML = '⚠️ Taking longer than expected...<br>📊 Current URL: ' + window.location.href + '<br>💾 localStorage: ' + (localStorage.getItem('rfOnlineGame') ? 'HAS DATA' : 'EMPTY');
                }
            }
        }, 3000);

        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getDatabase, ref, set, get, child, update, onValue, onDisconnect, push, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBSmstVBMny75LIw8U8fde6Obz4nZgqTQk",
            authDomain: "idle-crusade-1900b.firebaseapp.com",
            databaseURL: "https://idle-crusade-1900b-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "idle-crusade-1900b",
            storageBucket: "idle-crusade-1900b.firebasestorage.app",
            messagingSenderId: "1026876043394",
            appId: "1:1026876043394:web:ee18a7b584b8359375849b",
            measurementId: "G-P16TS8H0R0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // Expose Firebase functions to global scope for other scripts
        window.getDatabase = getDatabase;
        window.ref = ref;
        window.set = set;
        window.get = get;
        window.child = child;
        window.update = update;
        window.onValue = onValue;
        window.onDisconnect = onDisconnect;
        window.push = push;
        window.serverTimestamp = serverTimestamp;
        window.db = db; // Expose the database instance too

        // Firebase presence system with public access
        console.log('Firebase presence system initializing...');

        // Function to update user's online presence and map
        window.updateUserPresence = function (user, currentMap) {
            console.log('updateUserPresence called with user:', user, 'map:', currentMap);

            if (!user) {
                console.log('updateUserPresence: no user provided');
                return;
            }

            if (!user.uid) {
                console.log('updateUserPresence: user has no uid');
                return;
            }

            try {
                console.log('Setting presence for user', user.uid, 'on map', currentMap);

                // Read current presence data, merge with our data, write back
                const presenceRef = ref(db, 'publicPresence');

                // First read current data
                get(presenceRef).then((snapshot) => {
                    const currentPresence = snapshot.val() || {};
                    console.log('Current Firebase presence:', currentPresence);

                    // Merge our presence data
                    const updatedPresence = {
                        ...currentPresence,
                        [user.uid]: {
                            uid: user.uid,
                            map: currentMap,
                            lastSeen: serverTimestamp(),
                            online: true,
                            characterName: gameState.character?.name || 'Unknown'
                        }
                    };

                    console.log('Writing merged presence data:', updatedPresence);

                    // Write the merged data back
                    set(presenceRef, updatedPresence).then(() => {
                        console.log('✅ Presence set successfully in Firebase for user', user.uid, 'on map', currentMap);
                    }).catch((writeError) => {
                        console.error('❌ Firebase presence write failed:', writeError);
                        // Fallback to localStorage
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        allPresence[user.uid] = updatedPresence[user.uid];
                        localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        console.log('📦 Fallback: Presence set in localStorage');
                    });

                }).catch((readError) => {
                    console.error('❌ Firebase presence read failed:', readError);
                    // Fallback: just write our own data
                    const presenceData = {
                        [user.uid]: {
                            uid: user.uid,
                            map: currentMap,
                            lastSeen: serverTimestamp(),
                            online: true,
                            characterName: gameState.character?.name || 'Unknown'
                        }
                    };

                    set(presenceRef, presenceData).then(() => {
                        console.log('✅ Presence set (new) in Firebase for user', user.uid);
                    }).catch((error) => {
                        console.error('❌ Firebase presence write failed:', error);
                        // Fallback to localStorage
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        allPresence[user.uid] = presenceData[user.uid];
                        localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        console.log('📦 Fallback: Presence set in localStorage');
                    });
                });

            } catch (error) {
                console.error('💥 Exception in updateUserPresence for user', user.uid, ':', error);
                // Fallback to localStorage
                const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                allPresence[user.uid] = {
                    uid: user.uid,
                    map: currentMap,
                    lastSeen: Date.now(),
                    online: true,
                    characterName: gameState.character?.name || 'Unknown'
                };
                localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                console.log('📦 Exception fallback: Presence set in localStorage for user', user.uid);
            }
        };

        // Function to get online players count for a specific map
        window.getOnlinePlayersCount = function (mapName) {
            return new Promise((resolve) => {
                try {
                    // Try Firebase first
                    const presenceRef = ref(db, 'publicPresence');
                    const unsubscribe = onValue(presenceRef, (snapshot) => {
                        try {
                            const allPresence = snapshot.val() || {};
                            console.log('Firebase presence data:', allPresence);
                            console.log('Current user:', window.currentUser?.uid);
                            console.log('Looking for map:', mapName);

                            // Count all online players on this map
                            const playersOnMap = Object.values(allPresence).filter(player => {
                                const matches = player && player.online && player.map === mapName;
                                console.log('Player', player?.uid, 'on map', player?.map, 'online:', player?.online, 'matches:', matches);
                                return matches;
                            });

                            const count = playersOnMap.length;
                            console.log('Firebase count for', mapName, ':', count, 'players found:', playersOnMap.map(p => p.uid));
                            resolve(count || 1); // At least 1 (yourself)

                            // Clean up listener after first read
                            unsubscribe();
                        } catch (error) {
                            console.error('Error processing Firebase presence data:', error);
                            unsubscribe();
                            fallbackToLocalStorage();
                        }
                    }, (error) => {
                        console.log('Firebase read failed, using localStorage fallback:', error.message);
                        fallbackToLocalStorage();
                    });

                    function fallbackToLocalStorage() {
                        try {
                            const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                            console.log('localStorage fallback data:', allPresence);

                            // Count all online players on this map
                            const playersOnMap = Object.values(allPresence).filter(player =>
                                player && player.online && player.map === mapName
                            );

                            const count = playersOnMap.length;
                            console.log('localStorage count for', mapName, ':', count);
                            resolve(count || 1);
                        } catch (error) {
                            console.error('localStorage fallback failed:', error);
                            resolve(1);
                        }
                    }
                } catch (error) {
                    console.error('Error in getOnlinePlayersCount:', error);
                    resolve(1);
                }
            });
        };

        // Debug function to check Firebase presence data
        window.debugPresence = function () {
            console.log('=== DEBUG PRESENCE ===');
            console.log('Current user:', window.currentUser?.uid);
            console.log('Current map:', gameState.currentMap);

            // Check localStorage
            const localData = JSON.parse(localStorage.getItem('playerPresence') || '{}');
            console.log('localStorage presence:', localData);

            // Check Firebase
            const presenceRef = ref(db, 'publicPresence');
            onValue(presenceRef, (snapshot) => {
                const firebaseData = snapshot.val() || {};
                console.log('Firebase presence data:', firebaseData);

                // Count players on current map
                const playersOnMap = Object.values(firebaseData).filter(player =>
                    player && player.online && player.map === gameState.currentMap
                );
                console.log('Players on', gameState.currentMap, ':', playersOnMap.length, playersOnMap.map(p => p.uid));
            }, { onlyOnce: true });
        };

        // Debug function to force refresh all presence
        window.forcePresenceUpdate = function () {
            console.log('=== FORCE PRESENCE UPDATE ===');
            if (window.currentUser) {
                updateUserPresence(window.currentUser, gameState.currentMap);
            }
            setTimeout(() => debugPresence(), 2000);
        };

        // Function to listen for real-time player count updates on current map
        window.listenForMapPlayerUpdates = function (mapName, callback) {
            try {
                // Try Firebase real-time listener first
                const presenceRef = ref(db, 'publicPresence');
                const unsubscribe = onValue(presenceRef, (snapshot) => {
                    try {
                        const allPresence = snapshot.val() || {};
                        console.log('Firebase real-time presence data:', allPresence);

                        // Count all online players on this map
                        const playersOnMap = Object.values(allPresence).filter(player =>
                            player && player.online && player.map === mapName
                        );

                        const count = playersOnMap.length;
                        console.log('Firebase real-time count for', mapName, ':', count);
                        callback(count || 1);
                    } catch (error) {
                        console.error('Error processing Firebase real-time data:', error);
                        callback(1);
                    }
                });

                // Return unsubscribe function
                return unsubscribe;

            } catch (firebaseError) {
                console.log('Firebase real-time failed, using localStorage polling:', firebaseError.message);

                // Fallback to localStorage polling
                const updateCount = () => {
                    try {
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        const playersOnMap = Object.values(allPresence).filter(player =>
                            player && player.online && player.map === mapName
                        );
                        const count = playersOnMap.length;
                        callback(count || 1);
                    } catch (error) {
                        console.error('Error in localStorage polling:', error);
                        callback(1);
                    }
                };

                // Initial call
                updateCount();

                // Set up periodic checks every 5 seconds
                const intervalId = setInterval(updateCount, 5000);

                // Return cleanup function
                return () => clearInterval(intervalId);
            }
        };

        // Failsafe: Hide loading screen after 8 seconds if something goes wrong
        setTimeout(() => {
            const loadingScreen = document.getElementById('auth-loading');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                console.warn('Authentication check timed out. Hiding loading screen.');
                loadingScreen.style.display = 'none';
            }
        }, 8000);

        // Save to Firebase - ORGANIZED STRUCTURE (User's Preferred Order)
        window.saveToFirebase = function (user, data) {
            if (!user) return;

            // Helper function to calculate lifesteal from equipped weapon
            const getLifesteal = () => {
                const weapon = data.character?.equipped?.weapon;
                if (weapon?.lifesteal) {
                    return {
                        chance: weapon.lifesteal.chance || 0,
                        multiplier: weapon.lifesteal.multiplier || 0
                    };
                }
                return { chance: 0, multiplier: 0 };
            };

            // Helper function to calculate damage reduction from equipped armor
            const getDamageReduction = () => {
                const armor = data.character?.equipped?.armor;
                return armor?.damageReduction || 0;
            };

            // CONFLICT DETECTION: Check if cloud data is newer before saving
            const localSaveTime = data.lastSaveTime || Date.now();
            const metadataRef = ref(db, `users/${user.uid}/metadata`);

            get(metadataRef).then((snapshot) => {
                const cloudMetadata = snapshot.val();
                const cloudSaveTime = cloudMetadata?.lastSaveTime || 0;

                // If cloud data is newer than local data, abort save to prevent data loss
                if (cloudSaveTime > localSaveTime) {
                    console.warn('⚠️ CONFLICT DETECTED: Cloud data is newer than local data.');
                    console.warn(`   Cloud timestamp: ${new Date(cloudSaveTime).toISOString()}`);
                    console.warn(`   Local timestamp: ${new Date(localSaveTime).toISOString()}`);
                    console.warn('   ❌ Save aborted to prevent overwriting newer data.');
                    return; // Abort save
                }

                // Organize data into logical categories (User's preferred order)
                const organizedData = {
                    profile: {
                        name: data.character?.name || '',
                        race: data.character?.race || '',
                        gender: data.character?.gender || '',
                        class: data.character?.class || '',
                        location: data.currentMap || data.character?.location || 'HQ'
                    },
                    currency: {
                        leaves: data.currency || 0,
                        coins: data.coins || 0
                    },
                    inventory: {
                        items: data.inventory || [],
                        materials: data.materials || []
                    },
                    stats: {
                        level: data.character?.level || 1,
                        exp: data.character?.exp || 0,
                        maxExp: data.character?.maxExp || 100,
                        hp: data.character?.hp || 100,
                        maxHp: data.character?.maxHp || 100,
                        fp: data.character?.fp || 100,
                        maxFp: data.character?.maxFp || 100,
                        attack: data.character?.attack || 10,
                        defense: data.character?.defense || 5,
                        criticalChance: data.character?.criticalChance || 0.05,
                        lifesteal: getLifesteal(),
                        damageReduction: getDamageReduction()
                    },
                    equipment: {
                        weapon: data.character?.equipped?.weapon || null,
                        armor: data.character?.equipped?.armor || null,
                        accessory1: data.character?.equipped?.accessory1 || null,
                        accessory2: data.character?.equipped?.accessory2 || null,
                        wings: data.character?.equipped?.wings || null
                    },
                    progression: {
                        currentMap: data.currentMap || 'HQ',
                        bosses: data.bosses || {}
                    },
                    exploration: {
                        isExploring: data.isExploring || false,
                        startTime: data.exploreStartTime || null,
                        duration: data.exploreDuration || 0,
                        area: data.exploreArea || null,
                        isTraveling: data.isTraveling || false
                    },
                    settings: {
                        autoPotion: data.autoPotion || false
                    },
                    metadata: {
                        lastSaveTime: Date.now(),
                        version: '2.1' // Updated version with user's preferred structure
                    }
                };

                // Save each category separately (in user's preferred order)
                const updates = {};
                updates[`users/${user.uid}/profile`] = organizedData.profile;
                updates[`users/${user.uid}/currency`] = organizedData.currency;
                updates[`users/${user.uid}/inventory`] = organizedData.inventory;
                updates[`users/${user.uid}/stats`] = organizedData.stats;
                updates[`users/${user.uid}/equipment`] = organizedData.equipment;
                updates[`users/${user.uid}/progression`] = organizedData.progression;
                updates[`users/${user.uid}/exploration`] = organizedData.exploration;
                updates[`users/${user.uid}/settings`] = organizedData.settings;
                updates[`users/${user.uid}/metadata`] = organizedData.metadata;

                // Use update() to save all categories atomically
                update(ref(db), updates)
                    .then(() => {
                        console.log('✅ Data saved to Firebase (Organized Structure v2.1)');
                    })
                    .catch((error) => {
                        console.error('❌ Error saving to Firebase:', error);
                    });
            }).catch((error) => {
                console.error('❌ Error checking cloud timestamp:', error);
                // If we can't check the timestamp, proceed with save (fail-safe)
                console.warn('⚠️ Proceeding with save despite timestamp check failure.');
            });
        };

        // Load from Firebase - SUPPORTS OLD & NEW STRUCTURE
        window.loadFromFirebase = function (user) {
            return new Promise((resolve, reject) => {
                if (!user) {
                    reject('No user provided');
                    return;
                }

                const dbRef = ref(db);

                // First, try to load from NEW organized structure
                get(child(dbRef, `users/${user.uid}/metadata`)).then((metadataSnapshot) => {
                    const version = metadataSnapshot.exists() ? metadataSnapshot.val().version : null;
                    if (version === '2.0' || version === '2.1') {
                        // NEW STRUCTURE EXISTS - Load from organized structure
                        console.log(`📦 Loading from organized structure (v${version})...`);

                        Promise.all([
                            get(child(dbRef, `users/${user.uid}/profile`)),
                            get(child(dbRef, `users/${user.uid}/stats`)),
                            get(child(dbRef, `users/${user.uid}/equipment`)),
                            get(child(dbRef, `users/${user.uid}/inventory`)),
                            get(child(dbRef, `users/${user.uid}/currency`)),
                            get(child(dbRef, `users/${user.uid}/progression`)),
                            get(child(dbRef, `users/${user.uid}/exploration`)),
                            get(child(dbRef, `users/${user.uid}/settings`))
                        ]).then(([profile, stats, equipment, inventory, currency, progression, exploration, settings]) => {
                            // Reconstruct the game data from organized structure
                            const profileData = profile.val() || {};
                            const statsData = stats.val() || {};
                            const equipmentData = equipment.val() || {};
                            const inventoryData = inventory.val() || {};
                            const currencyData = currency.val() || {};
                            const progressionData = progression.val() || {};
                            const explorationData = exploration.val() || {};
                            const settingsData = settings.val() || {};

                            const reconstructedData = {
                                character: {
                                    name: profileData.name,
                                    race: profileData.race,
                                    gender: profileData.gender,
                                    class: profileData.class,
                                    location: profileData.location,
                                    level: statsData.level,
                                    hp: statsData.hp,
                                    maxHp: statsData.maxHp,
                                    fp: statsData.fp,
                                    maxFp: statsData.maxFp,
                                    attack: statsData.attack,
                                    defense: statsData.defense,
                                    exp: statsData.exp,
                                    maxExp: statsData.maxExp,
                                    criticalChance: statsData.criticalChance,
                                    equipped: {
                                        weapon: equipmentData.weapon,
                                        armor: equipmentData.armor,
                                        accessory1: equipmentData.accessory1,
                                        accessory2: equipmentData.accessory2,
                                        wings: equipmentData.wings
                                    }
                                },
                                inventory: inventoryData.items || [],
                                materials: inventoryData.materials || [],
                                currency: currencyData.leaves || 0,
                                coins: currencyData.coins || 0,
                                currentMap: progressionData.currentMap || 'HQ',
                                bosses: progressionData.bosses || {},
                                isExploring: explorationData.isExploring || false,
                                exploreStartTime: explorationData.startTime || null,
                                exploreDuration: explorationData.duration || 0,
                                exploreArea: explorationData.area || null,
                                autoPotion: settingsData.autoPotion || false
                            };

                            localStorage.setItem('rfOnlineGame', JSON.stringify(reconstructedData));

                            // Verify localStorage was set successfully
                            const verifyData = localStorage.getItem('rfOnlineGame');
                            if (verifyData) {
                                console.log('✅ Data loaded from NEW organized structure and saved to localStorage');
                            } else {
                                console.error('❌ Failed to save data to localStorage');
                            }

                            sessionStorage.removeItem('firebaseReloadCount');

                            // Small delay to ensure localStorage is fully written
                            setTimeout(() => {
                                resolve(); // Resolve promise when loading is complete
                            }, 100);
                        }).catch((error) => {
                            console.error('❌ Error loading organized structure:', error);
                            const loadingScreen = document.getElementById('auth-loading');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            reject(error);
                        });
                    } else {
                        // Try to load from OLD flat structure
                        console.log('🔍 Checking for OLD structure...');
                        get(child(dbRef, `users/${user.uid}/character`)).then((snapshot) => {
                            if (snapshot.exists()) {
                                console.log('📦 OLD structure detected! Migrating to NEW structure...');
                                const oldData = snapshot.val();

                                // Save to localStorage
                                localStorage.setItem('rfOnlineGame', JSON.stringify(oldData));

                                // Verify localStorage was set successfully
                                const verifyData = localStorage.getItem('rfOnlineGame');
                                if (verifyData) {
                                    console.log('✅ OLD structure migrated and saved to localStorage');
                                } else {
                                    console.error('❌ Failed to save old data to localStorage');
                                }

                                // Migrate to new structure automatically
                                console.log('🔄 Auto-migrating data to organized structure...');
                                window.saveToFirebase(user, oldData);

                                // Delete old structure after successful migration
                                set(ref(db, `users/${user.uid}/character`), null)
                                    .then(() => {
                                        console.log('🗑️ Old structure cleaned up');
                                    });

                                sessionStorage.removeItem('firebaseReloadCount');

                                // Small delay to ensure localStorage is fully written
                                setTimeout(() => {
                                    resolve(); // Resolve promise
                                }, 100);
                            } else {
                                // No data at all - new player
                                console.log("📝 No cloud data available. New player detected.");
                                localStorage.removeItem('rfOnlineGame');

                                if (!sessionStorage.getItem('newPlayerReset')) {
                                    sessionStorage.setItem('newPlayerReset', 'true');
                                    window.location.reload();
                                } else {
                                    sessionStorage.removeItem('newPlayerReset');
                                }
                                resolve(); // Resolve even for new players
                            }
                        }).catch((error) => {
                            console.error("❌ Error loading from Firebase:", error);
                            const loadingScreen = document.getElementById('auth-loading');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            reject(error);
                        });
                    }
                }).catch((error) => {
                    console.error("❌ Error checking metadata:", error);
                    const loadingScreen = document.getElementById('auth-loading');
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    reject(error);
                });
            });
        };

        // Check authentication state
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                console.log('🚫 No user logged in, redirecting to login page...');
                console.log('📊 Debug Info:');
                console.log('   - Current URL:', window.location.href);
                console.log('   - localStorage:', localStorage.getItem('rfOnlineGame') ? 'HAS DATA' : 'EMPTY');
                console.log('   - sessionStorage:', sessionStorage.getItem('currentSessionId') ? 'HAS SESSION' : 'NO SESSION');

                // Clear any stuck data
                console.log('🧹 Clearing stuck session data...');
                sessionStorage.removeItem('currentSessionId');
                sessionStorage.removeItem('newPlayerReset');
                sessionStorage.removeItem('firebaseReloadCount');

                // Show visual message before redirect
                const loadingScreen = document.getElementById('auth-loading');
                if (loadingScreen) {
                    const loadingText = document.getElementById('loading-text');
                    if (loadingText) {
                        loadingText.innerHTML = '🚫 Not logged in<br><small>Redirecting to login page...</small>';
                        loadingText.style.color = 'var(--danger)';
                    }
                }

                // Delay redirect slightly to allow console logging to be visible
                setTimeout(() => {
                    console.log('🔄 Redirecting to index.html...');
                    window.location.href = 'index.html';
                }, 1000);
            } else {
                console.log('User authenticated:', user.email);
                window.currentUser = user;

                // Set initial presence immediately when user logs in
                setTimeout(() => {
                    if (typeof updateUserPresence === 'function') {
                        updateUserPresence(user, 'HQ'); // Default to HQ when logging in
                    }
                }, 3000); // Wait a bit longer for Firebase to be fully ready

                // SESSION MANAGEMENT: Generate or reuse session ID
                let sessionId = sessionStorage.getItem('currentSessionId');
                if (!sessionId) {
                    // Generate new session ID only if one doesn't exist
                    sessionId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    sessionStorage.setItem('currentSessionId', sessionId);

                    // Write session ID to Firebase only for new sessions
                    set(ref(db, `users/${user.uid}/activeSession`), sessionId)
                        .then(() => {
                            console.log('✅ Session ID set:', sessionId);
                        })
                        .catch((error) => {
                            console.error('❌ Error setting session ID:', error);
                        });
                } else {
                    console.log('✅ Reusing existing session ID:', sessionId);
                }

                // Monitor session changes (skip initial trigger)
                let isFirstCheck = true;
                const sessionRef = ref(db, `users/${user.uid}/activeSession`);
                onValue(sessionRef, (snapshot) => {
                    const activeSessionId = snapshot.val();
                    const currentSessionId = sessionStorage.getItem('currentSessionId');

                    // Skip the first check (initial value)
                    if (isFirstCheck) {
                        isFirstCheck = false;
                        return;
                    }

                    if (activeSessionId && currentSessionId && activeSessionId !== currentSessionId) {
                        console.log('🚫 Session invalidated. Another device logged in.');
                        console.log('📊 Session Debug:');
                        console.log('   - Active Session ID:', activeSessionId);
                        console.log('   - Current Session ID:', currentSessionId);

                        alert('Your account has been logged in from another device. You will be disconnected.');

                        // Clear session data
                        sessionStorage.clear();
                        localStorage.removeItem('rfOnlineGame');

                        // Redirect to login page
                        console.log('🔄 Redirecting to index.html due to session conflict...');
                        window.location.href = 'index.html';
                    }
                });

                // ALWAYS load from Firebase first, then initialize game
                console.log('🔄 Loading data from Firebase...');

                // Update loading text
                const loadingText = document.getElementById('loading-text');
                if (loadingText) loadingText.textContent = 'Loading your character...';

                window.loadFromFirebase(user).then(() => {
                    console.log('✅ Firebase data loaded, initializing game...');
                    initGame();

                    // Hide loading screen after initGame completes
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('auth-loading');
                        if (loadingScreen) {
                            loadingScreen.style.display = 'none';
                            loadingScreen.remove(); // Completely remove from DOM
                        }
                    }, 100); // Reduced from 200ms
                }).catch((error) => {
                    console.error('❌ Failed to load from Firebase:', error);
                    // Fall back to localStorage if Firebase fails
                    console.log('⚠️ Falling back to localStorage...');
                    initGame();

                    // Hide loading screen even on error
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('auth-loading');
                        if (loadingScreen) {
                            loadingScreen.style.display = 'none';
                            loadingScreen.remove(); // Completely remove from DOM
                        }
                    }, 100); // Reduced from 200ms
                });
            }
        });
    </script>

    <script>
        // Game state
        const gameState = {
            character: null,
            isExploring: false,
            exploreTimer: null,
            battleTimer: null,
            stopTimer: null,
            regenTimer: null,
            exploreStartTime: null,
            exploreDuration: 0,
            battleLog: [],
            inventory: [],
            materials: [],
            currency: 0,
            coins: 0,
            autoPotion: true, // Auto Potion enabled by default
            lastPotionTime: 0, // Track last potion use for cooldown
            // BOSS TIMER STATE
            bossCheckTimer: null,        // Timer for 15-min boss checks
            bossEncounterQueued: false,  // Flag: boss queued for next battle
            bossEncountered: false,      // Flag: boss already encountered this exploration
            // ENCOUNTER TRACKING
            encounterStats: {},          // Track monster encounters: { "Monster Name": count }
            // BOSS STATE
            bosses: {
                "Arghol Wasp": {
                    name: "Arghol Wasp",
                    level: 15,
                    maxHp: 5000,
                    currentHp: 5000,
                    attack: 150,
                    defense: 80,
                    isAlive: true,
                    lastDefeated: null
                },
                "Turncoat Knight": {
                    name: "Turncoat Knight",
                    level: 30,
                    maxHp: 10000,
                    currentHp: 10000,
                    attack: 400,
                    defense: 250,
                    isAlive: true,
                    lastDefeated: null
                },
                "Calliana Princess": {
                    name: "Calliana Princess",
                    level: 50,
                    maxHp: 60000,
                    currentHp: 60000,
                    attack: 700,
                    defense: 400,
                    isAlive: true,
                    lastDefeated: null
                }
            },
            currentMap: "HQ" // Default map
        };

        // Class base stats and level up system (Nerfed by ~35% total)
        const classStats = {
            Warrior: { hp: 130, fp: 35, attack: 20, defense: 13, criticalChance: 0.05 },
            Ranger: { hp: 100, fp: 55, attack: 17, defense: 10, criticalChance: 0.10 },
            Mystic: { hp: 85, fp: 100, attack: 14, defense: 6, criticalChance: 0.05 }
        };

        // Level up stat increases (Nerfed by ~35% total)
        const statIncrease = {
            Warrior: { hp: 32, fp: 10, attack: 2, defense: 2 },
            Ranger: { hp: 24, fp: 16, attack: 3, defense: 2 },
            Mystic: { hp: 16, fp: 26, attack: 3, defense: 1 }
        };

        // Race-class mappings
        const raceClasses = {
            Accretia: ["Warrior", "Ranger"],
            Bellato: ["Warrior", "Ranger", "Mystic"],
            Cora: ["Warrior", "Ranger", "Mystic"]
        };

        // Class Skills Definition
        const classSkills = {
            Warrior: [
                { name: "Slash", level: 15, damageMult: 1.3, fpCost: 15, type: "Basic" },
                { name: "Clout Chop", level: 20, damageMult: 1.6, fpCost: 25, type: "Expert" },
                { name: "Pressure", level: 25, damageMult: 2.0, fpCost: 40, type: "Elite" },
                { name: "Bash Explosion", level: 30, damageMult: 2.5, fpCost: 60, type: "Ultimate" }
            ],
            Mystic: [
                { name: "Prism Shard", level: 15, damageMult: 1.3, fpCost: 15, type: "Basic" },
                { name: "Flame Arrow", level: 20, damageMult: 1.6, fpCost: 25, type: "Expert" },
                { name: "Blaze Pearl", level: 25, damageMult: 2.0, fpCost: 40, type: "Elite" },
                { name: "Force Impact", level: 30, damageMult: 2.5, fpCost: 60, type: "Ultimate" }
            ],
            Ranger: [
                { name: "Fast Shot", level: 15, damageMult: 1.3, fpCost: 15, type: "Basic" },
                { name: "Aiming Shot", level: 20, damageMult: 1.6, fpCost: 25, type: "Expert" },
                { name: "Destructive Shot", level: 25, damageMult: 2.0, fpCost: 40, type: "Elite" },
                { name: "Inspired Shell", level: 30, damageMult: 2.5, fpCost: 60, type: "Ultimate" }
            ]
        };

        // Monster definitions
        const monsters = {
            // HQ Monsters
            // 30 mins Exploration Monsters
            "Young Flym": {
                level: 1,
                hp: 18,
                attack: 8,
                defense: 3,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Novice Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.50 },
                    { type: "item", name: "Novice Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.40 },
                    { type: "item", name: "Basic Wings", stats: { attack: 5, defense: 5 }, movementSpeed: 1.0, isWings: true, sellValue: 10, chance: 1.0 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Wing": {
                level: 2,
                hp: 25,
                attack: 12,
                defense: 5,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Novice Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.50 },
                    { type: "item", name: "Novice Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Flym": {
                level: 3,
                hp: 35,
                attack: 15,
                defense: 8,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Novice Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.50 },
                    { type: "item", name: "Novice Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.30 },
                    { type: "item", name: "Novice Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },

            // 1 hour Exploration Monsters
            "Stinkbug": {
                level: 4,
                hp: 45,
                attack: 18,
                defense: 10,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 4, chance: 0.50 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 4, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Desert Klan": {
                level: 5,
                hp: 55,
                attack: 22,
                defense: 12,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 4, chance: 0.50 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 4, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Demolis": {
                level: 6,
                hp: 65,
                attack: 25,
                defense: 15,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 4, chance: 0.50 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 4, chance: 0.30 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 4, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },

            // 6 hours Exploration Monsters
            "Splinter Brat": {
                level: 7,
                hp: 80,
                attack: 30,
                defense: 18,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyrie Sword", stats: { attack: 8 }, sellValue: 7, chance: 0.50 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Hora Tunic", stats: { defense: 8 }, sellValue: 7, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Lunker": {
                level: 8,
                hp: 95,
                attack: 35,
                defense: 22,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyrie Sword", stats: { attack: 8 }, sellValue: 7, chance: 0.50 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Hora Tunic", stats: { defense: 8 }, sellValue: 7, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Warbeast": {
                level: 9,
                hp: 110,
                attack: 40,
                defense: 25,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyrie Sword", stats: { attack: 8 }, sellValue: 7, chance: 0.50 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 7, chance: 0.30 },
                    { type: "item", name: "Hora Tunic", stats: { defense: 8 }, sellValue: 7, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },

            // 12 hours Exploration Monsters
            "Ratmoth": {
                level: 10,
                hp: 130,
                attack: 45,
                defense: 30,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 12, chance: 0.50 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 12, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Snatcher Cheat": {
                level: 11,
                hp: 150,
                attack: 50,
                defense: 35,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 12, chance: 0.50 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 12, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },
            "Splinter": {
                level: 12,
                hp: 180,
                attack: 55,
                defense: 40,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 12, chance: 0.50 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 12, chance: 0.30 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 12, chance: 0.40 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.30 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.30 }
                ]
            },

            // BOSS - Arghol Wasp
            "Arghol Wasp": {
                level: 15,
                hp: 5000,
                attack: 150,
                defense: 80,
                explorationTime: 720,
                map: "HQ",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 50, chance: 1.0 },
                    { type: "item", name: "Arghol Blade", stats: { attack: 15 }, sellValue: 50, chance: 0.5 },
                    { type: "item", name: "Arghol Staff", stats: { attack: 15 }, sellValue: 50, chance: 0.5 },
                    { type: "item", name: "Arghol Bow", stats: { attack: 15 }, sellValue: 50, chance: 0.5 },
                    { type: "item", name: "Arghol Armor", stats: { defense: 15 }, sellValue: 50, chance: 0.5, quantity: 2 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.15 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.12 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.10 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 5 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 1.0, quantity: 5 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 10, chance: 1.0, quantity: 1 }
                ]
            },

            // Sette Desert Monsters
            "Bulky Lunker": {
                level: 25,
                hp: 300,
                attack: 80,
                defense: 60,
                explorationTime: 30,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 15, chance: 1.0 },
                    { type: "item", name: "Bastard Sword", stats: { attack: 20 }, sellValue: 20, chance: 0.05 },
                    { type: "item", name: "Black Wand", stats: { attack: 20 }, sellValue: 20, chance: 0.03 },
                    { type: "item", name: "Long Bow", stats: { attack: 20 }, sellValue: 20, chance: 0.03 },
                    { type: "item", name: "Iron Tunic", stats: { defense: 20 }, sellValue: 20, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Ghost": {
                level: 26,
                hp: 350,
                attack: 90,
                defense: 65,
                explorationTime: 30,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 12, chance: 1.0 },
                    { type: "item", name: "Claymore", stats: { attack: 22 }, sellValue: 22, chance: 0.05 },
                    { type: "item", name: "Field Staff", stats: { attack: 22 }, sellValue: 22, chance: 0.03 },
                    { type: "item", name: "Battle Bow", stats: { attack: 22 }, sellValue: 22, chance: 0.03 },
                    { type: "item", name: "Steel Core", stats: { defense: 22 }, sellValue: 22, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Ghost II": { // Hack for 1 hour
                level: 26,
                hp: 380,
                attack: 95,
                defense: 70,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 15, chance: 1.0 },
                    { type: "item", name: "Claymore", stats: { attack: 22 }, sellValue: 22, chance: 0.05 },
                    { type: "item", name: "Field Staff", stats: { attack: 22 }, sellValue: 22, chance: 0.03 },
                    { type: "item", name: "Battle Bow", stats: { attack: 22 }, sellValue: 22, chance: 0.03 },
                    { type: "item", name: "Steel Core", stats: { defense: 22 }, sellValue: 22, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Rigor Lapis": {
                level: 27,
                hp: 450,
                attack: 100,
                defense: 75,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Raging Wave",
                drops: [
                    { type: "currency", amount: 18, chance: 1.0 },
                    { type: "item", name: "Big Breaker", stats: { attack: 25 }, sellValue: 25, chance: 0.05 },
                    { type: "item", name: "Dual Wand", stats: { attack: 25 }, sellValue: 25, chance: 0.03 },
                    { type: "item", name: "Dual Bow", stats: { attack: 25 }, sellValue: 25, chance: 0.03 },
                    { type: "item", name: "Duple Armor", stats: { defense: 25 }, sellValue: 25, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Rigor Lapis II": { // Hack for 6 hours
                level: 27,
                hp: 500,
                attack: 110,
                defense: 80,
                explorationTime: 360,
                map: "Sette Desert",
                skill: "Raging Wave",
                drops: [
                    { type: "currency", amount: 25, chance: 1.0 },
                    { type: "item", name: "Big Breaker", stats: { attack: 25 }, sellValue: 25, chance: 0.05 },
                    { type: "item", name: "Dual Wand", stats: { attack: 25 }, sellValue: 25, chance: 0.03 },
                    { type: "item", name: "Dual Bow", stats: { attack: 25 }, sellValue: 25, chance: 0.03 },
                    { type: "item", name: "Duple Armor", stats: { defense: 25 }, sellValue: 25, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Grumble Hook": {
                level: 28,
                hp: 550,
                attack: 120,
                defense: 85,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 20, chance: 1.0 },
                    { type: "item", name: "Beam Sword", stats: { attack: 28 }, sellValue: 27, chance: 0.05 },
                    { type: "item", name: "Beam Bead", stats: { attack: 28 }, sellValue: 27, chance: 0.03 },
                    { type: "item", name: "Beam Bow", stats: { attack: 28 }, sellValue: 27, chance: 0.03 },
                    { type: "item", name: "Sprits Cloak", stats: { defense: 28 }, sellValue: 27, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Grumble Hook II": { // Hack for 6 hours
                level: 28,
                hp: 600,
                attack: 130,
                defense: 90,
                explorationTime: 360,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 30, chance: 1.0 },
                    { type: "item", name: "Beam Sword", stats: { attack: 28 }, sellValue: 27, chance: 0.05 },
                    { type: "item", name: "Beam Bead", stats: { attack: 28 }, sellValue: 27, chance: 0.03 },
                    { type: "item", name: "Beam Bow", stats: { attack: 28 }, sellValue: 27, chance: 0.03 },
                    { type: "item", name: "Sprits Cloak", stats: { defense: 28 }, sellValue: 27, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Turncoat": {
                level: 29,
                hp: 700,
                attack: 140,
                defense: 100,
                explorationTime: 60,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 25, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 30, chance: 0.05 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 30, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Turncoat II": { // Hack for 6 hours
                level: 29,
                hp: 750,
                attack: 150,
                defense: 110,
                explorationTime: 360,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 35, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 30, chance: 0.05 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 30, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Turncoat III": { // Hack for 12 hours
                level: 29,
                hp: 800,
                attack: 160,
                defense: 120,
                explorationTime: 720,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 45, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 30, chance: 0.05 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 30, chance: 0.03 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 30, chance: 0.04 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.02 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.01 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.01 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },

            // BOSS - Turncoat Knight
            "Turncoat Knight": {
                level: 30,
                hp: 10000,
                attack: 400,
                defense: 250,
                explorationTime: 720,
                map: "Sette Desert",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 200, chance: 1.0 },
                    { type: "item", name: "Turncoat Sword", stats: { attack: 35 }, sellValue: 75, chance: 0.5 },
                    { type: "item", name: "Turncoat Staff", stats: { attack: 35 }, sellValue: 75, chance: 0.5 },
                    { type: "item", name: "Turncoat Bow", stats: { attack: 35 }, sellValue: 75, chance: 0.5 },
                    { type: "item", name: "Turncoat Armor", stats: { defense: 35 }, sellValue: 75, chance: 0.5, quantity: 2 },
                    { type: "item", name: "Parsal Wristlet A", stats: { attack: 15, defense: 15 }, sellValue: 50, chance: 0.15 },
                    { type: "item", name: "Parsal Wristlet B", stats: { attack: 20, defense: 20 }, sellValue: 75, chance: 0.12 },
                    { type: "item", name: "Parsal Wristlet C", stats: { attack: 25, defense: 25 }, sellValue: 100, chance: 0.10 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 10 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 1.0, quantity: 10 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 10, chance: 1.0, quantity: 2 }

                ]
            },

            // ETHER PLATFORM MONSTERS
            // Wharf Area
            "Chooty": {
                level: 40,
                hp: 1600,
                attack: 200,
                defense: 140,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 50, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.03 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.03 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.03 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.03 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.35 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.35 }
                ]
            },
            "Hobo Mite": {
                level: 41,
                hp: 1700,
                attack: 210,
                defense: 145,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 52, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.37 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.37 }
                ]
            },
            "Hobo Sword": {
                level: 41,
                hp: 1700,
                attack: 210,
                defense: 145,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 52, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.37 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.37 }
                ]
            },
            "Hobo Turnpike": {
                level: 41,
                hp: 1700,
                attack: 210,
                defense: 145,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 52, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.37 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.37 }
                ]
            },
            "Hobo Cutter": {
                level: 41,
                hp: 1700,
                attack: 210,
                defense: 145,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 52, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.04 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.37 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.37 }
                ]
            },
            "Passer Alpha": {
                level: 44,
                hp: 2000,
                attack: 240,
                defense: 160,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 58, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.05 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.05 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.05 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.05 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.40 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.40 }
                ]
            },

            // White Hole Area
            "Hobo Robber": {
                level: 45,
                hp: 2100,
                attack: 250,
                defense: 165,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 60, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.40 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.40 }
                ]
            },
            "Hobo Blade": {
                level: 45,
                hp: 2100,
                attack: 250,
                defense: 165,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 60, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.40 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.40 }
                ]
            },
            "Passer Beta": {
                level: 46,
                hp: 2200,
                attack: 260,
                defense: 170,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 62, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.06 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.42 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.42 }
                ]
            },
            "Calliana Atroc": {
                level: 47,
                hp: 2300,
                attack: 270,
                defense: 175,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 64, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.42 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.42 }
                ]
            },
            "Calliana Crew": {
                level: 47,
                hp: 2300,
                attack: 270,
                defense: 175,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 64, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.42 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.42 }
                ]
            },

            // Lures Lot Area
            "Calliana Atroc II": { // Duplicate for Lures Lot
                level: 47,
                hp: 2300,
                attack: 270,
                defense: 175,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 64, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.42 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.42 }
                ]
            },
            "Calliana Crew II": { // Duplicate for Lures Lot
                level: 47,
                hp: 2300,
                attack: 270,
                defense: 175,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 64, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.07 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.42 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.42 }
                ]
            },
            "Calliana Archer": {
                level: 49,
                hp: 2500,
                attack: 290,
                defense: 185,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 68, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.45 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.45 }
                ]
            },
            "Assassin Builder B": {
                level: 50,
                hp: 2600,
                attack: 300,
                defense: 190,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 70, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.08 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.45 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 0.45 }
                ]
            },

            // BOSS - Calliana Princess (Lures Lot only)
            "Calliana Princess": {
                level: 50,
                hp: 15000,
                attack: 700,
                defense: 400,
                area: "Lures Lot",
                map: "Ether Platform",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 500, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 100, chance: 0.20 },
                    { type: "material", name: "Snowflake", emoji: "❄️", sellValue: 50, chance: 1.0, quantity: 3 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 45, chance: 0.60 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 45, chance: 0.60 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 45, chance: 0.60 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 45, chance: 0.60 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 15 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 2, chance: 1.0, quantity: 15 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 10, chance: 1.0, quantity: 3 }
                ]
            }
        };

        // Crafting Recipes
        const craftingRecipes = {
            // Arghol Series (From Arghol Wasp)
            "T1 Arghol Blade": {
                name: "T1 Arghol Blade",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 100,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Blade", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 500
                }
            },
            "T1 Arghol Staff": {
                name: "T1 Arghol Staff",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 100,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 500
                }
            },
            "T1 Arghol Bow": {
                name: "T1 Arghol Bow",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 100,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 500
                }
            },
            "T1 Arghol Armor": {
                name: "T1 Arghol Armor",
                type: "armor",
                stats: { defense: 50 },
                damageReduction: 0.10,
                sellValue: 100,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 500
                }
            },

            // Turncoat Series (From Turncoat)
            "T1 Turncoat Sword": {
                name: "T1 Turncoat Sword",
                type: "weapon",
                stats: { attack: 80 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 200,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Sword", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 3 },
                    currency: 500
                }
            },
            "T1 Turncoat Staff": {
                name: "T1 Turncoat Staff",
                type: "weapon",
                stats: { attack: 80 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 200,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 3 },
                    currency: 500
                }
            },
            "T1 Turncoat Bow": {
                name: "T1 Turncoat Bow",
                type: "weapon",
                stats: { attack: 80 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 200,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 3 },
                    currency: 500
                }
            },
            "T1 Turncoat Armor": {
                name: "T1 Turncoat Armor",
                type: "armor",
                stats: { defense: 80 },
                damageReduction: 0.15,
                sellValue: 200,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 3 },
                    currency: 500
                }
            },

            // Intense Series (From Turncoat Knight & Calliana Princess) - Removed for now
            /*
            "T1 Intense Sword": {
                name: "T1 Intense Sword",
                type: "weapon",
                stats: { attack: 120 },
                lifesteal: { chance: 0.15, multiplier: 0.20 },
                sellValue: 500,
                rarity: "t1",
                requirements: {
                    item: { name: "Intense Sword", upgradeLevel: 5 },
                    materials: { "Red Gem": 10, "Blue Gem": 10, "Shiny Gem": 5 },
                    currency: 2000
                }
            },
            "T1 Intense Staff": {
                name: "T1 Intense Staff",
                type: "weapon",
                stats: { attack: 120 },
                lifesteal: { chance: 0.15, multiplier: 0.20 },
                sellValue: 500,
                rarity: "t1",
                requirements: {
                    item: { name: "Intense Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 10, "Blue Gem": 10, "Shiny Gem": 5 },
                    currency: 2000
                }
            },
            "T1 Intense Bow": {
                name: "T1 Intense Bow",
                type: "weapon",
                stats: { attack: 120 },
                lifesteal: { chance: 0.15, multiplier: 0.20 },
                sellValue: 500,
                rarity: "t1",
                requirements: {
                    item: { name: "Intense Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 10, "Blue Gem": 10, "Shiny Gem": 5 },
                    currency: 2000
                }
            },
            "T1 Intense Armor": {
                name: "T1 Intense Armor",
                type: "armor",
                stats: { defense: 120 },
                sellValue: 500,
                rarity: "t1",
                requirements: {
                    item: { name: "Intense Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 10, "Blue Gem": 10, "Shiny Gem": 5 },
                    currency: 2000
                }
            },
            "T1 Intense Greatsword": {
                name: "T1 Intense Greatsword",
                type: "weapon",
                stats: { attack: 150 },
                lifesteal: { chance: 0.15, multiplier: 0.20 },
                sellValue: 800,
                rarity: "t1",
                requirements: {
                    item: { name: "Intense Greatsword", upgradeLevel: 5 },
                    materials: { "Red Gem": 15, "Blue Gem": 15, "Shiny Gem": 8 },
                    currency: 3000
                }
            }
            */
        };

        // Upgrade system
        const upgradeSystem = {
            // Upgrade bonuses per level
            bonuses: {
                1: { attack: 5, defense: 5 },
                2: { attack: 10, defense: 10 },
                3: { attack: 15, defense: 15 },
                4: { attack: 20, defense: 20 },
                5: { attack: 25, defense: 25 },
                6: { attack: 30, defense: 30 },
                7: { attack: 35, defense: 35 },
            },
            // Success chances per level
            chances: {
                1: 1.0,  // 100%
                2: 0.9,  // 90%
                3: 0.8,  // 80%
                4: 0.7,  // 70%
                5: 0.6,  // 60%
                6: 0.5,  // 50%
                7: 0.4   // 40%
            },
            // Cost per level - Weapons use Red Gems, Armors use Blue Gems
            costs: {
                1: { "Red Gem": 1, "Blue Gem": 1, "currency": 100 },
                2: { "Red Gem": 2, "Blue Gem": 2, "currency": 100 },
                3: { "Red Gem": 3, "Blue Gem": 3, "currency": 100 },
                4: { "Red Gem": 4, "Blue Gem": 4, "currency": 100 },
                5: { "Red Gem": 5, "Blue Gem": 5, "currency": 100 },
                6: { "Red Gem": 6, "Blue Gem": 6, "currency": 100 },
                7: { "Red Gem": 7, "Blue Gem": 7, "currency": 100 }
            },
            // Destroy on +5, +6, +7 failure
            destroyOnFailure: [5, 6, 7]
        };

        // DOM elements
        const registrationModal = document.getElementById('registration-modal');
        const playersModal = document.getElementById('players-modal');
        const mapsModal = document.getElementById('maps-modal');
        const marketModal = document.getElementById('market-modal');
        const upgradeModal = document.getElementById('upgrade-modal');
        const exploreBtn = document.getElementById('explore-btn');
        const exploreOptions = document.getElementById('explore-options');
        const stopBtn = document.getElementById('stop-btn');
        const playersBtn = document.getElementById('players-btn');
        const mapsBtn = document.getElementById('maps-btn');
        const createCharacterBtn = document.getElementById('create-character-btn');
        const battleLog = document.getElementById('battle-log');
        const inventoryItems = document.getElementById('inventory-items');
        const materialsItems = document.getElementById('materials-items');
        const emptyInventory = document.getElementById('empty-inventory');
        const emptyMaterials = document.getElementById('empty-materials');
        const exploreStatus = document.getElementById('explore-status');
        const exploreTimer = document.getElementById('explore-timer');
        const upgradeItemInfo = document.getElementById('upgrade-item-info');
        const upgradeResult = document.getElementById('upgrade-result');
        const upgradeConfirmBtn = document.getElementById('upgrade-confirm-btn');
        const upgradeCancelBtn = document.getElementById('upgrade-cancel-btn');
        const inventoryLimit = document.getElementById('inventory-limit');
        const setteDessetMap = document.getElementById('sette-desset-map');
        const craftingModal = document.getElementById('crafting-modal');
        const craftBtn = document.getElementById('craft-btn');
        const craftConfirmBtn = document.getElementById('craft-confirm-btn');
        const craftCancelBtn = document.getElementById('craft-cancel-btn');
        const recipeList = document.getElementById('recipe-list');

        // Current item being upgraded
        let currentUpgradeItem = null;
        let selectedRecipe = null;

        // Process offline battles
        function processOfflineBattles(count, map, duration, area = null) {
            const char = gameState.character;
            let totalExp = 0;
            let totalCurrency = 0;
            let totalDrops = [];
            let battlesWon = 0;
            let battlesLost = 0;

            // Get monsters for this exploration
            let availableMonsters;
            if (area) {
                // Area-based exploration (Ether Platform)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.area === area && monster.map === map
                );
            } else {
                // Time-based exploration (HQ, Sette Desert)
                const exploreMinutes = duration / 60000;
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.explorationTime === exploreMinutes && monster.map === map
                );
            }

            if (availableMonsters.length === 0) return;

            for (let i = 0; i < count; i++) {
                const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                const [monsterName, monster] = availableMonsters[randomIndex];

                // Simplified Battle Logic for Offline
                // Assume player wins if level is sufficient, or use simple stats comparison
                // For now, let's give the player the benefit of the doubt for offline progress
                // unless they are severely underleveled.

                let playerWins = true;
                if (char.level < monster.level - 5) {
                    // 50% chance if underleveled
                    playerWins = Math.random() > 0.5;
                }

                if (playerWins) {
                    battlesWon++;

                    // EXP
                    if (char.level < 40) {
                        // Use the new formula: Monster Level * 3
                        const expGain = monster.level * 1;
                        totalExp += expGain;
                    }

                    // Currency
                    if (monster.drops) {
                        monster.drops.forEach(drop => {
                            if (Math.random() < drop.chance) {
                                if (drop.type === 'currency') {
                                    totalCurrency += drop.amount;
                                } else {
                                    totalDrops.push({ ...drop, itemName: drop.name }); // Store item name
                                }
                            }
                        });
                    }
                } else {
                    battlesLost++;
                }
            }

            // Apply Results
            if (totalExp > 0) {
                char.exp += totalExp;
                while (char.exp >= char.maxExp && char.level < 40) {
                    char.exp -= char.maxExp;
                    char.level++;
                    char.maxExp = Math.floor(50 * Math.pow(1.2, char.level - 1));

                    // Update stats
                    const base = classStats[char.class];
                    const increases = statIncrease[char.class];
                    char.maxHp += increases.hp;
                    char.maxFp += increases.fp;
                    char.attack += increases.attack;
                    char.defense += increases.defense;

                    char.hp = char.maxHp;
                    char.fp = char.maxFp;
                }
            }

            gameState.currency += totalCurrency;

            // Process Drops
            const consolidatedDrops = {};
            totalDrops.forEach(drop => {
                if (drop.type === 'item' || drop.type === 'material') {
                    const name = drop.itemName;
                    if (!consolidatedDrops[name]) {
                        consolidatedDrops[name] = { ...drop, count: 0 };
                    }
                    consolidatedDrops[name].count++;
                }
            });

            // Add to inventory
            Object.values(consolidatedDrops).forEach(drop => {
                if (drop.type === 'material') {
                    const existingMat = gameState.materials.find(m => m.name === drop.name);
                    if (existingMat) {
                        existingMat.quantity += drop.count;
                    } else {
                        gameState.materials.push({
                            name: drop.name,
                            sellValue: drop.sellValue,
                            quantity: drop.count,
                            type: 'material'
                        });
                    }
                } else if (drop.type === 'item') {
                    // For items, we add them individually or stack if stackable (but equipment isn't stackable usually)
                    // In this game, equipment is individual.
                    // Limit offline equipment drops to avoid inventory overflow?
                    // Let's add up to 10 items to avoid spam, convert rest to currency?
                    // For now, just add them.
                    for (let k = 0; k < drop.count; k++) {
                        // Check inventory limit
                        if (gameState.inventory.length >= 20) {
                            // Only log once per item type to avoid spam
                            if (k === 0) {
                                addToBattleLog(`Inventory full! Could not pick up remaining ${drop.name}s.`, 'warning');
                            }
                            continue;
                        }

                        gameState.inventory.push({
                            name: drop.name,
                            stats: { ...drop.stats },
                            sellValue: drop.sellValue,
                            quantity: 1,
                            type: 'item',
                            upgradeLevel: 0,
                            rarity: 'common'
                        });
                    }
                }
            });

            // Log Summary
            addToBattleLog(`📝 Offline Report: Won ${battlesWon} battles.`, 'success');
            if (totalExp > 0) addToBattleLog(`✨ Gained ${totalExp} EXP.`, 'exp');
            if (totalCurrency > 0) addToBattleLog(`💰 Gained ${totalCurrency} Leaves.`, 'gold');

            const dropNames = Object.keys(consolidatedDrops);
            if (dropNames.length > 0) {
                addToBattleLog(`📦 Looted: ${dropNames.join(', ')}`, 'loot');
            }

            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameState();
        }

        // Resume exploration
        function resumeExploration(remainingTime, savedData) {
            addToBattleLog(`Resuming exploration... ${formatExplorationTime(Math.floor(remainingTime / 60000))} remaining.`);

            // Restore UI state
            exploreOptions.style.display = 'none';
            exploreBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            exploreStatus.style.display = 'flex';
            // Restore exploreArea if it exists
            if (savedData.exploreArea) {
                gameState.exploreArea = savedData.exploreArea;
                document.getElementById('explore-selected-time').textContent = `Explore Time: ${savedData.exploreArea}`;
            } else {
                const minutes = gameState.exploreDuration / 60000;
                let displayText;
                if (minutes < 60) {
                    displayText = `${minutes}m`;
                } else {
                    displayText = `${minutes / 60}h`;
                }
                document.getElementById('explore-selected-time').textContent = `Explore Time: ${displayText}`;
            }


            // Restart timers
            gameState.exploreTimer = setInterval(() => {
                const elapsed = Date.now() - gameState.exploreStartTime;
                const remaining = Math.max(0, gameState.exploreDuration - elapsed);

                const elapsedMinutes = Math.floor(elapsed / 60000);
                const elapsedSeconds = Math.floor((elapsed % 60000) / 1000);

                exploreTimer.textContent = `Elapsed ${Math.floor(elapsedMinutes)}:${elapsedSeconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    finishExploration();
                }

                // Auto-save every minute
                if (elapsedSeconds === 0) {
                    saveGameState();
                }
            }, 1000);

            startBattles();
        }

        // Initialize the game
        function initGame() {
            // Check if character exists in localStorage with integrity validation
            const savedData = loadGameState();

            if (savedData) {
                gameState.character = savedData.character;
                // Initialize new properties if they don't exist in saved data (for migration)
                if (savedData.currency === undefined) savedData.currency = 0;
                if (savedData.coins === undefined) savedData.coins = savedData.gold || 0;
                if (savedData.materials === undefined) savedData.materials = [];

                gameState.inventory = savedData.inventory || [];
                gameState.materials = savedData.materials || [];
                gameState.currency = savedData.currency || 0;
                gameState.coins = savedData.coins || 0; // Load coins
                gameState.currentMap = savedData.currentMap || "HQ";

                // Load boss state if exists, otherwise use default
                if (savedData.bosses) {
                    // Merge saved boss data with defaults, ensuring all bosses have required properties
                    Object.keys(gameState.bosses).forEach(bossName => {
                        if (savedData.bosses[bossName]) {
                            // Merge saved data but ensure isAlive is set
                            gameState.bosses[bossName] = {
                                ...gameState.bosses[bossName],
                                ...savedData.bosses[bossName],
                                // If isAlive is undefined in saved data, default to true
                                isAlive: savedData.bosses[bossName].isAlive !== undefined ? savedData.bosses[bossName].isAlive : true
                            };
                        }
                        // If boss doesn't exist in saved data, keep default (isAlive: true)
                    });
                } else if (savedData.boss) {
                    // Migrate old single boss state
                    gameState.bosses["Arghol Wasp"] = {
                        ...gameState.bosses["Arghol Wasp"],
                        ...savedData.boss,
                        isAlive: savedData.boss.isAlive !== undefined ? savedData.boss.isAlive : true
                    };
                }

                // TEMPORARILY DISABLED: RESUME EXPLORATION IF IT WAS IN PROGRESS
                // This was causing issues where exploration would resume even after death
                /*
                if (savedData.isExploring) {
                    gameState.isExploring = true;
                    gameState.exploreStartTime = Date.now(); // Reset start time to now
                    gameState.exploreDuration = savedData.exploreDuration;
                    gameState.currentMap = savedData.currentMap;

                    // Resume exploration with full duration (no offline progress)
                    addToBattleLog(`🔄 Resuming exploration in ${savedData.currentMap}...`, 'info');
                    resumeExploration(savedData.exploreDuration, savedData);
                }
                */


                // Force update boss static stats (MaxHP, Level, etc.) from source
                // This fixes issues where old save data has outdated boss stats (e.g. Turncoat Knight 25k HP)
                const defaultBosses = {
                    "Arghol Wasp": { maxHp: 5000, attack: 150, defense: 80, level: 15 },
                    "Turncoat Knight": { maxHp: 10000, attack: 400, defense: 250, level: 30 },
                    "Calliana Princess": { maxHp: 60000, attack: 700, defense: 400, level: 50 }
                };

                Object.entries(defaultBosses).forEach(([bossName, stats]) => {
                    if (gameState.bosses[bossName]) {
                        gameState.bosses[bossName].maxHp = stats.maxHp;
                        gameState.bosses[bossName].attack = stats.attack;
                        gameState.bosses[bossName].defense = stats.defense;
                        gameState.bosses[bossName].level = stats.level;
                        // Clamp current HP to new Max HP
                        if (gameState.bosses[bossName].currentHp > stats.maxHp) {
                            gameState.bosses[bossName].currentHp = stats.maxHp;
                        }
                    }
                });

                // Fix object references lost during JSON serialization and recalculate stats
                if (gameState.character.equipped) {
                    const char = gameState.character;

                    // Initialize ALL equipment slots if they don't exist (for old/corrupted saves)
                    if (!char.equipped.weapon) char.equipped.weapon = null;
                    if (!char.equipped.armor) char.equipped.armor = null;
                    if (!char.equipped.accessory1) char.equipped.accessory1 = null;
                    if (!char.equipped.accessory2) char.equipped.accessory2 = null;
                    if (!char.equipped.hasOwnProperty('wings')) {
                        char.equipped.wings = null;
                    }

                    const slots = ['weapon', 'armor', 'accessory1', 'accessory2', 'wings'];
                    const claimedItems = new Set();

                    // Reset stats to base (Class + Level) to ensure accuracy
                    const base = classStats[char.class];
                    const increases = statIncrease[char.class];
                    const levels = char.level - 1;

                    char.maxHp = Math.floor(base.hp + (levels * increases.hp));
                    char.maxFp = Math.floor(base.fp + (levels * increases.fp));
                    char.attack = Math.floor(base.attack + (levels * increases.attack));
                    char.defense = Math.floor(base.defense + (levels * increases.defense));
                    char.criticalChance = base.criticalChance || 0.05; // Reset crit chance

                    // Recalculate MaxExp with exponential 1.3 curve
                    char.maxExp = Math.floor(50 * Math.pow(1.2, char.level - 1));

                    // MIGRATION FIX: For characters at level 30+ who were capped before
                    // Ensure they have proper maxExp and can gain experience
                    if (char.level >= 30 && char.level < 40) {
                        // If maxExp is suspiciously low (less than expected for level 30), recalculate
                        const expectedMaxExp = Math.floor(100 * Math.pow(1.3, char.level - 1));
                        if (char.maxExp < expectedMaxExp * 0.9) { // 10% tolerance
                            char.maxExp = expectedMaxExp;
                            addToBattleLog(`✨ Level cap increased! You can now level up to 40!`, 'level');
                        }
                    }

                    // Re-link equipped items and apply stats
                    slots.forEach(slot => {
                        if (char.equipped[slot]) {
                            const savedItem = char.equipped[slot];
                            // Find matching item in inventory
                            const match = gameState.inventory.find(i =>
                                !claimedItems.has(i) &&
                                i.name === savedItem.name &&
                                i.upgradeLevel === savedItem.upgradeLevel &&
                                JSON.stringify(i.stats) === JSON.stringify(savedItem.stats)
                            );

                            if (match) {
                                // Re-link reference to inventory object
                                char.equipped[slot] = match;
                                claimedItems.add(match);

                                // Apply stats
                                const itemLevel = match.upgradeLevel || 0;
                                const isAccessory = slot.includes('accessory');
                                const isWings = slot === 'wings';

                                if (isAccessory || isWings) {
                                    // Accessories and Wings have both attack and defense
                                    char.attack += match.stats.attack || 0;
                                    char.defense += match.stats.defense || 0;
                                } else {
                                    const isArmor = slot === 'armor';
                                    const statType = isArmor ? 'defense' : 'attack';
                                    const bonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                                    char[statType] += (match.stats[statType] || 0) + bonus;
                                }
                            } else {
                                // Ghost item found! Clear it.
                                console.warn(`Removed ghost item from ${slot}: ${savedItem.name}`);
                                char.equipped[slot] = null;
                            }
                        }
                    });
                }

                // Check boss respawn
                checkBossRespawn();

                updateCharacterDisplay();
                updateInventoryDisplay();
                updateMapsAccessibility(); // Update map access based on level

                // Set up user presence in Firebase (will initialize after delay)
                if (window.currentUser) {
                    // Presence will be set up when Firebase is ready
                    setTimeout(() => {
                        if (typeof updateUserPresence === 'function') {
                            console.log('Setting user presence for map:', gameState.currentMap);
                            updateUserPresence(window.currentUser, gameState.currentMap);
                        }
                    }, 2500);
                }

                // Show player count immediately
                updateMapPlayersDisplay();

                // Start real-time map player updates
                setTimeout(() => {
                    startMapPlayerUpdates();
                }, 2500);

                // Fix UI if exploration finished but UI wasn't reset
                if (!gameState.isExploring) {
                    exploreBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    exploreStatus.style.display = 'flex';
                    document.getElementById('explore-selected-time').textContent = 'AFK';
                    document.getElementById('explore-timer').textContent = '';
                    mapsBtn.disabled = false;
                    mapsBtn.style.opacity = '1';
                    mapsBtn.style.cursor = 'pointer';

                    // Enable Maps button (center panel)
                    const mapsMainBtnInit = document.getElementById('maps-main-btn');
                    if (mapsMainBtnInit) {
                        mapsMainBtnInit.disabled = false;
                        mapsMainBtnInit.style.opacity = '1';
                        mapsMainBtnInit.style.cursor = 'pointer';
                    }
                }

                // Start HP regeneration timer
                startHPRegeneration();
            } else {
                // Show registration modal if no character exists
                registrationModal.style.display = 'flex';
            }

            // Set up event listeners
            setupEventListeners();
        }

        // Save game state to localStorage
        async function saveGameState() {
            const gameData = {
                character: gameState.character,
                inventory: gameState.inventory,
                materials: gameState.materials,
                currency: gameState.currency,
                coins: gameState.coins,
                currentMap: gameState.currentMap,
                bosses: gameState.bosses,
                // Exploration State
                isExploring: gameState.isExploring,
                exploreStartTime: gameState.exploreStartTime,
                exploreDuration: gameState.exploreDuration,
                exploreArea: gameState.exploreArea || null, // Ensure not undefined
                autoPotion: gameState.autoPotion,
                lastSaveTime: Date.now()
            };

            // SIMPLE ANTI-CHEAT: Only detect extreme console manipulation
            // This won't interfere with normal gameplay
            const violations = detectConsoleCheat(gameData);
            if (violations.length > 0) {
                console.error('🚫 CONSOLE CHEAT DETECTED:', violations);

                // Log to Firebase
                for (const violation of violations) {
                    await logCheatAttempt('console_manipulation', violation);
                }

                // Show warning
                addToBattleLog('⚠️ Console manipulation detected. Save blocked.', 'danger');
                return; // Block save
            }

            // Generate checksum
            const checksum = generateChecksum(gameData);

            // Save with checksum
            const saveData = {
                data: gameData,
                checksum: checksum,
                timestamp: Date.now()
            };

            localStorage.setItem('rfOnlineGame', JSON.stringify(saveData));

            // Sync with Firebase
            if (window.saveToFirebase && window.currentUser) {
                console.log('Attempting to sync with Firebase...');
                // Deep clone and sanitize to remove any other undefined values
                const cleanData = JSON.parse(JSON.stringify(gameData));
                window.saveToFirebase(window.currentUser, cleanData);
            } else {
                console.log('Skipping Firebase sync: saveToFirebase or currentUser missing', {
                    hasSaveFn: !!window.saveToFirebase,
                    user: window.currentUser
                });
            }
        }

        // ============================================
        // SECURITY: Data Integrity System
        // ============================================

        // Generate checksum for data validation
        function generateChecksum(data) {
            const str = JSON.stringify(data);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }

        // Validate data integrity
        function validateDataIntegrity(data, checksum) {
            const calculatedChecksum = generateChecksum(data);
            return calculatedChecksum === checksum;
        }

        // Log cheat attempt to Firebase
        async function logCheatAttempt(cheatType, details) {
            if (!window.currentUser) {
                console.warn('Cannot log cheat: No user authenticated');
                return;
            }

            const timestamp = Date.now();
            // Use global Firebase functions exposed in module script
            const db = window.getDatabase ? window.getDatabase() : null;

            if (!db) {
                console.error('❌ Firebase not initialized or not accessible globally');
                return;
            }

            const cheatLogRef = window.ref(db, `cheatLogs/${window.currentUser.uid}/${timestamp}`);

            const logData = {
                userId: window.currentUser.uid,
                email: window.currentUser.email,
                characterName: gameState.character?.name || 'Unknown',
                cheatType: cheatType,
                details: details,
                timestamp: timestamp,
                timestampReadable: new Date(timestamp).toISOString(),
                userAgent: navigator.userAgent,
                screenResolution: `${window.screen.width}x${window.screen.height}`
            };

            try {
                await window.set(cheatLogRef, logData);
                console.error('🚫 CHEAT LOGGED TO FIREBASE:', cheatType, details);
                console.log('📍 Firebase path:', `cheatLogs/${window.currentUser.uid}/${timestamp}`);
            } catch (error) {
                console.error('❌ Failed to log cheat to Firebase:', error);
            }
        }

        // SIMPLE CONSOLE CHEAT DETECTION
        // Only detects extreme, impossible jumps that indicate console manipulation
        // Does NOT interfere with normal gameplay
        function detectConsoleCheat(data) {
            const violations = [];
            const char = data.character;

            if (!char) return violations;

            // Get previous save for comparison
            let previousData = null;
            try {
                const savedGame = localStorage.getItem('rfOnlineGame');
                if (savedGame) {
                    const parsed = JSON.parse(savedGame);
                    previousData = parsed.data || parsed;
                }
            } catch (error) {
                // No previous save, allow
                return violations;
            }

            if (!previousData || !previousData.character) {
                return violations; // First save, allow
            }

            const prevChar = previousData.character;

            // 1. EXTREME level jump (5+ levels at once = console cheat)
            const levelDiff = char.level - prevChar.level;
            if (levelDiff >= 3) {
                violations.push({
                    type: 'extreme_level_jump',
                    before: prevChar.level,
                    after: char.level,
                    difference: levelDiff,
                    reason: `Level jumped ${levelDiff} levels at once (console manipulation)`
                });
            }

            // 2. EXTREME currency jump (100k+ at once = console cheat)
            const currencyDiff = data.currency - previousData.currency;
            if (currencyDiff >= 999) {
                violations.push({
                    type: 'extreme_currency_jump',
                    before: previousData.currency,
                    after: data.currency,
                    difference: currencyDiff,
                    reason: `Currency jumped by ${currencyDiff} (console manipulation)`
                });
            }

            // 3. EXTREME coins jump (10k+ at once = console cheat)
            const coinsDiff = data.coins - previousData.coins;
            if (coinsDiff >= 500) {
                violations.push({
                    type: 'extreme_coins_jump',
                    before: previousData.coins,
                    after: data.coins,
                    difference: coinsDiff,
                    reason: `Coins jumped by ${coinsDiff} (console manipulation)`
                });
            }

            // 4. EXTREME inventory jump (50+ items at once = console cheat)
            const invDiff = data.inventory.length - previousData.inventory.length;
            if (invDiff >= 50) {
                violations.push({
                    type: 'extreme_inventory_jump',
                    before: previousData.inventory.length,
                    after: data.inventory.length,
                    difference: invDiff,
                    reason: `Inventory jumped by ${invDiff} items (console manipulation)`
                });
            }

            return violations;
        }

        // Modified loadGameState with checksum validation
        function loadGameState() {
            const savedGame = localStorage.getItem('rfOnlineGame');
            if (!savedGame) return null;

            try {
                const saveData = JSON.parse(savedGame);

                // Check if old format (no checksum)
                if (!saveData.checksum) {
                    console.warn('⚠️ Old save format detected. Migrating...');
                    return saveData; // Old format, accept it
                }

                // Validate checksum
                if (!validateDataIntegrity(saveData.data, saveData.checksum)) {
                    console.error('🚫 DATA CORRUPTION DETECTED!');

                    // Log the cheat attempt
                    logCheatAttempt('localStorage_manipulation', {
                        attemptedData: saveData.data,
                        reason: 'Checksum mismatch'
                    });

                    addToBattleLog('⚠️ Save data corruption detected. Loading from cloud...', 'warning');

                    // Clear corrupted local save
                    localStorage.removeItem('rfOnlineGame');

                    // Force reload from Firebase
                    if (window.currentUser) {
                        window.loadFromFirebase(window.currentUser).then(() => {
                            location.reload();
                        });
                    }
                    return null;
                }

                return saveData.data;
            } catch (error) {
                console.error('Failed to load save data:', error);
                return null;
            }
        }

        // Check if boss should respawn
        function checkBossRespawn() {
            Object.values(gameState.bosses).forEach(boss => {
                if (!boss.isAlive && boss.lastDefeated) {
                    const timeSinceDefeat = Date.now() - boss.lastDefeated;
                    const respawnTime = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                    if (timeSinceDefeat >= respawnTime) {
                        // Respawn boss
                        boss.isAlive = true;
                        boss.currentHp = boss.maxHp;
                        boss.lastDefeated = null;
                        addToBattleLog(`👾 ${boss.name} has respawned!`);
                    }
                }
            });
            saveGameState();
        }

        function changeMap(mapName) {
            gameState.currentMap = mapName;
            // Update character location
            if (gameState.character) {
                gameState.character.location = mapName;
                document.getElementById('char-location').textContent = mapName;
            }
            addToBattleLog(`Traveling to ${mapName}...`);

            // Update user's presence in Firebase with new map
            if (window.currentUser && typeof updateUserPresence === 'function') {
                updateUserPresence(window.currentUser, mapName);
            }

            // Update map players display
            updateMapPlayersDisplay();

            // Update map selection UI
            document.querySelectorAll('.map-item').forEach(mapItem => {
                mapItem.style.border = 'none';
            });
            document.getElementById(`${mapName.toLowerCase().replace(' ', '-')}-map`).style.border = '2px solid var(--accent-color)';

            saveGameState();
        }

        // Show maps modal
        function showMaps() {
            updateMapsAccessibility();
            mapsModal.style.display = 'flex';
        }

        // Update maps accessibility based on level
        function updateMapsAccessibility() {
            const char = gameState.character;
            if (!char) return;

            // HQ: Always accessible
            const hqMap = document.getElementById('hq-map');
            if (hqMap) {
                hqMap.classList.add('map-unlocked');


                hqMap.onclick = () => {
                    changeMap('HQ');
                    mapsModal.style.display = 'none';
                };
            }

            // Sette Desert: Level 20+
            const setteMap = document.getElementById('sette-desset-map');
            if (setteMap) {
                if (char.level >= 20) {
                    setteMap.classList.add('map-unlocked');
                    setteMap.style.opacity = '1';
                    setteMap.style.cursor = 'pointer';


                    setteMap.onclick = () => {
                        changeMap('Sette Desert');
                        mapsModal.style.display = 'none';
                    };
                    const levelText = setteMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.style.color = 'var(--success)';
                        levelText.textContent = 'Level 20+ (Unlocked)';
                    }
                } else {
                    setteMap.classList.remove('map-unlocked');
                    setteMap.style.opacity = '0.5';
                    setteMap.style.cursor = 'not-allowed';
                    setteMap.onclick = null;
                    const levelText = setteMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.style.color = 'var(--text-dim)';
                        levelText.textContent = 'Level 20+ (Locked)';
                    }
                }
            }

            // Ether Platform: Level 30+
            const etherMap = document.getElementById('ether-platform-map');
            if (etherMap) {
                if (char.level >= 30) {
                    etherMap.classList.add('map-unlocked');
                    etherMap.style.opacity = '1';
                    etherMap.style.cursor = 'pointer';


                    etherMap.onclick = () => {
                        // Check for travel cost (1000 Leaves)
                        if (gameState.currentMap === 'Ether Platform') {
                            addToBattleLog('You are already at Ether Platform.', 'warning');
                            return;
                        }

                        if (gameState.currency >= 1000) {
                            if (confirm('Travel to Ether Platform? Cost: 1000 Leaves')) {
                                gameState.currency -= 1000;
                                document.getElementById('currency-amount').textContent = gameState.currency;
                                changeMap('Ether Platform');
                                mapsModal.style.display = 'none';
                            }
                        } else {
                            addToBattleLog('Not enough Leaves to travel to Ether Platform (Cost: 1000).', 'warning');
                        }
                    };
                    const levelText = etherMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.innerHTML = 'Level 30+ <span style="color: var(--success); font-size: 0.8rem;">(Unlocked)</span>';
                    }
                } else {
                    etherMap.classList.remove('map-unlocked');
                    etherMap.style.opacity = '0.5';
                    etherMap.style.cursor = 'not-allowed';
                    etherMap.onclick = null;
                    const levelText = etherMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.innerHTML = 'Level 30+ <span style="color: var(--text-dim); font-size: 0.8rem;">(Locked)</span>';
                    }
                }
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Race selection
            document.querySelectorAll('.race-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.race-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');

                    const race = option.getAttribute('data-race');

                    // Update gender selection visibility
                    const genderSelection = document.getElementById('gender-selection');
                    if (race === 'Accretia') {
                        genderSelection.style.display = 'none';
                        // Clear any selected gender
                        document.querySelectorAll('.gender-option').forEach(g => g.classList.remove('selected'));
                    } else {
                        genderSelection.style.display = 'block';
                    }

                    // Update class options
                    updateClassOptions(race);
                });
            });

            // Gender selection
            document.querySelectorAll('.gender-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.gender-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                });
            });

            // Class selection
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('class-option')) {
                    document.querySelectorAll('.class-option').forEach(o => o.classList.remove('selected'));
                    e.target.classList.add('selected');
                }
            });

            // Create character button
            createCharacterBtn.addEventListener('click', createCharacter);

            // Explore button
            exploreBtn.addEventListener('click', () => {
                const isVisible = exploreOptions.style.display === 'flex';
                exploreOptions.style.display = isVisible ? 'none' : 'flex';

                // Show/hide appropriate buttons based on current map
                if (!isVisible) {
                    const isEtherPlatform = gameState.currentMap === 'Ether Platform';
                    document.querySelectorAll('.time-based-explore').forEach(el => {
                        el.style.display = isEtherPlatform ? 'none' : 'block';
                    });
                    document.querySelectorAll('.area-based-explore').forEach(el => {
                        el.style.display = isEtherPlatform ? 'block' : 'none';
                    });
                }
            });

            // Time-based exploration buttons (HQ, Sette Desert)
            document.getElementById('explore-30').addEventListener('click', () => startExploration(30));
            document.getElementById('explore-60').addEventListener('click', () => startExploration(60));
            document.getElementById('explore-360').addEventListener('click', () => startExploration(360));
            document.getElementById('explore-720').addEventListener('click', () => startExploration(720));

            // Area-based exploration buttons (Ether Platform)
            document.getElementById('explore-wharf').addEventListener('click', () => startExploration('Wharf'));
            document.getElementById('explore-white-hole').addEventListener('click', () => startExploration('White Hole'));
            document.getElementById('explore-lures-lot').addEventListener('click', () => startExploration('Lures Lot'));

            // Stop button
            stopBtn.addEventListener('click', stopExploration);

            // Players button
            playersBtn.addEventListener('click', showPlayers);

            // Maps button (navigation)
            mapsBtn.addEventListener('click', showMaps);

            // Market button
            const marketBtn = document.getElementById('market-btn');
            if (marketBtn) {
                marketBtn.addEventListener('click', showMarket);
            }

            // Market confirm sell button
            const confirmSellBtn = document.getElementById('confirm-sell-btn');
            if (confirmSellBtn) {
                confirmSellBtn.addEventListener('click', confirmSell);
            }

            // Clean up presence when user leaves
            window.addEventListener('beforeunload', () => {
                if (window.currentUser) {
                    try {
                        // Try Firebase cleanup first
                        const presenceRef = ref(db, `publicPresence/${window.currentUser.uid}`);
                        set(presenceRef, null).catch(() => {
                            // Firebase cleanup failed, try localStorage
                            const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                            delete allPresence[window.currentUser.uid];
                            localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        });
                    } catch (error) {
                        console.error('Error cleaning up presence:', error);
                    }
                }
            });

            // Maps button (center panel)
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.addEventListener('click', showMaps);
            }

            // Craft button
            craftBtn.addEventListener('click', openCraftingModal);
            craftCancelBtn.addEventListener('click', closeCraftingModal);
            craftConfirmBtn.addEventListener('click', async () => {
                // 1. Add pulsing class and disable
                craftConfirmBtn.classList.add('btn-pulsing');
                craftConfirmBtn.disabled = true;

                // 2. Wait 2 seconds (3 pulses)
                await new Promise(resolve => setTimeout(resolve, 2000));

                // 3. Remove pulsing class
                craftConfirmBtn.classList.remove('btn-pulsing');

                // 4. Execute logic
                craftItem();

                // 5. Change to "Crafted!" and Green
                // Note: craftItem checks for selectedRecipe, so we should only change UI if successful?
                // But craftItem doesn't return success/fail. It checks inside.
                // We'll assume if it runs, it was clickable (enabled).
                if (selectedRecipe) {
                    craftConfirmBtn.textContent = "Crafted!";
                    craftConfirmBtn.classList.add('btn-success');

                    // Reset after 2 seconds
                    setTimeout(() => {
                        craftConfirmBtn.textContent = "Craft";
                        craftConfirmBtn.classList.remove('btn-success');
                        craftConfirmBtn.disabled = false; // Re-enable
                        // Re-check requirements to set disabled state correctly
                        if (selectedRecipe) selectRecipe(selectedRecipe);
                    }, 2000);
                }
            });

            // Upgrade buttons
            upgradeConfirmBtn.addEventListener('click', async () => {
                // 1. Add pulsing class and disable
                upgradeConfirmBtn.classList.add('btn-pulsing');
                upgradeConfirmBtn.disabled = true;
                const originalText = upgradeConfirmBtn.textContent;

                // 2. Wait 2 seconds (3 pulses)
                await new Promise(resolve => setTimeout(resolve, 2000));

                // 3. Remove pulsing class and re-enable
                upgradeConfirmBtn.classList.remove('btn-pulsing');
                upgradeConfirmBtn.disabled = false;

                // 4. Execute logic
                confirmUpgrade();
            });
            upgradeCancelBtn.addEventListener('click', () => {
                upgradeModal.style.display = 'none';
                currentUpgradeItem = null;
            });

            // Logout button
            const authBtn = document.getElementById('auth-btn');
            if (authBtn) {
                authBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to logout?')) {
                        // Sign out from Firebase
                        import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js')
                            .then(({ getAuth, signOut }) => {
                                const auth = getAuth();
                                signOut(auth).then(() => {
                                    window.location.href = 'index.html';
                                });
                            });
                    }
                });
            }

            // Reset game button
            document.getElementById('reset-game-btn').addEventListener('click', function () {
                if (confirm('Are you sure you want to reset your progress? This cannot be undone.')) {
                    localStorage.removeItem('rfOnlineSave');
                    location.reload();
                }
            });



            // Add Leaves button
            document.getElementById('add-leaves-btn').addEventListener('click', function () {
                gameState.currency += 10000;
                document.getElementById('currency-amount').textContent = gameState.currency;
                addToBattleLog('Added 10,000 Leaves 🍃', 'success');
                saveGameState();
                // Refresh crafting modal if open to update requirements
                if (document.getElementById('crafting-modal').style.display === 'flex') {
                    renderRecipes();
                }
            });

            // Add Gems button
            document.getElementById('add-gems-btn').addEventListener('click', function () {
                const redGem = gameState.materials.find(m => m.name === 'Red Gem');
                const blueGem = gameState.materials.find(m => m.name === 'Blue Gem');

                if (redGem) {
                    redGem.quantity += 100;
                } else {
                    gameState.materials.push({ name: 'Red Gem', sellValue: 1, quantity: 100, type: 'material' });
                }

                if (blueGem) {
                    blueGem.quantity += 100;
                } else {
                    gameState.materials.push({ name: 'Blue Gem', sellValue: 2, quantity: 100, type: 'material' });
                }

                updateInventoryDisplay();
                addToBattleLog('Added 100 Red Gems and 100 Blue Gems! 💎', 'success');
                saveGameState();
            });

            // Add Test Gear button
            document.getElementById('add-gear-btn').addEventListener('click', function () {
                const playerClass = gameState.character.class;
                let weaponName = '';

                // Determine weapon based on class
                if (playerClass === 'Warrior') {
                    weaponName = 'Turncoat Sword';
                } else if (playerClass === 'Mystic') {
                    weaponName = 'Turncoat Staff';
                } else if (playerClass === 'Ranger') {
                    weaponName = 'Turncoat Bow';
                }

                // Add weapon
                gameState.inventory.push({
                    name: weaponName,
                    stats: { attack: 35 },
                    sellValue: 75,
                    quantity: 1,
                    type: 'weapon',
                    upgradeLevel: 0,
                    rarity: 'common'
                });

                // Add armor
                gameState.inventory.push({
                    name: 'Turncoat Armor',
                    stats: { defense: 35 },
                    sellValue: 75,
                    quantity: 1,
                    type: 'armor',
                    upgradeLevel: 0,
                    rarity: 'common'
                });

                updateInventoryDisplay();
                addToBattleLog(`Added ${weaponName} and Turncoat Armor! ⚔️🛡️`, 'success');
                saveGameState();
            });

            // Kill Arghol Wasp Debug
            document.getElementById('kill-arghol-btn').addEventListener('click', function () {
                const boss = monsters["Arghol Wasp"];
                if (boss) {
                    checkDrops(boss);
                    addToBattleLog('Debug: Arghol Wasp killed and looted! 🗡️', 'success');
                } else {
                    addToBattleLog('Debug: Arghol Wasp not found!', 'warning');
                }
            });

            // Export Save
            document.getElementById('export-save-btn').addEventListener('click', function () {
                const saveData = localStorage.getItem('rfOnlineGame');
                if (!saveData) {
                    addToBattleLog('No save data found!', 'warning');
                    return;
                }
                const encodedSave = btoa(saveData);

                // Try to copy to clipboard
                navigator.clipboard.writeText(encodedSave).then(() => {
                    addToBattleLog('Save code copied to clipboard! 📋', 'success');
                    alert('Save code copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    // Fallback
                    prompt("Copy this code manually:", encodedSave);
                });
            });

            // Import Save
            const importModal = document.getElementById('import-modal');
            const importTextarea = document.getElementById('import-textarea');
            const importConfirmBtn = document.getElementById('import-confirm-btn');
            const importCancelBtn = document.getElementById('import-cancel-btn');

            document.getElementById('import-save-btn').addEventListener('click', function () {
                importModal.style.display = 'flex';
                importTextarea.value = '';
                importTextarea.focus();
            });

            importCancelBtn.addEventListener('click', function () {
                importModal.style.display = 'none';
            });

            importConfirmBtn.addEventListener('click', function () {
                const encodedSave = importTextarea.value.trim();
                if (!encodedSave) return;

                try {
                    const decodedSave = atob(encodedSave);
                    const parsed = JSON.parse(decodedSave);

                    // Basic validation
                    if (!parsed.character || !parsed.inventory) {
                        throw new Error("Invalid save file format");
                    }

                    if (confirm("This will overwrite your current progress. Are you sure?")) {
                        localStorage.setItem('rfOnlineGame', decodedSave);
                        alert("Save imported successfully! Reloading...");
                        location.reload();
                    }
                } catch (e) {
                    alert("Invalid save code! Please check and try again.");
                    console.error(e);
                }
            });

            // Instant finish button
            // Instant finish button - REMOVED (Element missing)
            // document.getElementById('instant-finish-btn')?.addEventListener('click', instantFinishExploration);

            // Global click listener for modals
            window.addEventListener('click', (e) => {
                if (e.target === registrationModal) {
                    // Prevent closing registration modal by clicking outside
                } else if (e.target === playersModal) {
                    playersModal.style.display = 'none';
                } else if (e.target === mapsModal) {
                    mapsModal.style.display = 'none';
                } else if (e.target === marketModal) {
                    marketModal.style.display = 'none';
                } else if (e.target === upgradeModal) {
                    upgradeModal.style.display = 'none';
                } else if (e.target === craftingModal) {
                    craftingModal.style.display = 'none';
                } else if (e.target === importModal) {
                    importModal.style.display = 'none';
                }
            });

            // Close buttons
            document.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', () => {
                    playersModal.style.display = 'none';
                    mapsModal.style.display = 'none';
                    upgradeModal.style.display = 'none';
                    craftingModal.style.display = 'none';
                    importModal.style.display = 'none';
                });
            });
        }

        // Update class options based on selected race
        function updateClassOptions(race) {
            const classOptions = document.getElementById('class-options');
            classOptions.innerHTML = '';

            raceClasses[race].forEach(className => {
                const classOption = document.createElement('div');
                classOption.className = 'class-option';
                classOption.textContent = className;
                classOptions.appendChild(classOption);
            });
        }

        // Create a new character
        function createCharacter() {
            const nameInput = document.getElementById('char-name-input');
            const selectedRace = document.querySelector('.race-option.selected');
            const selectedGender = document.querySelector('.gender-option.selected');
            const selectedClass = document.querySelector('.class-option.selected');

            // Check if Accretia race (no gender required)
            const isAccretia = selectedRace && selectedRace.getAttribute('data-race') === 'Accretia';

            if (!nameInput.value || !selectedRace || !selectedClass ||
                (!isAccretia && !selectedGender)) {
                alert('Please fill in all character details.');
                return;
            }

            const race = selectedRace.getAttribute('data-race');
            const gender = isAccretia ? 'None' : selectedGender.getAttribute('data-gender');
            const charClass = selectedClass.textContent;

            // Create character object
            gameState.character = {
                name: nameInput.value,
                race: race,
                gender: gender,
                class: charClass,
                level: 1,
                exp: 0,
                maxExp: 100,
                hp: classStats[charClass].hp,
                maxHp: classStats[charClass].hp,
                fp: classStats[charClass].fp,
                maxFp: classStats[charClass].fp,
                attack: classStats[charClass].attack,
                defense: classStats[charClass].defense,
                location: `${race} HQ`,
                equipped: {
                    weapon: null,
                    armor: null,
                    accessory1: null,
                    accessory2: null,
                    wings: null  // Dedicated Wings slot
                },
                criticalChance: classStats[charClass].criticalChance || 0.05
            };

            // Save game state
            saveGameState();

            // Update display and close modal
            updateCharacterDisplay();
            registrationModal.style.display = 'none';

            // Start HP regeneration timer
            startHPRegeneration();

            // Add welcome message to battle log
            addToBattleLog(`Welcome, ${gameState.character.name}! Your journey begins at ${gameState.character.location}.`);
        }

        // Update character display
        function updateCharacterDisplay() {
            const char = gameState.character;
            if (!char) return;

            sanitizeStats();

            document.getElementById('char-name').textContent = char.name;
            document.getElementById('char-race').textContent = char.race;
            document.getElementById('char-gender').textContent = char.gender;
            document.getElementById('char-class').textContent = char.class;
            // Use currentMap as the source of truth for location
            document.getElementById('char-location').textContent = gameState.currentMap || char.location;
            document.getElementById('char-level').textContent = char.level;
            document.getElementById('char-hp').textContent = char.hp;
            document.getElementById('char-fp').textContent = char.fp;
            document.getElementById('char-attack').textContent = char.attack;
            document.getElementById('char-defense').textContent = char.defense;
            document.getElementById('char-crit').textContent = Math.floor((char.criticalChance || 0.05) * 100) + '%';

            // Update EXP text display
            document.getElementById('char-exp').textContent = `${char.exp}/${char.maxExp}`;

            // Update Lifesteal Display
            const lifestealContainer = document.getElementById('lifesteal-stat-container');
            const lifestealValue = document.getElementById('char-lifesteal');

            if (char.equipped.weapon && char.equipped.weapon.lifesteal) {
                lifestealContainer.style.display = 'flex';
                lifestealValue.textContent = `${Math.round(char.equipped.weapon.lifesteal.chance * 100)}%`;
            } else {
                lifestealContainer.style.display = 'none';
            }

            // Update Damage Reduction Display
            const dmgRedContainer = document.getElementById('dmg-red-stat-container');
            const dmgRedValue = document.getElementById('char-dmg-red');

            if (char.equipped.armor && char.equipped.armor.damageReduction) {
                dmgRedContainer.style.display = 'flex';
                dmgRedValue.textContent = `${Math.round(char.equipped.armor.damageReduction * 100)}%`;
            } else {
                dmgRedContainer.style.display = 'none';
            }

            // Update Speed Display (Movement Speed from Wings)
            const speedContainer = document.getElementById('speed-stat-container');
            const speedValue = document.getElementById('char-speed');

            let totalMovementSpeed = 0;
            if (char.equipped.accessory1?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory1.movementSpeed;
            }
            if (char.equipped.accessory2?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory2.movementSpeed;
            }
            if (char.equipped.wings?.movementSpeed) {
                totalMovementSpeed += char.equipped.wings.movementSpeed;
            }

            if (totalMovementSpeed > 0) {
                speedContainer.style.display = 'flex';
                speedValue.textContent = totalMovementSpeed;
            } else {
                speedContainer.style.display = 'none';
            }

            // Update progress bars
            document.querySelector('.exp-bar').style.width = `${(char.exp / char.maxExp) * 100}%`;
            document.querySelector('.hp-bar').style.width = `${(char.hp / char.maxHp) * 100}%`;
            document.querySelector('.fp-bar').style.width = `${(char.fp / char.maxFp) * 100}%`;

            // Update Skills Display
            const mySkills = classSkills[char.class] || [];
            const basicSkill = mySkills.find(s => s.type === 'Basic');
            const expertSkill = mySkills.find(s => s.type === 'Expert');
            const eliteSkill = mySkills.find(s => s.type === 'Elite');
            const ultimateSkill = mySkills.find(s => s.type === 'Ultimate');

            const basicEl = document.getElementById('skill-basic');
            const expertEl = document.getElementById('skill-expert');
            const eliteEl = document.getElementById('skill-elite');
            const ultimateEl = document.getElementById('skill-ultimate');

            if (basicSkill) {
                if (char.level >= basicSkill.level) {
                    basicEl.textContent = basicSkill.name;
                    basicEl.className = 'skill-value unlocked';
                } else {
                    basicEl.textContent = `Unlocks at Lv${basicSkill.level}`;
                    basicEl.className = 'skill-value locked';
                }
            }

            if (expertSkill) {
                if (char.level >= expertSkill.level) {
                    expertEl.textContent = expertSkill.name;
                    expertEl.className = 'skill-value unlocked';
                } else {
                    expertEl.textContent = `Unlocks at Lv${expertSkill.level}`;
                    expertEl.className = 'skill-value locked';
                }
            }

            if (eliteSkill) {
                if (char.level >= eliteSkill.level) {
                    eliteEl.textContent = eliteSkill.name;
                    eliteEl.className = 'skill-value unlocked';
                } else {
                    eliteEl.textContent = `Unlocks at Lv${eliteSkill.level}`;
                    eliteEl.className = 'skill-value locked';
                }
            }

            if (ultimateSkill) {
                if (char.level >= ultimateSkill.level) {
                    ultimateEl.textContent = ultimateSkill.name;
                    ultimateEl.className = 'skill-value unlocked';
                } else {
                    ultimateEl.textContent = `Unlocks at Lv${ultimateSkill.level}`;
                    ultimateEl.className = 'skill-value locked';
                }
            }

            // Update maps accessibility
            updateMapsAccessibility();
        }

        function updateMapPlayersDisplay() {
            const currentMap = gameState.currentMap;
            const element = document.getElementById('explore-map-players');

            if (!element) {
                console.error('explore-map-players element not found!');
                return;
            }

            // Get online players count from localStorage
            getOnlinePlayersCount(currentMap).then(count => {
                element.textContent = `Map Players: ${count}`;
            }).catch(error => {
                console.error('Error getting online players count:', error);
                element.textContent = `Map Players: 1`;
            });
        }

        // Start listening for real-time map player updates
        function startMapPlayerUpdates() {
            const currentMap = gameState.currentMap;

            // First, update the display immediately
            updateMapPlayersDisplay();

            // Set up periodic updates for player count
            if (typeof listenForMapPlayerUpdates === 'function') {
                listenForMapPlayerUpdates(currentMap, (count) => {
                    document.getElementById('explore-map-players').textContent = `Map Players: ${count}`;
                });
            }
        }

        // Update maps accessibility based on level
        // Update maps accessibility based on level
        function updateMapsAccessibility() {
            const hqMap = document.getElementById('hq-map');
            const setteMap = document.getElementById('sette-desset-map');
            const etherMap = document.getElementById('ether-platform-map');

            // Reset styles
            hqMap.style.border = 'none';
            setteMap.style.border = 'none';
            etherMap.style.border = 'none';

            // Highlight current map
            if (gameState.currentMap === 'HQ') {
                hqMap.style.border = '2px solid var(--accent-color)';
            } else if (gameState.currentMap === 'Sette Desert') {
                setteMap.style.border = '2px solid var(--accent-color)';
            } else if (gameState.currentMap === 'Ether Platform') {
                etherMap.style.border = '2px solid var(--accent-color)';
            }

            // HQ Click Handler
            hqMap.onclick = async () => {
                if (gameState.currentMap !== 'HQ') {
                    // Special check for Ether Platform return - NO PULSE
                    if (gameState.currentMap === 'Ether Platform') {
                        if (gameState.currency >= 1000) {
                            if (confirm("Purchase a ticket to HQ for 1,000 Leaves? (Travel time: 3 mins)")) {
                                gameState.currency -= 1000;
                                document.getElementById('currency-amount').textContent = gameState.currency;
                                mapsModal.style.display = 'none';
                                startHQTravel();
                            }
                        } else {
                            addToBattleLog('You need 1,000 Leaves to buy a ticket to HQ.', 'warning');
                        }
                        return;
                    }

                    // Standard instant travel for other maps (e.g. Sette) - WITH PULSE
                    // Add pulsing and disable all maps
                    hqMap.classList.add('btn-pulsing');
                    setteMap.style.pointerEvents = 'none';
                    etherMap.style.pointerEvents = 'none';
                    hqMap.style.pointerEvents = 'none';

                    // Wait 2 seconds (3 pulses)
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Remove pulsing
                    hqMap.classList.remove('btn-pulsing');
                    setteMap.style.pointerEvents = '';
                    etherMap.style.pointerEvents = '';
                    hqMap.style.pointerEvents = '';

                    gameState.currentMap = 'HQ';
                    document.getElementById('char-location').textContent = gameState.currentMap;
                    addToBattleLog('Traveled to HQ.');
                    mapsModal.style.display = 'none';
                    updateMapsAccessibility();
                    saveGameState();
                }
            };
            // Sette Desert Logic
            if (gameState.currentMap === 'Ether Platform') {
                setteMap.style.opacity = '0.5';
                setteMap.style.cursor = 'not-allowed';
                setteMap.onclick = () => {
                    addToBattleLog('You cannot travel directly to Sette Desert from Ether Platform.', 'warning');
                };
            } else {
                setteMap.style.opacity = '1';
                setteMap.style.cursor = 'pointer';

                setteMap.onclick = async () => {
                    if (gameState.currentMap !== 'Sette Desert') {
                        if (gameState.character.level >= 20) {
                            // Add pulsing and disable all maps
                            setteMap.classList.add('btn-pulsing');
                            hqMap.style.pointerEvents = 'none';
                            etherMap.style.pointerEvents = 'none';
                            setteMap.style.pointerEvents = 'none';

                            // Wait 2 seconds (3 pulses)
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            // Remove pulsing
                            setteMap.classList.remove('btn-pulsing');
                            hqMap.style.pointerEvents = '';
                            etherMap.style.pointerEvents = '';
                            setteMap.style.pointerEvents = '';

                            // Execute travel
                            gameState.currentMap = 'Sette Desert';
                            document.getElementById('char-location').textContent = gameState.currentMap;
                            addToBattleLog('Traveled to Sette Desert.');
                            mapsModal.style.display = 'none';
                            updateMapsAccessibility();
                            saveGameState();
                        } else {
                            addToBattleLog('You need to be Level 20 to enter Sette Desert.', 'warning');
                        }
                    }
                };
            }

            // Ether Platform Click Handler
            if (gameState.currentMap === 'Sette Desert') {
                etherMap.style.opacity = '0.5';
                etherMap.style.cursor = 'not-allowed';
                etherMap.onclick = () => {
                    addToBattleLog('You cannot travel directly to Ether Platform from Sette Desert.', 'warning');
                };
            } else {
                etherMap.style.opacity = '1';
                etherMap.style.cursor = 'pointer';

                etherMap.onclick = () => {
                    if (gameState.currentMap !== 'Ether Platform') {
                        if (gameState.currentMap !== 'HQ') {
                            addToBattleLog('You can only take the ship to Ether Platform from HQ.', 'warning');
                            return;
                        }

                        if (gameState.character.level >= 30) {
                            if (gameState.currency >= 1000) {
                                // NO PULSE - Direct confirmation
                                if (confirm("Purchase a ticket to Ether Platform for 1,000 Leaves? (Travel time: 3 mins)")) {
                                    gameState.currency -= 1000;
                                    document.getElementById('currency-amount').textContent = gameState.currency;
                                    mapsModal.style.display = 'none';
                                    startEtherTravel();
                                }
                            } else {
                                addToBattleLog('You need 1,000 Leaves to buy a ticket to Ether Platform.', 'warning');
                            }
                        } else {
                            addToBattleLog('You need to be Level 30 to enter Ether Platform.', 'warning');
                        }
                    }
                };
            }
        }

        // Flat EXP system for balanced monster rewards
        function getMonsterExpGain(monsterName, monster) {
            // HQ Monsters: 10-300 EXP (current values)
            const hqExpValues = {
                'Young Flym': 15,
                'Wing': 20,
                'Flym': 26,
                'Stinkbug': 34,
                'Desert Klan': 44,
                'Demolis': 57,
                'Splinter Brat': 74,
                'Lunker': 94,
                'Warbeast': 122,
                'Ratmoth': 163,
                'Snatcher Cheat': 212,
                'Splinter': 276,
                'Arghol Wasp': 300
            };

            // Sette Desert Monsters: 200-500 EXP
            const setteExpValues = {
                'Bulky Lunker': 220,
                'Ghost': 240,
                'Ghost II': 250,
                'Rigor Lapis': 280,
                'Rigor Lapis II': 300,
                'Grumble Hook': 350,
                'Grumble Hook II': 370,
                'Turncoat': 420,
                'Turncoat II': 450,
                'Turncoat III': 480,
                'Turncoat Knight': 500
            };

            // Ether Platform Monsters: 500-1,000 EXP
            const etherExpValues = {
                'Chooty': 520,
                'Hobo Mite': 550,
                'Hobo Sword': 560,
                'Hobo Turnpike': 570,
                'Hobo Cutter': 580,
                'Passer Alpha': 650,
                'Hobo Robber': 700,
                'Hobo Blade': 720,
                'Passer Beta': 780,
                'Calliana Atroc': 850,
                'Calliana Crew': 880,
                'Calliana Princess': 1000
            };

            // Return EXP based on monster name (works for all maps)
            if (hqExpValues[monsterName]) return hqExpValues[monsterName];
            if (setteExpValues[monsterName]) return setteExpValues[monsterName];
            if (etherExpValues[monsterName]) return etherExpValues[monsterName];

            // Fallback for unknown monsters
            return 100;
        }

        // Handle Ship Travel
        function startEtherTravel() {
            gameState.isTraveling = true;

            // Disable controls
            exploreBtn.disabled = true;
            mapsBtn.disabled = true;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }
            exploreBtn.style.opacity = '0.5';
            exploreBtn.style.cursor = 'not-allowed';
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            addToBattleLog("Ticket purchased. Boarding the transport ship...", "info");

            // Show travel status
            exploreStatus.style.display = 'flex';
            document.getElementById('explore-selected-time').textContent = "Traveling to Ether";

            let timeLeft = 180; // 3 minutes
            addToBattleLog(`Ship departs! Estimated travel time: 3 minutes.`);

            const travelTimer = setInterval(() => {
                timeLeft--;
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                exploreTimer.textContent = `Arriving in ${mins}:${secs.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(travelTimer);
                    completeEtherTravel();
                }
            }, 1000);
        }

        function completeEtherTravel() {
            gameState.isTraveling = false;
            gameState.currentMap = 'Ether Platform';

            // Reset UI
            exploreStatus.style.display = 'none';
            exploreBtn.disabled = false;
            mapsBtn.disabled = false;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = false;
                mapsMainBtn.style.opacity = '1';
                mapsMainBtn.style.cursor = '';
            }
            exploreBtn.style.opacity = '1';
            exploreBtn.style.cursor = '';
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = '';

            addToBattleLog("You have arrived at Ether Platform.", "success");

            // Update UI
            updateMapsAccessibility();
            document.getElementById('char-location').textContent = gameState.currentMap;
            saveGameState();
        }

        // Handle HQ Travel (Return trip)
        function startHQTravel() {
            gameState.isTraveling = true;

            // Disable controls
            exploreBtn.disabled = true;
            mapsBtn.disabled = true;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }
            exploreBtn.style.opacity = '0.5';
            exploreBtn.style.cursor = 'not-allowed';
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            addToBattleLog("Ticket purchased. Boarding the transport ship to HQ...", "info");

            // Show travel status
            exploreStatus.style.display = 'flex';
            document.getElementById('explore-selected-time').textContent = "Traveling to HQ";

            let timeLeft = 180; // 3 minutes
            addToBattleLog(`Ship departs! Estimated travel time: 3 minutes.`);

            const travelTimer = setInterval(() => {
                timeLeft--;
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                exploreTimer.textContent = `Arriving in ${mins}:${secs.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(travelTimer);
                    completeHQTravel();
                }
            }, 1000);
        }

        function completeHQTravel() {
            gameState.isTraveling = false;
            gameState.currentMap = 'HQ';

            // Reset UI
            exploreStatus.style.display = 'none';
            exploreBtn.disabled = false;
            mapsBtn.disabled = false;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = false;
                mapsMainBtn.style.opacity = '1';
                mapsMainBtn.style.cursor = '';
            }
            exploreBtn.style.opacity = '1';
            exploreBtn.style.cursor = '';
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = '';

            addToBattleLog("You have arrived at HQ.", "success");

            // Update UI
            updateMapsAccessibility();
            document.getElementById('char-location').textContent = gameState.currentMap;
            saveGameState();
        }

        // Show maps modal
        function showMaps() {
            // Hide explore options when Maps is opened
            exploreOptions.style.display = 'none';
            updateMapsAccessibility();
            mapsModal.style.display = 'flex';

            // Add hover effects to all unlocked maps
            console.log('showMaps called, adding hover effects');
            const char = gameState.character;
            if (char) {
                // HQ - always unlocked
                const hqMap = document.getElementById('hq-map');
                if (hqMap) {
                    hqMap.style.transition = 'all 0.1s ease';
                    hqMap.addEventListener('mouseenter', () => {
                        console.log('Hovering HQ');
                        hqMap.style.opacity = '0.7';
                        hqMap.style.transform = 'translateY(-1px)';
                    });
                    hqMap.addEventListener('mouseleave', () => {
                        hqMap.style.opacity = '1';
                        hqMap.style.transform = 'translateY(0)';
                    });
                }

                // Sette Desert - level 20+ AND not in Ether Platform
                if (char.level >= 20 && gameState.currentMap !== 'Ether Platform') {
                    const setteMap = document.getElementById('sette-desset-map');
                    if (setteMap) {
                        setteMap.style.transition = 'all 0.1s ease';
                        setteMap.addEventListener('mouseenter', () => {
                            console.log('Hovering Sette');
                            setteMap.style.opacity = '0.7';
                            setteMap.style.transform = 'translateY(-1px)';
                        });
                        setteMap.addEventListener('mouseleave', () => {
                            setteMap.style.opacity = '1';
                            setteMap.style.transform = 'translateY(0)';
                        });
                    }
                }

                // Ether Platform - level 30+ AND not in Sette Desert
                if (char.level >= 30 && gameState.currentMap !== 'Sette Desert') {
                    const etherMap = document.getElementById('ether-platform-map');
                    if (etherMap) {
                        etherMap.style.transition = 'all 0.1s ease';
                        etherMap.addEventListener('mouseenter', () => {
                            console.log('Hovering Ether');
                            etherMap.style.opacity = '0.7';
                            etherMap.style.transform = 'translateY(-1px)';
                        });
                        etherMap.addEventListener('mouseleave', () => {
                            etherMap.style.opacity = '1';
                            etherMap.style.transform = 'translateY(0)';
                        });
                    }
                }
            }
        }




        // Update encounter tracker display
        function updateEncounterDisplay() {
            const encounterList = document.getElementById('encounter-list');
            const encounterTracker = document.getElementById('encounter-tracker');

            // Show tracker if has encounters (even after exploration ends)
            if (Object.keys(gameState.encounterStats).length > 0) {
                encounterTracker.style.display = 'block';
            } else {
                encounterTracker.style.display = 'none';
                return;
            }

            // Sort by count (descending)
            const sorted = Object.entries(gameState.encounterStats)
                .sort((a, b) => b[1] - a[1]);

            // Build HTML
            encounterList.innerHTML = sorted.map(([name, count]) => `
                <div class="encounter-item">
                    <span class="encounter-name">${name}</span>
                    <span class="encounter-count">×${count}</span>
                </div>
            `).join('');
        }

        // Get boss name for current map
        function getMapBossName() {
            const mapBosses = {
                "HQ": "Arghol Wasp",
                "Sette Desert": "Turncoat Knight",
                "Ether Platform": "Calliana Princess"
            };
            return mapBosses[gameState.currentMap] || null;
        }

        // Check for boss encounter (called after 5 minutes in 12h exploration)
        function checkBossEncounter() {
            if (!gameState.isExploring) return;
            if (gameState.bossEncountered) return; // Already encountered

            const mapBossName = getMapBossName();
            if (!mapBossName) {
                console.log("No boss for this map");
                return;
            }

            const mapBoss = gameState.bosses[mapBossName];
            if (!mapBoss || !mapBoss.isAlive) {
                console.log("Boss is dead or missing:", mapBossName);
                return;
            }

            // 100% guaranteed boss encounter
            gameState.bossEncounterQueued = true;
            gameState.bossEncountered = true;
            console.log("Boss encounter queued:", mapBossName);
            addToBattleLog(`⚠️ You sense a powerful presence nearby...`, 'warning');
        }


        // Start exploration
        function startExploration(param) {
            if (gameState.isExploring) {
                addToBattleLog('You are already exploring!');
                return;
            }

            exploreOptions.style.display = 'none';
            gameState.isExploring = true;

            // Determine if this is time-based or area-based exploration
            const isAreaBased = typeof param === 'string';
            let minutes, area, displayText;

            if (isAreaBased) {
                // Area-based exploration (Ether Platform)
                area = param;
                minutes = 720; // Fixed 12 hours for all areas
                displayText = area;
                gameState.exploreArea = area;
            } else {
                // Time-based exploration (HQ, Sette Desert)
                minutes = param;
                area = null;
                gameState.exploreArea = null;
                if (minutes < 60) {
                    displayText = `${minutes}m`;
                } else {
                    displayText = `${minutes / 60}h`;
                }
            }

            gameState.exploreDuration = minutes * 60 * 1000;
            gameState.exploreStartTime = Date.now();

            // Reset boss flags and encounter stats
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            // Show stop button and hide explore button
            exploreBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            exploreStatus.style.display = 'flex';

            // Disable Maps button
            mapsBtn.disabled = true;
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            // Disable Maps button (center panel)
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }

            document.getElementById('explore-selected-time').textContent = `Explore Time: ${displayText}`;
            exploreTimer.textContent = "Elapsed 0:00"; // Initial state

            if (isAreaBased) {
                addToBattleLog(`You start exploring ${area}...`);
            } else {
                addToBattleLog(`You start exploring for ${minutes < 60 ? minutes + ' minutes' : minutes / 60 + ' hours'}...`);
            }

            // Reset boss flags
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;

            // Start boss check timer for 12h explorations (HQ, Sette Desert) or Lures Lot area
            if (minutes === 720 && !isAreaBased) {
                // Time-based 12h exploration (HQ, Sette Desert)
                gameState.bossCheckTimer = setTimeout(checkBossEncounter, 5 * 60 * 1000);
            } else if (area === 'Lures Lot') {
                // Area-based Lures Lot - Calliana Princess after 5 minutes
                gameState.bossCheckTimer = setTimeout(checkBossEncounter, 5 * 60 * 1000);
            }

            // Start battle timer after 30 seconds
            setTimeout(() => {
                if (gameState.isExploring) {
                    addToBattleLog('You venture deeper into the wilderness...');
                    startBattles();
                }
            }, 30 * 1000);

            // Update explore timer display
            gameState.exploreTimer = setInterval(() => {
                const elapsed = Date.now() - gameState.exploreStartTime;
                const remaining = Math.max(0, gameState.exploreDuration - elapsed);

                const elapsedMinutes = Math.floor(elapsed / 60000);
                const elapsedSeconds = Math.floor((elapsed % 60000) / 1000);

                exploreTimer.textContent = `Elapsed ${Math.floor(elapsedMinutes)}:${elapsedSeconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    finishExploration();
                }

                // Auto-save every minute
                if (elapsedSeconds === 0) {
                    saveGameState();
                }
            }, 1000);

            saveGameState();
        }

        // Format exploration time for display
        function formatExplorationTime(minutes) {
            if (minutes < 60) {
                return `${minutes} minutes`;
            } else if (minutes < 1440) {
                const hours = minutes / 60;
                return `${hours} ${hours === 1 ? 'hour' : 'hours'}`;
            } else {
                const days = minutes / 1440;
                return `${days} ${days === 1 ? 'day' : 'days'}`;
            }
        }

        // Start battles
        function startBattles() {
            if (gameState.battleTimer) {
                clearInterval(gameState.battleTimer);
            }

            scheduleNextBattle();
        }

        // Schedule next battle
        function scheduleNextBattle() {
            if (!gameState.isExploring) return;

            let baseInterval = 30000 + Math.random() * 30000; // 30-60 seconds

            // Calculate movement speed bonus from equipped accessories
            const char = gameState.character;
            let totalMovementSpeed = 0;

            if (char.equipped.accessory1?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory1.movementSpeed;
            }
            if (char.equipped.accessory2?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory2.movementSpeed;
            }

            // Apply movement speed: 1 MS = 10% faster encounters
            const encounterMultiplier = 1.0 - (totalMovementSpeed * 0.10);
            const interval = baseInterval * encounterMultiplier;

            gameState.battleTimer = setTimeout(() => {
                if (gameState.isExploring) {
                    simulateBattle();
                    scheduleNextBattle();
                }
            }, interval);
        }

        // Stop exploration immediately
        function stopExploration() {
            if (!gameState.isExploring) return;

            // Use different messaging based on current location
            const returnMessage = gameState.currentMap === 'Sette Desert'
                ? 'Exploration finished. Returning to safezone in 30 seconds...'
                : 'Exploration finished. Returning to HQ in 30 seconds...';

            addToBattleLog(returnMessage);

            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearTimeout(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            gameState.isExploring = false;

            // HIDE INSTANT FINISH BUTTON
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            gameState.stopTimer = setTimeout(() => {
                exploreBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                // Set to AFK mode instead of hiding
                document.getElementById('explore-selected-time').textContent = 'AFK';
                document.getElementById('explore-timer').textContent = '';

                // Enable Maps button after returning to HQ
                mapsBtn.disabled = false;
                mapsBtn.style.opacity = '1';
                mapsBtn.style.cursor = 'pointer';

                // Enable Maps button (center panel)
                const mapsMainBtnStop = document.getElementById('maps-main-btn');
                if (mapsMainBtnStop) {
                    mapsMainBtnStop.disabled = false;
                    mapsMainBtnStop.style.opacity = '1';
                    mapsMainBtnStop.style.cursor = 'pointer';
                }

                // Use different messaging based on current location
                const returnedMessage = gameState.currentMap === 'Sette Desert'
                    ? 'Returned to safezone.'
                    : 'Returned to HQ.';

                addToBattleLog(returnedMessage);
                gameState.stopTimer = null;
                saveGameState();
            }, 30 * 1000);

            saveGameState();
        }

        // Finish exploration when time runs out
        function finishExploration() {
            if (!gameState.isExploring) return;

            // Use different messaging based on current location
            const returnMessage = gameState.currentMap === 'Sette Desert'
                ? 'Exploration finished. Returning to safezone in 30 seconds...'
                : 'Exploration finished. Returning to HQ in 30 seconds...';

            addToBattleLog(returnMessage);

            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearTimeout(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            gameState.isExploring = false;

            // HIDE INSTANT FINISH BUTTON
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            gameState.stopTimer = setTimeout(() => {
                exploreBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                // Set to AFK mode instead of hiding
                document.getElementById('explore-selected-time').textContent = 'AFK';
                document.getElementById('explore-timer').textContent = '';

                // Enable Maps button after returning
                mapsBtn.disabled = false;
                mapsBtn.style.opacity = '1';
                mapsBtn.style.cursor = 'pointer';

                // Enable Maps button (center panel)
                const mapsMainBtnFinish = document.getElementById('maps-main-btn');
                if (mapsMainBtnFinish) {
                    mapsMainBtnFinish.disabled = false;
                    mapsMainBtnFinish.style.opacity = '1';
                    mapsMainBtnFinish.style.cursor = 'pointer';
                }

                // Use different messaging based on current location
                const returnedMessage = gameState.currentMap === 'Sette Desert'
                    ? 'Returned to safezone.'
                    : 'Returned to HQ.';

                addToBattleLog(returnedMessage);
                gameState.stopTimer = null;
                saveGameState();
            }, 30 * 1000);

            saveGameState();
        }

        // Instant finish exploration function (SIMPLIFIED - for testing only)
        function instantFinishExploration() {
            if (!gameState.isExploring) {
                addToBattleLog('You are not currently exploring!');
                return;
            }

            addToBattleLog('Instantly finishing exploration...');

            // Clear all timers
            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearInterval(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }

            // Calculate how many battles should happen based on exploration duration
            const exploreMinutes = gameState.exploreDuration / 60000;
            let battleCount;

            if (exploreMinutes === 30) battleCount = 8;
            else if (exploreMinutes === 60) battleCount = 12;
            else if (exploreMinutes === 360) battleCount = 20;
            else if (exploreMinutes === 720) battleCount = 30;
            else battleCount = 15; // Default

            addToBattleLog(`Simulating ${battleCount} battles from your exploration...`);

            // For 12h explorations, queue a boss encounter at a random battle
            if (exploreMinutes === 720 && !gameState.bossEncountered) {
                const mapBossName = getMapBossName();
                if (mapBossName) {
                    const mapBoss = gameState.bosses[mapBossName];
                    if (mapBoss && mapBoss.isAlive) {
                        // 100% guaranteed boss encounter
                        const randomBattleIndex = Math.floor(Math.random() * battleCount);
                        console.log(`Boss queued for battle ${randomBattleIndex + 1}/${battleCount}`);

                        // Queue the boss for that specific battle
                        setTimeout(() => {
                            gameState.bossEncounterQueued = true;
                        }, randomBattleIndex * 300);
                    }
                }
            }

            // Run battles by calling simulateBattle() repeatedly
            let battlesCompleted = 0;

            const battleInterval = setInterval(() => {
                if (battlesCompleted < battleCount) {
                    // Call the SAME battle function used in normal exploration
                    simulateBattle();

                    battlesCompleted++;
                    exploreTimer.textContent = `Finishing: ${battlesCompleted}/${battleCount}`;
                } else {
                    clearInterval(battleInterval);

                    // Restore HP and FP
                    gameState.character.hp = gameState.character.maxHp;
                    gameState.character.fp = gameState.character.maxFp;

                    finishInstantExploration();
                }
            }, 300); // 300ms between each battle
        }

        // Finish the instant exploration
        function finishInstantExploration() {
            addToBattleLog('Exploration instantly completed!');

            // Reset UI
            exploreBtn.style.display = 'block';
            stopBtn.style.display = 'none';
            // Set to AFK mode instead of hiding
            document.getElementById('explore-selected-time').textContent = 'AFK';
            document.getElementById('explore-timer').textContent = '';
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            // Enable Maps button
            mapsBtn.disabled = false;
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = 'pointer';

            // Enable Maps button (center panel)
            const mapsMainBtnInstant = document.getElementById('maps-main-btn');
            if (mapsMainBtnInstant) {
                mapsMainBtnInstant.disabled = false;
                mapsMainBtnInstant.style.opacity = '1';
                mapsMainBtnInstant.style.cursor = 'pointer';
            }

            gameState.isExploring = false;

            // Update character display
            updateCharacterDisplay();
            saveGameState();
        }

        // Simulate a battle
        function simulateBattle() {
            if (!gameState.isExploring) return;

            const char = gameState.character;

            // Get monsters for current exploration (EXCLUDE BOSSES - they are handled by timer)
            let availableMonsters;
            if (gameState.exploreArea) {
                // Area-based exploration (Ether Platform)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.area === gameState.exploreArea &&
                    monster.map === gameState.currentMap &&
                    !monster.isBoss  // Exclude bosses from regular pool
                );
            } else {
                // Time-based exploration (HQ, Sette Desert)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.explorationTime === (gameState.exploreDuration / 60000) &&
                    monster.map === gameState.currentMap &&
                    !monster.isBoss  // Exclude bosses from regular pool
                );
            }

            if (availableMonsters.length === 0) {
                addToBattleLog("No monsters available in this area.", 'warning');
                return;
            }

            // BOSS ENCOUNTER CHECK (New Timer System)
            let selectedMonster;
            let selectedMonsterName;

            // Check if boss is queued from 15-min timer
            if (gameState.bossEncounterQueued) {
                const mapBossName = getMapBossName();
                if (mapBossName) {
                    selectedMonsterName = mapBossName;
                    selectedMonster = monsters[selectedMonsterName];
                    gameState.bossEncounterQueued = false; // Clear flag
                    addToBattleLog(`<span class="log-boss-encounter">❗Monster Boss Alert: ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
                } else {
                    // Fallback if map changed or error
                    const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                    [selectedMonsterName, selectedMonster] = availableMonsters[randomIndex];
                    addToBattleLog(`<span class="log-encounter">You encounter a ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
                }
            } else {
                // Regular monster encounter
                if (availableMonsters.length === 0) {
                    addToBattleLog("No monsters available in this area.", 'warning');
                    return;
                }
                const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                [selectedMonsterName, selectedMonster] = availableMonsters[randomIndex];
                addToBattleLog(`<span class="log-encounter">You encounter a ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
            }

            // Track encounter
            if (!gameState.encounterStats[selectedMonsterName]) {
                gameState.encounterStats[selectedMonsterName] = 0;
            }
            gameState.encounterStats[selectedMonsterName]++;
            updateEncounterDisplay();

            // Calculate Base Damage
            const baseCharDamage = Math.max(1, char.attack - Math.floor(selectedMonster.defense / 3));
            let monsterDamage = Math.max(1, selectedMonster.attack - Math.floor(char.defense / 2));

            // Apply Damage Reduction from Armor
            let damageReductionAmount = 0;
            if (char.equipped.armor && char.equipped.armor.damageReduction) {
                damageReductionAmount = Math.floor(monsterDamage * char.equipped.armor.damageReduction);
                monsterDamage -= damageReductionAmount;
            }

            let monsterHp = selectedMonster.isBoss ? gameState.bosses[selectedMonsterName].currentHp : selectedMonster.hp;
            let charHp = char.hp;

            while (monsterHp > 0 && charHp > 0) {
                // Calculate Crit for this hit
                const criticalChance = char.criticalChance || 0.05;
                const isCritical = Math.random() < criticalChance;
                const damageMultiplier = isCritical ? 1.5 : 1;

                // Apply Crit to Base Damage
                let charDamage = Math.floor(baseCharDamage * damageMultiplier);

                // Skill Usage Logic
                let currentAttackDamage = charDamage;
                let skillUsed = null;

                // Check for available skills
                const mySkills = classSkills[char.class] || [];
                const availableSkills = mySkills.filter(skill => char.level >= skill.level && char.fp >= skill.fpCost);

                // 30% chance to use a skill if available
                if (availableSkills.length > 0 && Math.random() < 0.3) {
                    // Pick a random available skill
                    const randomSkillIndex = Math.floor(Math.random() * availableSkills.length);
                    skillUsed = availableSkills[randomSkillIndex];

                    // Apply skill effects
                    currentAttackDamage = Math.floor(charDamage * skillUsed.damageMult);
                    char.fp -= skillUsed.fpCost;
                }

                monsterHp -= currentAttackDamage;

                if (skillUsed) {
                    addToBattleLog(`You used <span style="color: #00ffff;">${skillUsed.name}</span>! Hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                } else if (isCritical) {
                    addToBattleLog(`⚡ CRITICAL HIT! You hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                } else {
                    addToBattleLog(`You hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                }

                // Lifesteal Logic
                if (char.equipped.weapon && char.equipped.weapon.lifesteal) {
                    const ls = char.equipped.weapon.lifesteal;
                    if (Math.random() < ls.chance) {
                        const healAmount = Math.floor(currentAttackDamage * ls.multiplier);
                        if (healAmount > 0) {
                            charHp = Math.min(char.maxHp, charHp + healAmount);
                            addToBattleLog(`💚 Lifesteal! Recovered <span style="color: #00ff00;">${healAmount} HP</span>.`, 'heal');
                        }
                    }
                }
                if (monsterHp <= 0) {
                    addToBattleLog(`<span class="log-success">You defeated ${selectedMonsterName}!</span>`, 'success');

                    // Handle boss defeat
                    if (selectedMonster.isBoss) {
                        const bossState = gameState.bosses[selectedMonsterName];
                        // Reset boss for next exploration
                        bossState.isAlive = true;
                        bossState.currentHp = bossState.maxHp;
                        addToBattleLog(`<span class="log-boss-victory">🎉 Victory! You defeated 👾 ${selectedMonsterName}!</span>`, 'level');
                    }

                    if (char.level < 40) {
                        // Flat EXP system: Different EXP per map for balanced progression
                        const expGain = getMonsterExpGain(selectedMonsterName, selectedMonster);
                        char.exp += expGain;
                        addToBattleLog(`You gained <span class="log-exp">${expGain} EXP points</span>.`, 'exp');

                        if (char.exp >= char.maxExp) {
                            levelUp();
                        }
                    }

                    checkDrops(selectedMonster);
                    break;
                }

                // BOSS SPECIAL ATTACK
                if (selectedMonster.isBoss && Math.random() < 0.3) { // 30% chance for special attack
                    const specialDamage = Math.floor(selectedMonster.attack * 0.5); // 50% of attack as bonus
                    charHp -= specialDamage;
                    addToBattleLog(`👾 ${selectedMonsterName} uses Special Attack! <span class="log-damage">${specialDamage} damage</span>.`, 'damage');
                } else {
                    // Regular attack
                    charHp -= monsterDamage;
                    let logMsg = `${selectedMonsterName} hits you for <span class="log-damage">${monsterDamage} damage</span>.`;
                    if (damageReductionAmount > 0) {
                        logMsg += ` <span style="color: #3498db; font-size: 0.8em;"> -${damageReductionAmount} DMG</span>`;
                    }
                    addToBattleLog(logMsg, 'damage');
                }

                // Auto Potion Logic (2-second cooldown)
                const currentTime = Date.now();
                if (gameState.autoPotion && charHp < char.maxHp * 0.5 && charHp > 0) {
                    if (gameState.currency >= 5 && (currentTime - gameState.lastPotionTime) >= 1000) {
                        const healAmount = Math.floor(char.maxHp * 0.3);
                        const fpAmount = Math.floor(char.maxFp * 0.3);
                        charHp = Math.min(char.maxHp, charHp + healAmount);
                        char.fp = Math.min(char.maxFp, char.fp + fpAmount);
                        gameState.currency -= 5;
                        gameState.lastPotionTime = currentTime; // Update last potion time
                        addToBattleLog(`🧪 Auto Potion! <span style="color: #00ff00;">+${healAmount} HP</span> and <span style="color: #4a9cff;">+${fpAmount} FP</span>. Consumed -5 🍃`, 'heal');
                        document.getElementById('currency-amount').textContent = gameState.currency;
                    }
                }

                if (charHp <= 0) {
                    console.log('DEATH CONDITION MET - charHp:', charHp, 'monsterHp:', monsterHp, 'isBoss:', selectedMonster.isBoss);
                    addToBattleLog(`<span class="log-damage">You have been defeated!</span>`, 'danger');

                    // Handle death location logic
                    if (gameState.currentMap === "Sette Desert") {
                        addToBattleLog(`You died and respawned at HQ.`, 'info');
                        gameState.currentMap = "HQ";
                        char.location = "HQ";
                        updateMapsAccessibility(); // Update UI to reflect map change
                    } else {
                        addToBattleLog(`You died and returned to your saved location.`, 'info');
                    }

                    // Update boss HP if it was a boss battle
                    if (selectedMonster.isBoss) {
                        gameState.bosses[selectedMonsterName].currentHp = monsterHp;
                        addToBattleLog(`👾 ${selectedMonsterName} has ${gameState.bosses[selectedMonsterName].currentHp}/${gameState.bosses[selectedMonsterName].maxHp} HP remaining.`);
                    }

                    char.hp = char.maxHp;
                    char.fp = char.maxFp;

                    if (gameState.exploreTimer) {
                        clearInterval(gameState.exploreTimer);
                        gameState.exploreTimer = null;
                    }

                    if (gameState.battleTimer) {
                        clearTimeout(gameState.battleTimer);
                        gameState.battleTimer = null;
                    }

                    if (gameState.bossCheckTimer) {
                        clearTimeout(gameState.bossCheckTimer);
                        gameState.bossCheckTimer = null;
                    }

                    exploreBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    exploreStatus.style.display = 'none';
                    const instantFinishBtn = document.getElementById('instant-finish-btn');
                    if (instantFinishBtn) {
                        instantFinishBtn.style.display = 'none';
                    }

                    // Enable Maps button
                    mapsBtn.disabled = false;
                    mapsBtn.style.opacity = '1';
                    mapsBtn.style.cursor = 'pointer';

                    // Enable Maps button (center panel)
                    const mapsMainBtnDeath = document.getElementById('maps-main-btn');
                    if (mapsMainBtnDeath) {
                        mapsMainBtnDeath.disabled = false;
                        mapsMainBtnDeath.style.opacity = '1';
                        mapsMainBtnDeath.style.cursor = 'pointer';
                    }

                    console.log('RESETTING EXPLORATION STATE - isExploring was:', gameState.isExploring);
                    gameState.isExploring = false;
                    gameState.bossEncounterQueued = false;
                    gameState.bossEncountered = false;
                    gameState.encounterStats = {};
                    console.log('EXPLORATION STATE RESET - isExploring now:', gameState.isExploring);

                    updateCharacterDisplay();
                    saveGameState();
                    return;
                }
            }

            // Update boss HP if it survived (shouldn't happen here as loop breaks on death, but for safety)
            if (selectedMonster.isBoss && monsterHp > 0) {
                gameState.bosses[selectedMonsterName].currentHp = monsterHp;
            }

            char.hp = charHp;
            updateCharacterDisplay();
            saveGameState();
        }

        // Check for monster drops
        function checkDrops(monster) {
            monster.drops.forEach(drop => {
                if (Math.random() < drop.chance) {
                    if (drop.type === 'currency') {
                        const amount = drop.quantity || drop.amount;
                        gameState.currency += amount;
                        addToBattleLog(`You found <span class="log-loot">${amount} ${getEmoji('currency')} Leaves</span>!`, 'loot');
                    } else if (drop.type === 'item') {
                        // Check inventory space ONLY for items
                        const quantity = drop.quantity || 1;
                        if (gameState.inventory.length + quantity > 20) {
                            addToBattleLog(`Inventory full! Could not pick up ${drop.name}.`, 'warning');
                            return;
                        }

                        // Determine type dynamically
                        let itemType = 'weapon';
                        if (drop.name.toLowerCase().includes('armor') || drop.name.toLowerCase().includes('core') || drop.name.toLowerCase().includes('tunic') || drop.name.toLowerCase().includes('cloak')) {
                            itemType = 'armor';
                        } else if (drop.name.toLowerCase().includes('wristlet')) {
                            itemType = 'accessory';
                        }

                        gameState.inventory.push({
                            name: drop.name,
                            stats: drop.stats,
                            sellValue: drop.sellValue,
                            quantity: 1,
                            type: itemType,
                            upgradeLevel: 0,
                            movementSpeed: drop.movementSpeed || null,
                            isWings: drop.isWings || false,
                            lifesteal: drop.lifesteal || null,
                            damageReduction: drop.damageReduction || null,
                            rarity: drop.rarity || null
                        });


                        addToBattleLog(`You found ${quantity > 1 ? quantity + ' ' : ''}<span class="log-loot">${getEmoji(drop.name.toLowerCase())} ${drop.name}${quantity > 1 ? 's' : ''}</span>!`, 'loot');
                        updateInventoryDisplay();
                    } else if (drop.type === 'material') {
                        const quantity = drop.quantity || 1;
                        const existingMaterial = gameState.materials.find(material => material.name === drop.name);

                        if (existingMaterial) {
                            existingMaterial.quantity += quantity;
                        } else {
                            gameState.materials.push({
                                name: drop.name,
                                sellValue: drop.sellValue,
                                quantity: quantity,
                                type: 'material'
                            });
                        }

                        addToBattleLog(`You found <span class="log-loot">${getEmoji(drop.name.toLowerCase())} ${drop.name} ×${quantity}</span>!`, 'loot');
                        updateInventoryDisplay();
                    }
                }
            });

            document.getElementById('currency-amount').textContent = gameState.currency;
            saveGameState();
        }

        // Start HP regeneration
        function startHPRegeneration() {
            if (gameState.regenTimer) {
                clearInterval(gameState.regenTimer);
            }

            gameState.regenTimer = setInterval(() => {
                if (gameState.character) {
                    const char = gameState.character;

                    if (char.hp < char.maxHp) {
                        char.hp = Math.min(char.maxHp, char.hp + Math.ceil(char.maxHp * 0.01));
                        updateCharacterDisplay();
                        saveGameState();
                    }

                    if (char.fp < char.maxFp) {
                        char.fp = Math.min(char.maxFp, char.fp + Math.ceil(char.maxFp * 0.01));
                        updateCharacterDisplay();
                        saveGameState();
                    }
                }
            }, 10000);
        }

        // Level up character
        function levelUp() {
            const char = gameState.character;

            while (char.exp >= char.maxExp && char.level < 40) {
                char.level += 1;
                char.exp -= char.maxExp;
                // EXP Required Formula: Gentle exponential progression (50 * 1.2^(level-1))
                char.maxExp = Math.floor(50 * Math.pow(1.2, char.level - 1));

                const increases = statIncrease[char.class];
                char.maxHp += increases.hp;
                char.maxFp += increases.fp;
                char.attack += increases.attack;
                char.defense += increases.defense;

                char.hp = char.maxHp;
                char.fp = char.maxFp;

                addToBattleLog(`<span class="log-level">✨ You reached level ${char.level}!</span>`, 'level');

                // Show max level message only when first reaching it
                if (char.level === 40) {
                    addToBattleLog(`<span class="log-level">🎉 You have reached the maximum level of 40!</span>`, 'level');
                }
            }

            saveGameState();
        }

        // Update inventory display - SORTED WITH EQUIPPED ITEMS FIRST
        function updateInventoryDisplay() {
            inventoryItems.innerHTML = '';
            materialsItems.innerHTML = '';

            // Sort inventory: equipped items first, then unequipped
            const sortedInventory = [...gameState.inventory].sort((a, b) => {
                const aEquipped = (gameState.character.equipped.weapon === a || gameState.character.equipped.armor === a || gameState.character.equipped.accessory1 === a || gameState.character.equipped.accessory2 === a || gameState.character.equipped.wings === a);
                const bEquipped = (gameState.character.equipped.weapon === b || gameState.character.equipped.armor === b || gameState.character.equipped.accessory1 === b || gameState.character.equipped.accessory2 === b || gameState.character.equipped.wings === b);

                if (aEquipped && !bEquipped) return -1;
                if (!aEquipped && bEquipped) return 1;
                return 0;
            });

            // Count actual items (not quantities) for inventory limit
            const totalItems = gameState.inventory.length;
            inventoryLimit.textContent = `Inventory: ${totalItems}/20`;

            if (sortedInventory.length === 0) {
                emptyInventory.style.display = 'block';
            } else {
                emptyInventory.style.display = 'none';

                sortedInventory.forEach((item, originalIndex) => {
                    // Find the original index for event handlers
                    const index = gameState.inventory.indexOf(item);

                    const itemElement = document.createElement('div');
                    itemElement.className = 'item-compact';

                    const isWeaponEquipped = gameState.character.equipped.weapon === item;
                    const isArmorEquipped = gameState.character.equipped.armor === item;
                    const isAccessory1Equipped = gameState.character.equipped.accessory1 === item;
                    const isAccessory2Equipped = gameState.character.equipped.accessory2 === item;
                    const isWingsEquipped = gameState.character.equipped.wings === item;
                    const isEquipped = isWeaponEquipped || isArmorEquipped || isAccessory1Equipped || isAccessory2Equipped || isWingsEquipped;

                    if (isEquipped) {
                        itemElement.classList.add('equipped');
                    }

                    const itemLevel = item.upgradeLevel || 0;
                    const upgradeText = itemLevel > 0 ? `+${itemLevel}` : '';

                    // Handle Emoji
                    let emoji = getEmoji(item.name.toLowerCase());
                    if (item.isWings || item.name.toLowerCase().includes('wings')) {
                        emoji = '🪽';
                    }

                    const displayName = `${emoji} ${item.name} ${upgradeText}`.trim();

                    const isArmor = item.name.toLowerCase().includes('armor') ||
                        item.name.toLowerCase().includes('shirt') ||
                        item.name.toLowerCase().includes('tunic') ||
                        item.name.toLowerCase().includes('cloak') ||
                        item.name.toLowerCase().includes('core') ||
                        item.name.toLowerCase().includes('suit');

                    const isAccessory = item.name.toLowerCase().includes('wristlet') || item.isWings || item.name.toLowerCase().includes('wings');

                    let statDisplay = '';
                    if (isArmor) {
                        const statBonus = item.stats.defense + (upgradeSystem.bonuses[itemLevel]?.defense || 0);
                        statDisplay = `🛡️ +${statBonus} Defense`;
                        if (item.damageReduction) {
                            statDisplay += ` | DMG Red. ${Math.round(item.damageReduction * 100)}%`;
                        }
                    } else if (isAccessory) {
                        // Accessories usually don't have upgrades in this simple system yet, or we assume base stats
                        // Parsal Wristlets have both Attack and Defense
                        const atk = item.stats.attack || 0;
                        const def = item.stats.defense || 0;
                        statDisplay = `⚔️ +${atk}  🛡️ +${def}`;

                        // Add Movement Speed display for Wings
                        if (item.movementSpeed) {
                            statDisplay += ` | Speed ${item.movementSpeed}`;
                        }
                    } else {
                        const statBonus = item.stats.attack + (upgradeSystem.bonuses[itemLevel]?.attack || 0);
                        statDisplay = `⚔️ +${statBonus} Attack`;

                        // Add Lifesteal display
                        if (item.lifesteal) {
                            statDisplay += ` | LS ${Math.round(item.lifesteal.chance * 100)}%`;
                        }
                    }

                    // Class Weapon Restrictions
                    const playerClass = gameState.character.class;
                    let canEquip = true;
                    let restrictionMsg = "";

                    if (!isArmor && !isAccessory) { // It's a weapon
                        const name = item.name.toLowerCase();
                        const isSword = name.includes('sword') || name.includes('blade') || name.includes('claymore') || name.includes('breaker') || name.includes('zweihander');
                        const isStaff = name.includes('staff') || name.includes('wand') || name.includes('bead');
                        const isBow = name.includes('bow');

                        let requiredClass = null;
                        if (isSword) requiredClass = 'Warrior';
                        else if (isStaff) requiredClass = 'Mystic';
                        else if (isBow) requiredClass = 'Ranger';

                        if (requiredClass && playerClass !== requiredClass) {
                            canEquip = false;
                            restrictionMsg = `${requiredClass} Only`;
                        }
                    }

                    itemElement.innerHTML = `
                <div class="item-compact-info">
                    <div class="item-compact-name ${item.rarity === 't1' ? 'item-rarity-t1' : ''}" style="display: flex; justify-content: space-between;">
                        <span>${displayName}</span>
                        <span style="font-size: 0.8rem; color: var(--text-dim); font-weight: normal;">Price ${item.sellValue} 🍃</span>
                    </div>
                    <div class="item-compact-stats">${statDisplay}</div>
                    <div class="item-compact-actions">
                        <button class="btn-small btn-equip" data-index="${index}" 
                            ${(!canEquip && !isEquipped) ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                            ${(isEquipped) ? 'Unequip' : (canEquip ? 'Equip' : restrictionMsg)}
                        </button>
                        <button class="btn-small btn-sell" data-index="${index}" 
                            ${(isEquipped) ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                            Sell
                        </button>
                        ${itemLevel < 7 && !isEquipped && !isAccessory ?
                            `<button class="btn-small btn-upgrade" data-index="${index}">Upgrade</button>` :
                            '<button class="btn-small btn-upgrade" data-index="${index}" disabled style="opacity: 0.5; cursor: not-allowed;">Upgrade</button>'
                        }
                    </div>
                </div>
            `;
                    const upgradeBtn = itemElement.querySelector('.btn-upgrade');
                    const sellBtn = itemElement.querySelector('.btn-sell');
                    const equipBtn = itemElement.querySelector('.btn-equip');

                    if (upgradeBtn && !upgradeBtn.disabled) {
                        upgradeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showUpgradeModal(item, index);
                        });
                    }

                    sellBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!isEquipped) {
                            sellItem(item, index);
                        } else {
                            addToBattleLog('You cannot sell an equipped item.', 'warning');
                        }
                    });

                    equipBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleEquipItem(item, index);
                    });

                    inventoryItems.appendChild(itemElement);
                });
            }

            // Update materials display
            if (gameState.materials.length === 0) {
                emptyMaterials.style.display = 'block';
            } else {
                emptyMaterials.style.display = 'none';

                gameState.materials.forEach((material, index) => {
                    const materialElement = document.createElement('div');
                    materialElement.className = 'material-item-compact';

                    materialElement.innerHTML = `
                        <div class="material-info">
                            ${getEmoji(material.name.toLowerCase())} ${material.name} x${material.quantity}
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span class="material-price" style="margin-right: 8px; font-size: 0.8rem; color: var(--text-dim);">Price ${material.sellValue} 🍃</span>
                            <button class="btn-small btn-sell" data-index="${index}">Sell</button>
                        </div>
                    `;

                    const sellBtn = materialElement.querySelector('.btn-sell');
                    sellBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        sellMaterial(material, index);
                    });

                    materialsItems.appendChild(materialElement);
                });
            }

            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
        }

        // Show upgrade modal
        function showUpgradeModal(item, index) {
            currentUpgradeItem = { item, index };
            const itemLevel = parseInt(item.upgradeLevel) || 0;

            // FIX: Check max level
            if (itemLevel >= 7) {
                // Check if it's armor or weapon
                const isArmor = item.name.toLowerCase().includes('armor') ||
                    item.name.toLowerCase().includes('shirt') ||
                    item.name.toLowerCase().includes('tunic');

                const statType = isArmor ? 'defense' : 'attack';
                const currentStat = item.stats[statType] + (upgradeSystem.bonuses[itemLevel]?.[statType] || 0);

                upgradeItemInfo.innerHTML = `
                    <div class="upgrade-info">
                        <div class="item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</div>
                        <div class="item-stats">Current: +${currentStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)} (MAX)</div>
                    </div>
                    <div class="upgrade-cost">
                        <span>Max Level Reached</span>
                    </div>
                `;
                document.getElementById('upgrade-confirm-btn').disabled = true;
                document.getElementById('upgrade-confirm-btn').textContent = "Max Level";
                upgradeResult.style.display = 'none';
                upgradeModal.style.display = 'flex';
                return;
            }

            document.getElementById('upgrade-confirm-btn').disabled = false;
            document.getElementById('upgrade-confirm-btn').textContent = "Upgrade";

            const nextLevel = itemLevel + 1;
            const cost = upgradeSystem.costs[nextLevel];
            const chance = upgradeSystem.chances[nextLevel];

            // Check if it's armor or weapon
            const isArmor = item.name.toLowerCase().includes('armor') ||
                item.name.toLowerCase().includes('shirt') ||
                item.name.toLowerCase().includes('tunic');

            const statType = isArmor ? 'defense' : 'attack';
            const currentStat = item.stats[statType] + (upgradeSystem.bonuses[itemLevel]?.[statType] || 0);
            const nextStat = item.stats[statType] + upgradeSystem.bonuses[nextLevel][statType];

            // Determine which gem to use based on item type
            const gemType = isArmor ? "Blue Gem" : "Red Gem";
            const gemEmoji = isArmor ? getEmoji('blue gem') : getEmoji('red gem');

            upgradeItemInfo.innerHTML = `
                <div class="upgrade-info">
                    <div class="item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</div>
                    <div class="item-stats">Current: +${currentStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)} → Next: +${nextStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)}</div>
                </div>
                <div class="upgrade-cost">
                    <span>Cost: ${cost[gemType]} ${gemEmoji} ${gemType}s + ${cost['currency']} 🍃</span>
                </div>
                <div class="upgrade-chance">
                    Success Chance: ${Math.round(chance * 100)}%
                    ${nextLevel === 5 ? '<div style="color: var(--danger); margin-top: 0.5rem;">Warning: Failure will destroy the item!</div>' : ''}
                </div>
            `;

            upgradeResult.style.display = 'none';
            upgradeModal.style.display = 'flex';
        }

        // Confirm upgrade
        // Confirm upgrade
        function confirmUpgrade() {
            if (!currentUpgradeItem) return;

            const { item, index } = currentUpgradeItem;
            const itemLevel = parseInt(item.upgradeLevel) || 0;
            const nextLevel = itemLevel + 1;
            const cost = upgradeSystem.costs[nextLevel];
            const chance = upgradeSystem.chances[nextLevel];

            // Check if it's armor or weapon
            const isArmor = item.name.toLowerCase().includes('armor') ||
                item.name.toLowerCase().includes('shirt') ||
                item.name.toLowerCase().includes('tunic');

            const statType = isArmor ? 'defense' : 'attack';
            const gemType = isArmor ? "Blue Gem" : "Red Gem";
            const equippedSlot = isArmor ? 'armor' : 'weapon';

            const gems = gameState.materials.find(m => m.name === gemType);

            if (!gems || gems.quantity < cost[gemType]) {
                showUpgradeResult(`You need ${cost[gemType]} ${gemType}s to upgrade.`, false);
                return;
            }

            if (gameState.currency < cost['currency']) {
                showUpgradeResult(`You need ${cost['currency']} 🍃 to upgrade.`, false);
                return;
            }

            const success = Math.random() < chance;

            if (success) {
                gameState.inventory[index].upgradeLevel = nextLevel;

                if (gameState.character.equipped[equippedSlot] === item) {
                    const oldBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                    const newBonus = upgradeSystem.bonuses[nextLevel][statType];
                    gameState.character[statType] += (newBonus - oldBonus);
                }

                if (gems.quantity > cost[gemType]) {
                    gems.quantity -= cost[gemType];
                } else {
                    const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                    gameState.materials.splice(materialIndex, 1);
                }

                gameState.currency -= cost['currency'];

                // Refresh modal content to show new stats and next level success rate
                showUpgradeModal(item, index);

                showUpgradeResult(`Upgrade successful! ${item.name} is now +${nextLevel} (+${upgradeSystem.bonuses[nextLevel][statType]} ${statType.charAt(0).toUpperCase() + statType.slice(1)})`, true);
                addToBattleLog(`Upgraded ${getEmoji(item.name.toLowerCase())} ${item.name} to +${nextLevel}!`);
            } else {
                // Only consume materials on failure for +1 to +4
                if (nextLevel < 5) { // Levels 1-4 only consume materials on failure
                    if (gems.quantity > cost[gemType]) {
                        gems.quantity -= cost[gemType];
                    } else {
                        const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                        gameState.materials.splice(materialIndex, 1);
                    }

                    showUpgradeResult(`Upgrade failed! Materials were consumed.`, false);
                    addToBattleLog(`Upgrade failed for ${getEmoji(item.name.toLowerCase())} ${item.name}! Materials lost.`);
                } else {
                    // +5 failure - destroy weapon and consume materials
                    if (gems.quantity > cost[gemType]) {
                        gems.quantity -= cost[gemType];
                    } else {
                        const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                        gameState.materials.splice(materialIndex, 1);
                    }

                    showUpgradeResult(`Upgrade failed! The item was destroyed.`, false);
                    addToBattleLog(`Upgrade failed! ${getEmoji(item.name.toLowerCase())} ${item.name} was destroyed.`);

                    // Handle destruction in UI
                    currentUpgradeItem = null;
                    document.getElementById('upgrade-confirm-btn').disabled = true;
                    document.getElementById('upgrade-item-info').innerHTML = '<div style="color: var(--danger); text-align: center; padding: 2rem;">Item Destroyed</div>';

                    // Remove the item from inventory
                    gameState.inventory.splice(index, 1);

                    // Unequip if it was equipped
                    if (gameState.character.equipped[equippedSlot] === item) {
                        const oldBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                        gameState.character[statType] -= (item.stats[statType] + oldBonus);
                        gameState.character.equipped[equippedSlot] = null;
                    }
                }
            }

            updateInventoryDisplay();
            updateCharacterDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;

            saveGameState();
        }

        // Show upgrade result
        function showUpgradeResult(message, success) {
            upgradeResult.textContent = message;
            upgradeResult.className = `upgrade-result ${success ? 'upgrade-success' : 'upgrade-failure'}`;
            upgradeResult.style.display = 'block';
        }

        // Sell an item
        function sellItem(item, index) {
            const equipped = gameState.character.equipped;
            if (equipped.weapon === item || equipped.armor === item ||
                equipped.accessory1 === item || equipped.accessory2 === item) {
                addToBattleLog(`You cannot sell an equipped item.`);
                return;
            }

            const sellValue = item.sellValue;
            gameState.currency += sellValue;

            gameState.inventory.splice(index, 1);

            addToBattleLog(`Sold ${getEmoji(item.name.toLowerCase())} ${item.name} for ${sellValue} 🍃.`);

            updateInventoryDisplay();
            updateInventoryDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
            saveGameState();
        }

        // Sell a material
        function sellMaterial(material, index) {
            const sellValue = material.sellValue;
            gameState.currency += sellValue;

            if (material.quantity > 1) {
                material.quantity -= 1;
            } else {
                gameState.materials.splice(index, 1);
            }

            addToBattleLog(`Sold ${getEmoji('redgem')} ${material.name} for ${sellValue} 🍃.`);

            updateInventoryDisplay();
            updateInventoryDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
            saveGameState();
        }

        // Toggle item equip/unequip
        function toggleEquipItem(item, index) {
            const char = gameState.character;
            const itemLevel = item.upgradeLevel || 0;
            const name = item.name.toLowerCase();

            // WINGS HANDLING - Check this FIRST before any other equipment type
            const isWings = item.isWings || name.includes('wings');
            if (isWings) {
                const isEquipped = char.equipped.wings === item;

                if (isEquipped) {
                    // Unequip wings
                    char.equipped.wings = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    // Equip wings (replace if already equipped)
                    if (char.equipped.wings) {
                        const oldWings = char.equipped.wings;
                        char.attack -= oldWings.stats.attack || 0;
                        char.defense -= oldWings.stats.defense || 0;
                        addToBattleLog(`You unequipped ${getEmoji(oldWings.name.toLowerCase())} ${oldWings.name}.`);
                    }
                    char.equipped.wings = item;
                    char.attack += item.stats.attack || 0;
                    char.defense += item.stats.defense || 0;
                    addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name}!`);
                }

                updateCharacterDisplay();
                updateInventoryDisplay(); // Re-render inventory to show equipped state
                saveGameState();
                return; // Exit early - Wings handled
            }

            // Robust Type Detection (for non-Wings items)
            let isArmor = name.includes('armor') ||
                name.includes('shirt') ||
                name.includes('tunic') ||
                name.includes('cloak') ||
                name.includes('core') ||
                name === 'steel core'; // Explicit check

            // Fallback: If it has defense but no attack, it's armor
            if (!isArmor && item.stats.defense && !item.stats.attack) {
                isArmor = true;
            }

            // Class Weapon Restrictions Check
            const playerClass = gameState.character.class;
            if (!isArmor && !name.includes('wristlet') && !item.isWings && !name.includes('wings')) { // It's a weapon
                const isSword = name.includes('sword') || name.includes('blade') || name.includes('claymore') || name.includes('breaker') || name.includes('zweihander');
                const isStaff = name.includes('staff') || name.includes('wand') || name.includes('bead');
                const isBow = name.includes('bow');

                if (playerClass === 'Warrior' && !isSword) {
                    addToBattleLog(`Warriors can only equip Swords!`, 'warning');
                    return;
                } else if (playerClass === 'Mystic' && !isStaff) {
                    addToBattleLog(`Mystics can only equip Staffs!`, 'warning');
                    return;
                } else if (playerClass === 'Ranger' && !isBow) {
                    addToBattleLog(`Rangers can only equip Bows!`, 'warning');
                    return;
                }
            }

            const isAccessory = name.includes('wristlet') || item.isWings || name.includes('wings');

            let statType = 'attack';
            let equippedSlot = 'weapon';

            if (isArmor) {
                statType = 'defense';
                equippedSlot = 'armor';
            } else if (isAccessory) {
                // Accessories give both attack and defense usually, but let's handle the main stat or both
                // For Parsal Wristlets, they give both.
                // We need special handling for accessories
            }

            // Calculate bonuses
            const currentBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
            // Note: For accessories, we might need to handle multiple stats. 
            // But current system assumes single stat type for upgrades. 
            // Let's assume accessories don't have upgrades for now or use default logic.

            // Accessory Logic
            if (isAccessory) {
                // Check if already equipped
                if (char.equipped.accessory1 === item) {
                    // Unequip from slot 1
                    char.equipped.accessory1 = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else if (char.equipped.accessory2 === item) {
                    // Unequip from slot 2
                    char.equipped.accessory2 = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    // Check Wings restriction before equipping
                    if (item.isWings) {
                        // Check if another Wings is already equipped
                        const hasWingsEquipped =
                            (char.equipped.accessory1?.isWings) ||
                            (char.equipped.accessory2?.isWings);

                        if (hasWingsEquipped) {
                            addToBattleLog('You can only equip one Wings item at a time!', 'warning');
                            return;
                        }
                    }

                    // Equip logic
                    // Try slot 1
                    if (!char.equipped.accessory1) {
                        char.equipped.accessory1 = item;
                        char.attack += item.stats.attack || 0;
                        char.defense += item.stats.defense || 0;
                        addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name} (Slot 1)!`);
                    }
                    // Try slot 2
                    else if (!char.equipped.accessory2) {
                        char.equipped.accessory2 = item;
                        char.attack += item.stats.attack || 0;
                        char.defense += item.stats.defense || 0;
                        addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name} (Slot 2)!`);
                    }
                    // Replace slot 1 if both full
                    else {
                        const oldItem = char.equipped.accessory1;
                        char.attack -= oldItem.stats.attack || 0;
                        char.defense -= oldItem.stats.defense || 0;

                        char.equipped.accessory1 = item;
                        char.attack += item.stats.attack || 0;
                        char.defense += item.stats.defense || 0;
                        addToBattleLog(`You replaced ${oldItem.name} with ${item.name} (Slot 1)!`);
                    }
                }
            } else {
                // Weapon/Armor Logic (Existing)
                const statValue = item.stats[statType] || 0;
                const totalStatBonus = statValue + currentBonus;
                const isEquipped = char.equipped[equippedSlot] === item;

                if (isEquipped) {
                    char.equipped[equippedSlot] = null;
                    char[statType] -= totalStatBonus;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    if (char.equipped[equippedSlot]) {
                        const currentItem = char.equipped[equippedSlot];
                        const currentLevel = currentItem.upgradeLevel || 0;
                        const currentItemBonus = upgradeSystem.bonuses[currentLevel]?.[statType] || 0;
                        const currentTotalStatBonus = currentItem.stats[statType] + currentItemBonus;
                        char[statType] -= currentTotalStatBonus;
                        char.equipped[equippedSlot] = null;
                    }

                    char.equipped[equippedSlot] = item;
                    char[statType] += totalStatBonus;
                    addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name}!`);
                }
            }

            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameState();
        }

        // Show players modal
        function showPlayers() {
            const playersList = document.getElementById('players-list');
            playersList.innerHTML = '';

            const sortedPlayers = [...gameState.players].sort((a, b) => b.level - a.level);

            sortedPlayers.forEach((player, index) => {
                const playerRow = document.createElement('div');
                playerRow.className = 'player-row';

                playerRow.innerHTML = `
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-level">Lv. ${player.level}</div>
                `;

                playersList.appendChild(playerRow);
            });

            playersModal.style.display = 'flex';
        }

        // Global Market System
        let selectedItemForSale = null;

        // Show market modal
        // Show market modal
        function showMarket() {
            const marketModal = document.getElementById('market-modal');
            marketModal.style.display = 'flex';

            // Show browse mode by default
            document.getElementById('market-browse').classList.add('active');
            document.getElementById('market-sell').classList.remove('active');

            // Set up price input validation
            setupPriceValidation();

            // Load market data
            loadMarketItems();
        }

        // Toggle between browse and sell modes
        function toggleSellMode() {
            const browseMode = document.getElementById('market-browse');
            const sellMode = document.getElementById('market-sell');

            if (browseMode.classList.contains('active')) {
                // Switch to sell mode
                browseMode.classList.remove('active');
                sellMode.classList.add('active');
                loadSellInventory();
            } else {
                // Switch back to browse mode
                sellMode.classList.remove('active');
                browseMode.classList.add('active');
                cancelSell();
            }
        }

        // Set up price input validation to only allow numbers
        function setupPriceValidation() {
            const priceInput = document.getElementById('sell-price');
            if (priceInput) {
                // Prevent non-numeric keys
                priceInput.addEventListener('keypress', function (e) {
                    // Allow backspace, delete, tab, escape, enter, and numbers
                    if ([8, 9, 27, 13, 46].includes(e.keyCode) ||
                        (e.keyCode >= 48 && e.keyCode <= 57) || // Numbers 0-9
                        (e.keyCode >= 96 && e.keyCode <= 105)) { // Numpad 0-9
                        return;
                    }
                    e.preventDefault();
                });

                // Clean input on change
                priceInput.addEventListener('input', function (e) {
                    // Remove any non-numeric characters
                    let value = e.target.value.replace(/[^0-9]/g, '');

                    // Remove leading zeros (except for single 0)
                    if (value.length > 1 && value.startsWith('0')) {
                        value = value.replace(/^0+/, '');
                    }

                    // Limit to reasonable price range (1-999999)
                    const numValue = parseInt(value) || 0;
                    if (numValue > 999999) {
                        value = '999999';
                    }

                    e.target.value = value;
                });

                // Prevent paste of invalid characters
                priceInput.addEventListener('paste', function (e) {
                    e.preventDefault();
                    setTimeout(() => {
                        const value = e.target.value.replace(/[^0-9]/g, '');
                        e.target.value = value;
                    }, 0);
                });
            }
        }

        // Market view switching
        function showBrowseMarket() {
            switchMarketView('browse');
        }

        function showSellInterface() {
            switchMarketView('sell');
            loadSellInventory();
        }

        function showMyListings() {
            switchMarketView('listings');
            loadMyListings();
        }

        function switchMarketView(viewName) {
            // Hide all views
            document.querySelectorAll('.market-view').forEach(view => {
                view.classList.remove('active');
            });

            // Show selected view
            document.getElementById(`market-${viewName}`).classList.add('active');
        }

        // Load market items for browsing
        function loadMarketItems() {
            const marketItems = document.getElementById('market-items');
            marketItems.innerHTML = '<div class="loading">Loading market items...</div>';

            try {
                // Use localStorage for market listings
                const localListings = JSON.parse(localStorage.getItem('globalMarket') || '{}');
                const listings = localListings;

                if (Object.keys(listings).length === 0) {
                    marketItems.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">🛒</div>
                            <h3>No Items for Sale</h3>
                            <p>Be the first to list an item! Start selling your gear to other players.</p>
                            <button class="sell-btn" onclick="toggleSellMode()">
                                <span class="btn-icon">💰</span> Start Selling
                            </button>
                        </div>
                    `;
                    return;
                }

                // Convert to array (no sorting as requested)
                const itemsArray = Object.entries(listings).map(([id, listing]) => ({
                    id,
                    ...listing
                }));

                marketItems.innerHTML = '';

                itemsArray.forEach(listing => {
                    if (listing.status !== 'active') return;

                    const itemElement = document.createElement('div');
                    itemElement.className = 'market-item';

                    // Format stats nicely
                    let statsText = '';
                    if (listing.item.stats) {
                        const stats = Object.entries(listing.item.stats);
                        if (stats.length > 0) {
                            statsText = stats.map(([stat, value]) => {
                                const icon = stat === 'attack' ? '⚔️' :
                                    stat === 'defense' ? '🛡️' :
                                        stat === 'criticalChance' ? '💥' : '✨';
                                return `${icon} ${stat}: +${value}`;
                            }).join(' • ');
                        }
                    }

                    itemElement.innerHTML = `
                            <div class="market-item-header">
                                <div class="market-item-name">${listing.item.name}</div>
                                <div class="market-item-price">${listing.price} <span class="currency-icon">🍃</span></div>
                            </div>
                            <div class="market-item-stats">
                                ${statsText || 'No special stats'}
                            </div>
                            <div class="market-item-footer">
                                <div class="market-item-seller">Seller: ${listing.sellerName || 'Anonymous'}</div>
                                <button class="btn btn-success" onclick="buyMarketItem('${listing.id}')">
                                    <span class="btn-icon">🛒</span> Buy Now
                                </button>
                            </div>
                        `;

                    marketItems.appendChild(itemElement);
                });
            } catch (error) {
                console.error('Error loading market items:', error);
                marketItems.innerHTML = '<div class="loading">Error loading market. Please try again.</div>';
            }
        }

        // Load player's inventory for selling
        function loadSellInventory() {
            const sellInventory = document.getElementById('sell-inventory');
            sellInventory.innerHTML = '';

            gameState.inventory.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.className = 'inventory-item';
                itemElement.onclick = () => selectItemForSale(index);

                itemElement.innerHTML = `
                    <div class="inventory-item-name">${item.name}</div>
                    <div class="inventory-item-stats">
                        ${item.stats ? Object.entries(item.stats).map(([stat, value]) =>
                    `${stat}: +${value}`).join('<br>') : ''}
                    </div>
                `;

                sellInventory.appendChild(itemElement);
            });

            if (gameState.inventory.length === 0) {
                sellInventory.innerHTML = '<div class="loading">No items to sell!</div>';
            }
        }

        // Select item for sale
        function selectItemForSale(index) {
            selectedItemForSale = index;

            // Update UI
            document.querySelectorAll('.inventory-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });

            // Show sell form
            const sellForm = document.getElementById('sell-form');
            const sellItemInfo = document.getElementById('sell-item-info');
            const item = gameState.inventory[index];

            sellItemInfo.innerHTML = `
                <div class="sell-item-name">${item.name}</div>
                <div class="sell-item-stats">
                    ${item.stats ? Object.entries(item.stats).map(([stat, value]) =>
                `${stat}: +${value}`).join(', ') : 'No special stats'}
                </div>
                <div class="sell-item-value">Sell Value: ${item.sellValue || 0} Leaves</div>
            `;

            sellForm.style.display = 'block';
        }

        // Cancel selling
        function cancelSell() {
            selectedItemForSale = null;
            document.querySelectorAll('.inventory-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.getElementById('sell-form').style.display = 'none';
            document.getElementById('sell-price').value = '';
        }

        // Confirm sale and list item
        function confirmSell() {
            if (selectedItemForSale === null) return;

            // Check if player already has a listing (only allow 1 item at a time)
            const localListings = JSON.parse(localStorage.getItem('globalMarket') || '{}');
            const userListings = Object.values(localListings).filter(listing =>
                listing.sellerId === (window.currentUser?.uid || 'unknown') && listing.status === 'active'
            );

            if (userListings.length > 0) {
                alert('You can only have 1 item listed for sale at a time.');
                return;
            }

            const priceInput = document.getElementById('sell-price').value.trim();
            const price = parseInt(priceInput);

            if (!priceInput || isNaN(price) || price < 1) {
                alert('Please enter a valid price (minimum 1 Leaf)!');
                return;
            }

            if (price > 999999) {
                alert('Maximum price is 999,999 Leaves!');
                return;
            }

            const item = gameState.inventory[selectedItemForSale];

            // Create listing
            const listing = {
                item: item,
                price: price,
                sellerId: window.currentUser?.uid || 'unknown',
                sellerName: gameState.character?.name || 'Unknown Player',
                timestamp: Date.now(),
                status: 'active'
            };

            try {
                // Use localStorage for market listings
                const listingId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const localListings = JSON.parse(localStorage.getItem('globalMarket') || '{}');
                localListings[listingId] = listing;
                localStorage.setItem('globalMarket', JSON.stringify(localListings));

                // Remove item from inventory
                gameState.inventory.splice(selectedItemForSale, 1);

                // Save game state
                saveGameState();
                updateInventoryDisplay();

                // Reset form and go back to browse mode
                cancelSell();
                toggleSellMode();

                // Refresh market
                loadMarketItems();

                alert('Item listed for sale successfully!');
            } catch (error) {
                console.error('Error creating listing:', error);
                alert('Failed to list item. Please try again.');
            }
        }

        // Buy market item
        function buyMarketItem(listingId) {
            if (!window.currentUser) {
                alert('You must be logged in to buy items!');
                return;
            }

            try {
                const localListings = JSON.parse(localStorage.getItem('globalMarket') || '{}');
                const listing = localListings[listingId];

                if (!listing || listing.status !== 'active') {
                    alert('This item is no longer available!');
                    return;
                }

                // Check if buyer has enough money
                if (gameState.currency < listing.price) {
                    alert('You don\'t have enough Leaves!');
                    return;
                }

                // Check if buyer is not the seller
                if (window.currentUser && listing.sellerId === window.currentUser.uid) {
                    alert('You cannot buy your own items!');
                    return;
                }

                // Process purchase
                gameState.currency -= listing.price;

                // Add item to inventory
                gameState.inventory.push(listing.item);

                // Mark listing as sold
                listing.status = 'sold';
                localStorage.setItem('globalMarket', JSON.stringify(localListings));

                // Save and update UI
                saveGameState();
                updateInventoryDisplay();
                document.getElementById('currency-amount').textContent = gameState.currency;

                // Refresh market
                loadMarketItems();

                alert(`Successfully purchased ${listing.item.name} for ${listing.price} Leaves!`);
            } catch (error) {
                console.error('Error processing purchase:', error);
                alert('Failed to purchase item. Please try again.');
            }
        }

        // Load player's listings
        function loadMyListings() {
            const myListings = document.getElementById('my-listings');

            if (!window.firebaseReady || !window.currentUser) {
                myListings.innerHTML = '<div class="loading">Please log in to view your listings.</div>';
                return;
            }

            myListings.innerHTML = '<div class="loading">Loading your listings...</div>';

            try {
                const marketRef = ref(db, 'market');
                onValue(marketRef, (snapshot) => {
                    const listings = snapshot.val() || {};
                    const myItems = Object.entries(listings).filter(([id, listing]) =>
                        listing.sellerId === window.currentUser.uid && listing.status === 'active'
                    );

                    if (myItems.length === 0) {
                        myListings.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-icon">📦</div>
                                <h3>No Active Listings</h3>
                                <p>You haven't listed any items for sale yet. Go to the "Sell Items" tab to list your first item!</p>
                            </div>
                        `;
                        return;
                    }

                    myListings.innerHTML = '';

                    myItems.forEach(([id, listing]) => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'listing-item';

                        // Format stats nicely
                        let statsText = '';
                        if (listing.item.stats) {
                            const stats = Object.entries(listing.item.stats);
                            if (stats.length > 0) {
                                statsText = stats.map(([stat, value]) => {
                                    const icon = stat === 'attack' ? '⚔️' :
                                        stat === 'defense' ? '🛡️' :
                                            stat === 'criticalChance' ? '💥' : '✨';
                                    return `${icon} ${stat}: +${value}`;
                                }).join(' • ');
                            }
                        }

                        itemElement.innerHTML = `
                        <div class="market-item-header">
                            <div class="market-item-name">${listing.item.name}</div>
                            <div class="market-item-price">${listing.price} <span class="currency-icon">🍃</span></div>
                        </div>
                        <div class="market-item-stats">
                            ${statsText || 'No special stats'}
                        </div>
                        <div class="market-item-footer">
                            <div class="market-item-seller">Listed for sale</div>
                            <button class="btn btn-danger" onclick="cancelListing('${id}')">
                                <span class="btn-icon">❌</span> Cancel Listing
                            </button>
                        </div>
                    `;

                        myListings.appendChild(itemElement);
                    });
                });
            } catch (error) {
                console.error('Error loading listings:', error);
                myListings.innerHTML = '<div class="loading">Error loading listings.</div>';
            }
        }

        // Cancel listing
        function cancelListing(listingId) {
            if (!confirm('Are you sure you want to cancel this listing? The item will be returned to your inventory.')) {
                return;
            }

            try {
                const listingRef = ref(db, `market/${listingId}`);
                get(listingRef).then((snapshot) => {
                    const listing = snapshot.val();

                    // Return item to inventory
                    gameState.inventory.push(listing.item);

                    // Remove listing
                    set(listingRef, { ...listing, status: 'cancelled' });

                    // Save and update
                    saveGameState();
                    updateInventoryDisplay();
                    loadMyListings();
                    loadMarketItems();

                    alert('Listing cancelled. Item returned to inventory.');
                }).catch((error) => {
                    console.error('Error cancelling listing:', error);
                    alert('Failed to cancel listing.');
                });
            } catch (error) {
                console.error('Error processing cancellation:', error);
                alert('Failed to cancel listing.');
            }
        }

        // Get emoji for items and elements
        function getEmoji(type) {
            switch (type) {
                case 'currency': return '🍃';
                case 'novice sword': return '🗡️';
                case 'sword breaker': return '🗡️';
                case 'valkyrie sword': return '🗡️';
                case 'zweihander': return '🗡️';
                case 'arghol blade': return '🗡️';
                case 'novice wand': return '🪄';
                case 'battle staff': return '🪄';
                case 'war wand': return '🪄';
                case 'red bead': return '🪄';
                case 'arghol staff': return '🪄';
                case 'novice bow': return '🏹';
                case 'assemble bow': return '🏹';
                case 'tower bow': return '🏹';
                case 'beam cross-bow': return '🏹';
                case 'arghol bow': return '🏹';
                case 'novice armor': return '🧥';
                case 'leather shirt': return '🧥';
                case 'hora tunic': return '🧥';
                case 'coil armor': return '🧥';
                case 'arghol armor': return '🧥';
                case 'iron tunic': return '🧥';
                case 'steel core': return '🧥';
                case 'duple armor': return '🧥';
                case 'sprits cloak': return '🧥';
                case 'soul armor': return '🧥';
                case 'turncoat armor': return '🧥';
                case 'glow suit': return '🧥';
                case 'red gem': return '♦️';
                case 'blue gem': return '🔷';
                case 'shiny gem': return '💎';
                case 'winter box': return '🧊';
                case 'exp': return '✨';
                case 'parsal wristlet a': return '💍';
                case 'parsal wristlet b': return '💍';
                case 'parsal wristlet c': return '💍';
                case 'parsal wristlet d': return '💍';
                case 'bastard sword': return '🗡️';
                case 'claymore': return '🗡️';
                case 'big breaker': return '🗡️';
                case 'beam sword': return '🗡️';
                case 'scale sword': return '🗡️';
                case 'turncoat sword': return '🗡️';
                case 'black wand': return '🪄';
                case 'field staff': return '🪄';
                case 'dual wand': return '🪄';
                case 'beam bead': return '🪄';
                case 'blue wand': return '🪄';
                case 'turncoat staff': return '🪄';
                case 'long bow': return '🏹';
                case 'battle bow': return '🏹';
                case 'dual bow': return '🏹';
                case 'beam bow': return '🏹';
                case 'siege bow': return '🏹';
                case 'turncoat bow': return '🏹';
                case 't1 turncoat sword': return '🗡️';
                case 't1 turncoat staff': return '🪄';
                case 't1 turncoat bow': return '🏹';
                case 't1 scale sword': return '🗡️';
                case 't1 blue wand': return '🪄';
                case 't1 siege bow': return '🏹';
                default: return '';
            }
        }

        function sanitizeStats() {
            const char = gameState.character;
            if (isNaN(char.attack)) char.attack = 10; // Default fallback
            if (isNaN(char.defense)) char.defense = 5; // Default fallback

            // Recalculate from base if possible
            if (classStats[char.class]) {
                const base = classStats[char.class];
                const increases = statIncrease[char.class];
                const levels = char.level - 1;

                // If stats are wildly off or NaN, reset to calculated base + equipped
                if (isNaN(char.attack) || isNaN(char.defense)) {
                    char.attack = base.attack + (levels * increases.attack);
                    char.defense = base.defense + (levels * increases.defense);

                    // Add equipped items
                    if (char.equipped.weapon) char.attack += (char.equipped.weapon.stats.attack || 0);
                    if (char.equipped.armor) char.defense += (char.equipped.armor.stats.defense || 0);
                    if (char.equipped.accessory1) {
                        char.attack += (char.equipped.accessory1.stats.attack || 0);
                        char.defense += (char.equipped.accessory1.stats.defense || 0);
                    }
                    if (char.equipped.accessory2) {
                        char.attack += (char.equipped.accessory2.stats.attack || 0);
                        char.defense += (char.equipped.accessory2.stats.defense || 0);
                    }
                    if (char.equipped.wings) {
                        char.attack += (char.equipped.wings.stats.attack || 0);
                        char.defense += (char.equipped.wings.stats.defense || 0);
                    }
                }
            }
        }

        // Crafting Functions
        function openCraftingModal() {
            craftingModal.style.display = 'flex';
            renderRecipes();
        }

        function closeCraftingModal() {
            craftingModal.style.display = 'none';
            selectedRecipe = null;
            craftConfirmBtn.disabled = true;
        }

        function renderRecipes() {
            recipeList.innerHTML = '';

            Object.entries(craftingRecipes).forEach(([key, recipe]) => {
                const recipeEl = document.createElement('div');
                recipeEl.className = 'recipe-item';
                if (selectedRecipe === key) recipeEl.classList.add('selected');

                // Check requirements
                const hasCurrency = gameState.currency >= recipe.requirements.currency;

                // Check materials
                let materialsMet = true;
                let materialsHtml = '';
                Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                    const playerMat = gameState.materials.find(m => m.name === matName);
                    const playerAmount = playerMat ? playerMat.quantity : 0;
                    const isMet = playerAmount >= amount;
                    if (!isMet) materialsMet = false;

                    materialsHtml += `
                        <div class="req-item ${isMet ? 'req-met' : 'req-missing'}">
                            ${getEmoji(matName.toLowerCase())} ${matName}: ${playerAmount}/${amount}
                        </div>
                    `;
                });

                // Check base item
                const reqItem = recipe.requirements.item;
                // Find ANY matching item in inventory
                const matchingItems = gameState.inventory.filter(i =>
                    i.name === reqItem.name &&
                    i.upgradeLevel >= reqItem.upgradeLevel
                );
                const hasItem = matchingItems.length > 0;

                const itemHtml = `
                    <div class="req-item ${hasItem ? 'req-met' : 'req-missing'}">
                        ${getEmoji(reqItem.name.toLowerCase())} ${reqItem.name} +${reqItem.upgradeLevel}: ${hasItem ? 'Available' : 'Missing'}
                    </div>
                `;

                const currencyHtml = `
                    <div class="req-item ${hasCurrency ? 'req-met' : 'req-missing'}">
                        🍃 Cost: ${recipe.requirements.currency}
                    </div>
                `;

                let statsDisplay = `<span>ATK: ${recipe.stats.attack}</span>`;
                if (recipe.lifesteal) {
                    statsDisplay = `
                        <div style="text-align: right;">
                            <div>ATK: ${recipe.stats.attack}</div>
                            <div style="font-size: 0.8rem; color: #00ff00;">LS: ${Math.round(recipe.lifesteal.chance * 100)}% (x${recipe.lifesteal.multiplier})</div>
                        </div>
                    `;
                } else if (recipe.damageReduction) {
                    statsDisplay = `
                        <div style="text-align: right;">
                            <div>DEF: ${recipe.stats.defense}</div>
                            <div style="font-size: 0.8rem; color: #3498db;">DMG Red: ${Math.round(recipe.damageReduction * 100)}%</div>
                        </div>
                    `;
                } else if (recipe.stats.defense) {
                    statsDisplay = `<span>DEF: ${recipe.stats.defense}</span>`;
                }

                recipeEl.innerHTML = `
                    <div class="recipe-header">
                        <span class="${recipe.rarity === 't1' ? 'item-rarity-t1' : ''}">${getEmoji(recipe.name.toLowerCase())} ${recipe.name}</span>
                        ${statsDisplay}
                    </div>
                    <div class="recipe-requirements">
                        ${itemHtml}
                        ${materialsHtml}
                        ${currencyHtml}
                    </div>
                `;

                recipeEl.addEventListener('click', () => {
                    selectRecipe(key);
                });

                recipeList.appendChild(recipeEl);
            });
        }

        function selectRecipe(recipeKey) {
            selectedRecipe = recipeKey;
            renderRecipes();

            // Check if craftable
            const recipe = craftingRecipes[recipeKey];
            const hasCurrency = gameState.currency >= recipe.requirements.currency;

            let materialsMet = true;
            Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                const playerMat = gameState.materials.find(m => m.name === matName);
                const playerAmount = playerMat ? playerMat.quantity : 0;
                if (playerAmount < amount) materialsMet = false;
            });

            const reqItem = recipe.requirements.item;
            const matchingItems = gameState.inventory.filter(i =>
                i.name === reqItem.name &&
                i.upgradeLevel >= reqItem.upgradeLevel
            );
            const hasItem = matchingItems.length > 0;

            craftConfirmBtn.disabled = !(hasCurrency && materialsMet && hasItem);
        }

        function craftItem() {
            if (!selectedRecipe) return;

            const recipe = craftingRecipes[selectedRecipe];

            // 1. Consume Currency
            gameState.currency -= recipe.requirements.currency;

            // 2. Consume Materials
            Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                const playerMat = gameState.materials.find(m => m.name === matName);
                playerMat.quantity -= amount;
                if (playerMat.quantity <= 0) {
                    const idx = gameState.materials.indexOf(playerMat);
                    gameState.materials.splice(idx, 1);
                }
            });

            // 3. Consume Base Item
            const reqItem = recipe.requirements.item;
            // Prioritize unequipped items
            let targetItem = gameState.inventory.find(i =>
                i.name === reqItem.name &&
                i.upgradeLevel >= reqItem.upgradeLevel &&
                gameState.character.equipped.weapon !== i
            );

            // If no unequipped item, use equipped one
            if (!targetItem) {
                targetItem = gameState.inventory.find(i =>
                    i.name === reqItem.name &&
                    i.upgradeLevel >= reqItem.upgradeLevel
                );

                // Unequip it first
                if (gameState.character.equipped.weapon === targetItem) {
                    gameState.character.equipped.weapon = null;
                    // Remove stats
                    const itemLevel = targetItem.upgradeLevel;
                    const bonus = upgradeSystem.bonuses[itemLevel]?.attack || 0;
                    gameState.character.attack -= (targetItem.stats.attack + bonus);
                }
            }

            const itemIndex = gameState.inventory.indexOf(targetItem);
            gameState.inventory.splice(itemIndex, 1);

            // 4. Add New Item
            const newItem = {
                name: recipe.name,
                stats: { ...recipe.stats },
                sellValue: recipe.sellValue,
                quantity: 1,
                type: recipe.type,
                upgradeLevel: 0,
                rarity: recipe.rarity,
                rarity: recipe.rarity,
                lifesteal: recipe.lifesteal || null,
                damageReduction: recipe.damageReduction || null
            };

            gameState.inventory.push(newItem);

            // 5. Update UI
            addToBattleLog(`Crafted <span class="item-rarity-t1">${getEmoji(newItem.name.toLowerCase())} ${newItem.name}</span>!`, 'success');
            updateInventoryDisplay();
            updateCharacterDisplay();
            // closeCraftingModal(); // Keep open to show "Crafted!" state
            saveGameState();
        }

        // MARKET SYSTEM
        // ========================================

        let selectedSellItem = null;

        // Show market modal with unified view
        function showMarket() {
            const marketModal = document.getElementById('market-modal');
            marketModal.style.display = 'flex';
            showUnifiedView();
            loadUnifiedMarket();
        }

        // Show unified market view
        function showUnifiedView() {
            document.getElementById('market-unified-view').style.display = 'block';
            document.getElementById('market-sell-mode').style.display = 'none';
        }

        // Show sell mode
        function showSellMode() {
            document.getElementById('market-unified-view').style.display = 'none';
            document.getElementById('market-sell-mode').style.display = 'block';
            loadSellInventory();
        }

        // Load unified market (my listings + other players' items)
        async function loadUnifiedMarket() {
            const myListingsContainer = document.getElementById('my-listings-container');
            const marketItemsContainer = document.getElementById('market-items-container');

            myListingsContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-dim);">Loading...</div>';
            marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-dim);">Loading...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'marketListings');
                const snapshot = await get(marketRef);

                if (!snapshot.exists()) {
                    myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No listings yet</div>';
                    marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No items available</div>';
                    return;
                }

                const listings = snapshot.val();
                const currentUserId = window.currentUser?.uid;

                // Separate my listings and other players' listings
                const myListings = [];
                const otherListings = [];

                Object.entries(listings).forEach(([id, listing]) => {
                    if (listing.sellerId === currentUserId) {
                        myListings.push([id, listing]);
                    } else {
                        otherListings.push([id, listing]);
                    }
                });

                // Render my listings
                if (myListings.length === 0) {
                    myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">You have no active listings</div>';
                } else {
                    myListingsContainer.innerHTML = '';
                    myListings.forEach(([listingId, listing]) => {
                        const itemEl = createSingleLineItem(listingId, listing, true);
                        myListingsContainer.appendChild(itemEl);
                    });
                }

                // Render other players' items
                if (otherListings.length === 0) {
                    marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No items available from other players</div>';
                } else {
                    marketItemsContainer.innerHTML = '';
                    otherListings.forEach(([listingId, listing]) => {
                        const itemEl = createSingleLineItem(listingId, listing, false);
                        marketItemsContainer.appendChild(itemEl);
                    });
                }

            } catch (error) {
                console.error('Error loading market:', error);
                myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--warning);">Error loading listings</div>';
                marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--warning);">Error loading market items</div>';
            }
        }

        // Create single-line item element
        function createSingleLineItem(listingId, listing, isMyListing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = isMyListing ? 'market-item-row my-listing' : 'market-item-row';

            // Build item name with upgrade level
            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;
            const emoji = getEmoji(item.name.toLowerCase());

            // Build stats display
            let statsText = '';
            if (item.stats.attack) statsText += `ATK: ${item.stats.attack}`;
            if (item.stats.defense) {
                if (statsText) statsText += ' | ';
                statsText += `DEF: ${item.stats.defense}`;
            }
            if (!statsText) statsText = '-';

            // Build action button
            let actionButton = '';
            if (isMyListing) {
                actionButton = `<button class="btn btn-danger btn-small" onclick="cancelListing('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">✖ Cancel</button>`;
            } else {
                actionButton = `<button class="btn btn-success btn-small" onclick="buyMarketItem('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">💰 Buy</button>`;
            }

            div.innerHTML = `
                <div class="market-item-info">
                    <div class="market-item-name">${emoji} ${itemName}</div>
                    <div class="market-item-stats">${statsText}</div>
                    <div class="market-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-action">
                    ${actionButton}
                </div>
            `;

            return div;
        }

        // Load market items from Firebase
        async function loadMarketItems() {
            const marketItemsContainer = document.getElementById('market-items');
            marketItemsContainer.innerHTML = '<div class="loading">Loading market items...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'marketListings');
                const snapshot = await get(marketRef);

                if (!snapshot.exists()) {
                    marketItemsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">🏪</div>
                            <h3>No Items Listed</h3>
                            <p>Be the first to list an item on the market!</p>
                        </div>
                    `;
                    return;
                }

                const listings = snapshot.val();
                const currentUserId = window.currentUser?.uid;

                // Filter out current user's listings
                const otherPlayersListings = Object.entries(listings).filter(([id, listing]) =>
                    listing.sellerId !== currentUserId
                );

                if (otherPlayersListings.length === 0) {
                    marketItemsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">🏪</div>
                            <h3>No Items Available</h3>
                            <p>Check back later for new listings!</p>
                        </div>
                    `;
                    return;
                }

                // Render market items
                marketItemsContainer.innerHTML = '';
                otherPlayersListings.forEach(([listingId, listing]) => {
                    const itemEl = createMarketItemElement(listingId, listing);
                    marketItemsContainer.appendChild(itemEl);
                });

            } catch (error) {
                console.error('Error loading market items:', error);
                marketItemsContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">⚠️</div>
                        <h3>Error Loading Market</h3>
                        <p>Please try again later.</p>
                    </div>
                `;
            }
        }

        // Create market item element
        function createMarketItemElement(listingId, listing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = 'market-item';

            // Build stats display
            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;
            if (item.upgradeLevel > 0) statsHtml += `+${item.upgradeLevel} `;

            div.innerHTML = `
                <div class="market-item-header">
                    <h4 class="market-item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</h4>
                    <div class="market-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-stats">${statsHtml}</div>
                <div class="market-item-footer">
                    <div class="market-item-seller">Sold by: ${listing.sellerName}</div>
                    <button class="btn btn-success" onclick="buyMarketItem('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">
                        <span class="btn-icon">💰</span> Buy
                    </button>
                </div>
            `;

            return div;
        }

        // Buy market item
        async function buyMarketItem(listingId, listing) {
            const price = listing.price;

            // Check if player has enough currency
            if (gameState.currency < price) {
                addToBattleLog('Not enough Leaves to buy this item!', 'warning');
                return;
            }

            // Check inventory space
            if (gameState.inventory.length >= 20) {
                addToBattleLog('Inventory full! Cannot buy item.', 'warning');
                return;
            }

            try {
                const { ref, get, set, update, remove } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Deduct currency from buyer
                gameState.currency -= price;
                document.getElementById('currency-amount').textContent = gameState.currency;

                // Add item to buyer's inventory
                gameState.inventory.push(listing.item);
                updateInventoryDisplay();


                // Add currency to seller using Firebase transaction (atomic and safe)
                const { runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const sellerDataRef = ref(db, `users/${listing.sellerId}`);

                console.log(`🔍 Starting transaction for seller ${listing.sellerName} (${listing.sellerId})`);
                console.log(`💰 Price to add: ${price}`);

                try {
                    const result = await runTransaction(sellerDataRef, (currentData) => {
                        console.log('📊 Current seller data:', JSON.stringify(currentData, null, 2));

                        if (currentData === null) {
                            console.warn('⚠️ Seller data is null!');
                            return currentData;
                        }

                        // Log the current structure
                        console.log('🔍 Data structure check:');
                        console.log('  - Has currency property?', !!currentData.currency);
                        console.log('  - currency type:', typeof currentData.currency);
                        console.log('  - currency value:', currentData.currency);

                        // Handle the currency structure: {coins: 0, leaves: 30}
                        if (currentData.currency && typeof currentData.currency === 'object') {
                            if (typeof currentData.currency.leaves === 'number') {
                                console.log(`✅ Adding ${price} to currency.leaves (${currentData.currency.leaves})`);
                                currentData.currency.leaves += price;
                                console.log(`✅ New currency.leaves: ${currentData.currency.leaves}`);
                            } else {
                                console.log(`⚠️ Creating currency.leaves with value ${price}`);
                                currentData.currency.leaves = price;
                            }
                        } else if (typeof currentData.currency === 'number') {
                            // Legacy: currency is a simple number
                            console.log(`✅ Adding ${price} to currency (${currentData.currency})`);
                            currentData.currency += price;
                            console.log(`✅ New currency: ${currentData.currency}`);
                        } else {
                            // No currency structure, create it
                            console.log(`⚠️ Creating new currency structure with leaves: ${price}`);
                            currentData.currency = { coins: 0, leaves: price };
                        }

                        console.log('📤 Returning updated data');
                        return currentData;
                    });

                    console.log('✅ Transaction result:', result);
                    console.log(`✅ Seller ${listing.sellerName} received ${price} Leaves via transaction`);
                    addToBattleLog(`Payment sent to ${listing.sellerName}`, 'info');
                } catch (transactionError) {
                    console.error('❌ Transaction failed for seller currency update:', transactionError);
                    addToBattleLog('Warning: Seller may not have received payment. Please contact support.', 'warning');
                }

                // Remove listing from market
                const listingRef = ref(db, `marketListings/${listingId}`);
                await remove(listingRef);

                // Save buyer's state
                saveGameState();

                addToBattleLog(`Purchased ${listing.item.name} for ${price} Leaves!`, 'success');

                // Reload unified market
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error buying item:', error);
                addToBattleLog('Failed to purchase item. Please try again.', 'warning');

                // Refund currency on error
                gameState.currency += price;
                document.getElementById('currency-amount').textContent = gameState.currency;
                gameState.inventory.pop();
                updateInventoryDisplay();
            }
        }

        // Load player's inventory for selling
        function loadSellInventory() {
            const sellInventory = document.getElementById('sell-inventory');
            const sellForm = document.getElementById('sell-form');

            sellInventory.innerHTML = '';
            sellForm.style.display = 'none';
            selectedSellItem = null;

            // Get sellable items (exclude equipped items)
            const sellableItems = gameState.inventory.filter(item => {
                const char = gameState.character;
                return item !== char.equipped.weapon &&
                    item !== char.equipped.armor &&
                    item !== char.equipped.accessory1 &&
                    item !== char.equipped.accessory2 &&
                    item !== char.equipped.wings;
            });

            if (sellableItems.length === 0) {
                sellInventory.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📦</div>
                        <h3>No Items to Sell</h3>
                        <p>You don't have any unequipped items to list on the market.</p>
                    </div>
                `;
                return;
            }

            // Render inventory items
            sellableItems.forEach(item => {
                const itemEl = createSellInventoryItem(item);
                sellInventory.appendChild(itemEl);
            });
        }

        // Create sell inventory item element
        function createSellInventoryItem(item) {
            const div = document.createElement('div');
            div.className = 'inventory-item';

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack}<br>`;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense}<br>`;
            if (item.upgradeLevel > 0) statsHtml += `+${item.upgradeLevel}`;

            div.innerHTML = `
                <div class="inventory-item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</div>
                <div class="inventory-item-stats">${statsHtml}</div>
            `;

            div.addEventListener('click', () => selectItemToSell(item, div));

            return div;
        }

        // Select item to sell
        function selectItemToSell(item, element) {
            selectedSellItem = item;

            // Update UI selection
            document.querySelectorAll('.inventory-item').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');

            // Show sell form
            const sellForm = document.getElementById('sell-form');
            const sellItemInfo = document.getElementById('sell-item-info');

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;
            if (item.upgradeLevel > 0) statsHtml += `+${item.upgradeLevel}`;

            sellItemInfo.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color); margin-bottom: 0.5rem;">
                        ${getEmoji(item.name.toLowerCase())} ${item.name}
                    </div>
                    <div style="color: var(--text);">${statsHtml}</div>
                </div>
            `;

            sellForm.style.display = 'block';
            document.getElementById('sell-price').value = '';
            document.getElementById('sell-price').focus();
        }

        // Confirm sell
        async function confirmSell() {
            if (!selectedSellItem) {
                addToBattleLog('Please select an item to sell!', 'warning');
                return;
            }

            const priceInput = document.getElementById('sell-price');
            const priceValue = priceInput.value.trim();

            // Validate input is a number
            if (!/^\d+$/.test(priceValue)) {
                addToBattleLog('Price must be a number only (no symbols or decimals)!', 'warning');
                return;
            }

            const price = parseInt(priceValue);

            if (!price || price <= 0) {
                addToBattleLog('Please enter a valid price!', 'warning');
                return;
            }

            if (price > 999999) {
                addToBattleLog('Price too high! Maximum is 999,999 Leaves.', 'warning');
                return;
            }

            try {
                const { ref, push } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Create listing
                const listing = {
                    sellerId: window.currentUser.uid,
                    sellerName: gameState.character.name,
                    item: selectedSellItem,
                    price: price,
                    listedAt: Date.now()
                };

                // Add to Firebase
                const marketRef = ref(db, 'marketListings');
                await push(marketRef, listing);

                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(selectedSellItem);
                gameState.inventory.splice(itemIndex, 1);
                updateInventoryDisplay();
                saveGameState();

                addToBattleLog(`Listed ${selectedSellItem.name} for ${price} Leaves!`, 'success');

                // Return to unified view and reload
                showUnifiedView();
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error listing item:', error);
                addToBattleLog('Failed to list item. Please try again.', 'warning');
            }
        }

        // Load player's listings
        async function loadMyListings() {
            const myListingsContainer = document.getElementById('my-listings');
            myListingsContainer.innerHTML = '<div class="loading">Loading your listings...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'marketListings');
                const snapshot = await get(marketRef);

                if (!snapshot.exists()) {
                    myListingsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">📋</div>
                            <h3>No Active Listings</h3>
                            <p>You haven't listed any items yet.</p>
                        </div>
                    `;
                    return;
                }

                const listings = snapshot.val();
                const currentUserId = window.currentUser?.uid;

                // Filter current user's listings
                const myListings = Object.entries(listings).filter(([id, listing]) =>
                    listing.sellerId === currentUserId
                );

                if (myListings.length === 0) {
                    myListingsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">📋</div>
                            <h3>No Active Listings</h3>
                            <p>You haven't listed any items yet.</p>
                        </div>
                    `;
                    return;
                }

                // Render listings
                myListingsContainer.innerHTML = '';
                myListings.forEach(([listingId, listing]) => {
                    const itemEl = createMyListingElement(listingId, listing);
                    myListingsContainer.appendChild(itemEl);
                });

            } catch (error) {
                console.error('Error loading my listings:', error);
                myListingsContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">⚠️</div>
                        <h3>Error Loading Listings</h3>
                        <p>Please try again later.</p>
                    </div>
                `;
            }
        }

        // Create my listing element
        function createMyListingElement(listingId, listing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = 'listing-item';

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;
            if (item.upgradeLevel > 0) statsHtml += `+${item.upgradeLevel}`;

            div.innerHTML = `
                <div class="market-item-header">
                    <h4 class="listing-item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</h4>
                    <div class="listing-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-stats">${statsHtml}</div>
                <div class="market-item-footer">
                    <div style="font-size: 0.85rem; color: var(--text-dim);">Listed ${getTimeAgo(listing.listedAt)}</div>
                    <button class="btn btn-danger btn-small" onclick="cancelListing('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">
                        <span class="btn-icon">✖</span> Cancel
                    </button>
                </div>
            `;

            return div;
        }

        // Cancel listing
        async function cancelListing(listingId, listing) {
            if (!confirm('Cancel this listing and return the item to your inventory?')) {
                return;
            }

            // Check inventory space
            if (gameState.inventory.length >= 20) {
                addToBattleLog('Inventory full! Cannot cancel listing.', 'warning');
                return;
            }

            try {
                const { ref, remove } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Return item to inventory
                gameState.inventory.push(listing.item);
                updateInventoryDisplay();

                // Remove listing from Firebase
                const listingRef = ref(db, `marketListings/${listingId}`);
                await remove(listingRef);

                saveGameState();

                addToBattleLog(`Cancelled listing for ${listing.item.name}`, 'info');

                // Reload unified market
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error cancelling listing:', error);
                addToBattleLog('Failed to cancel listing. Please try again.', 'warning');

                // Remove item from inventory on error
                gameState.inventory.pop();
                updateInventoryDisplay();
            }
        }

        // Helper function to get time ago
        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        // Make functions globally accessible
        window.showMarket = showMarket;
        window.showUnifiedView = showUnifiedView;
        window.showSellMode = showSellMode;
        window.buyMarketItem = buyMarketItem;
        window.confirmSell = confirmSell;
        window.cancelListing = cancelListing;
        window.loadUnifiedMarket = loadUnifiedMarket;

        // Add message to battle log
        function addToBattleLog(message, type = 'info') {
            const now = new Date();
            const timeString = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;

            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;

            logEntry.innerHTML = `
                <span class="log-time">${timeString}</span> ${message}
            `;

            battleLog.appendChild(logEntry);
            battleLog.scrollTop = battleLog.scrollHeight;

            const entries = battleLog.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        // Auto Potion Toggle Event Listener
        const autoPotionToggle = document.getElementById('auto-potion-toggle');
        if (autoPotionToggle) {
            autoPotionToggle.addEventListener('change', (e) => {
                gameState.autoPotion = e.target.checked;
                saveGameState();
                addToBattleLog(`Auto Potion ${gameState.autoPotion ? 'enabled' : 'disabled'}.`, 'info');
            });
        }

        // Debug Tools Event Listeners
        const fixExpBtn = document.getElementById('fix-exp-btn');
        if (fixExpBtn) {
            fixExpBtn.addEventListener('click', () => {
                if (!gameState.character) {
                    alert('No character found!');
                    return;
                }

                const char = gameState.character;
                const oldMaxExp = char.maxExp;

                // Recalculate maxExp based on current level using NEW formula
                char.maxExp = Math.floor(50 * Math.pow(1.2, char.level - 1));

                addToBattleLog(`🔧 Fixed EXP! Old maxExp: ${oldMaxExp}, New maxExp: ${char.maxExp}`, 'success');
                addToBattleLog(`✨ You can now gain experience toward level ${char.level + 1}!`, 'level');

                updateCharacterDisplay();
                saveGameState();
            });
        }

        // Initialize the game when the page loads
        // NOTE: initGame() is now called by the auth flow AFTER Firebase data is loaded
        // This ensures Firebase is always the source of truth, not localStorage
        console.log('Page loaded, waiting for authentication...');
        // window.addEventListener('load', () => {
        //     console.log('Window load event fired, calling initGame');
        //     initGame();
        // });
    </script>
</body>

</html>
