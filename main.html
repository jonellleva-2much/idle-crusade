<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RF Online - Text-Based MMORPG</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300..800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="gm_style.css">
    <style>
        :root {
            --dark-bg: #121212;
            --darker-bg: #0a0a0a;
            --panel-bg: #1e1e1e;
            --accent: #2a2a2a;
            --highlight: #3a3a3a;
            --text: #e0e0e0;
            --text-dim: #a0a0a0;
            --accent-color: #ff7a2f;
            --accent-hover: #ff8a4f;
            --danger: #ff3f3f;
            --success: #4aff7a;
            --warning: #ffb84a;
            --exp-color: #ff9c4a;
            --encounter-color: #ffaa00;
            --fp-color: #4a9cff;
            --gem-color: #ff4a6a;
            --equip-color: #9c4aff;
        }

        /* Custom Scrollbar Styling */
        /* Webkit browsers (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--accent);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--highlight);
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--highlight) var(--accent);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Open Sans', sans-serif;
            font-size: 14px;
        }

        .battle-log,
        .log-entry,
        code,
        pre,
        .stat-value,
        .inventory-item-stats,
        .combat-value {
            font-family: 'Courier Prime', monospace;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: rgba(10, 10, 10, 0.95);
            padding: 0.8rem 2rem;
            border-bottom: 1px solid var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: calc(100% - 2rem);
            max-width: calc(1400px - 2rem);
            margin: 1rem auto 0;
            border-radius: 6px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-image {
            height: 40px;
            width: auto;
            object-fit: contain;
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        .logo-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-color);
            line-height: 1.2;
        }

        .logo-subtitle {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-weight: normal;
            margin-top: 0rem;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            /* Allow items to wrap */
        }


        nav a {
            color: var(--text);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        nav a:hover,
        nav a.active {
            background-color: var(--accent);
            color: var(--accent-color);
        }

        .container {
            display: flex;
            flex: 1;
            padding: 1rem;
            gap: 1rem;
            height: calc(100vh - 80px);
            overflow: hidden;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .mobile-tabs {
            display: none;
            gap: 0.5rem;
            margin: 0 200px 1rem;
        }

        .mobile-tab-btn {
            flex: 1;
            border: none;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-dim);
            padding: 0.7rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-tab-btn.active {
            background: var(--accent-color);
            color: #fff;
            box-shadow: 0 2px 8px rgba(255, 122, 47, 0.3);
        }

        /* Mobile Panel Visibility - Only on mobile screens */
        @media (max-width: 720px) {
            .mobile-tabs {
                display: flex;
            }

            .mobile-tab-panel {
                display: none !important;
            }

            .mobile-tab-panel.active-mobile {
                display: flex !important;
                flex-direction: column;
            }

            .container {
                flex-direction: column;
                height: auto;
                overflow: visible;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
            }
        }

        /* Desktop - ensure all panels are visible */
        @media (min-width: 721px) {
            .mobile-tab-panel {
                display: flex !important;
            }
        }

        .panel {
            background-color: rgba(30, 30, 30, 0.95);
            border-radius: 6px;
            padding: 1.25rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            flex-direction: column;
        }

        .left-panel {
            width: 25%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .center-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .right-panel {
            width: 25%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: calc(100vh - 120px);
            overflow-y: visible;
        }

        .inventory {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .inventory-scrollable {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--accent);
            color: var(--accent-color);
        }

        .character-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: var(--text-dim);
        }

        .stats {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .stat-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
        }

        .stat {
            background-color: var(--accent);
            padding: 0.8rem;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .level-value {
            color: var(--accent-color);
        }

        .hp-value {
            color: var(--danger);
        }

        .fp-value {
            color: var(--fp-color);
        }

        .attack-value {
            color: var(--warning);
        }

        .defense-value {
            color: var(--success);
        }

        .exp-value {
            color: var(--exp-color);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .battle-log {
            background-color: var(--darker-bg);
            border-radius: 4px;
            padding: 1rem 1rem 0.25rem;
            height: 400px;
            /* Default desktop height */
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .battle-log .log-entry:last-child {
            margin-bottom: 0;
        }

        .log-time {
            color: var(--text-dim);
        }

        .log-damage {
            color: #ff4a4a;
            /* Standard Red for Monster */
        }

        .log-player-damage {
            color: #ff4a4a;
            /* Pale Red for Player */
        }

        .log-heal {
            color: var(--success);
        }

        .log-loot {
            color: var(--warning);
        }

        .log-exp {
            color: var(--exp-color);
        }

        .log-level {
            color: var(--accent-color);
        }

        /* Normal monster encounters */
        .log-encounter {
            color: #dab600;
            background-color: rgba(255, 170, 0, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Exploring animation */
        .log-exploring {
            color: var(--text-dim);
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding: 0.25rem 0;
        }

        #exploring-text {
            font-style: italic;
        }

        .log-exploring .log-time {
            font-style: normal;
        }

        /* Boss monster encounters - increased specificity */
        .log-entry span.log-boss-encounter {
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.5) !important;
            background-color: rgba(255, 107, 53, 0.1) !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
        }

        /* Boss victory messages */
        .log-entry span.log-boss-victory {
            color: #ffaa00;
            background-color: rgba(255, 107, 53, 0.1) !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
        }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-buttons {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.7rem 1.2rem;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-family: 'Open Sans', sans-serif;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn:hover {
            background-color: var(--accent-hover);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: var(--accent);
            color: var(--text-dim);
            cursor: not-allowed;
        }

        /* Pulse Animation (Opacity & Scale) */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.85;
                transform: scale(0.99);
            }
        }

        .btn-pulsing {
            animation: pulse 0.66s infinite;
            background-color: var(--warning) !important;
            color: white !important;
            cursor: not-allowed;
        }

        .btn-success {
            background-color: var(--success) !important;
            color: white !important;
        }

        .btn-secondary {
            background-color: var(--accent);
        }

        .btn-secondary:hover {
            background-color: var(--highlight);
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-modal:hover {
            color: var(--accent-color);
        }

        /* Map item hover effects for unlocked maps */
        .map-item.map-unlocked:hover {
            opacity: 0.8 !important;
            transform: translateY(-2px) !important;
            transition: all 0.2s ease !important;
        }

        /* Dropdown Styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropbtn {
            background-color: var(--accent);
            color: var(--text);
            padding: 0.5rem 1rem;
            font-size: 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--panel-bg);
            min-width: 160px;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
            z-index: 1;
            border-radius: 4px;
            border: 1px solid var(--accent);
            right: 0;
            /* Align to right of parent */
        }

        .dropdown-content button {
            color: var(--text);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 1px solid var(--accent);
        }

        .dropdown-content button:last-child {
            border-bottom: none;
        }

        .dropdown-content button:hover {
            background-color: var(--highlight);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* Panel Header for Battle Log */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--accent);
        }

        .panel-header .panel-title {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        /* Header Buttons in Dropdown */
        .btn-add-leaves {
            color: var(--success) !important;
        }

        .btn-reset {
            color: var(--danger) !important;
        }

        .btn-save {
            color: #4a9cff !important;
        }

        /* Instant Finish Button in Header */
        #instant-finish-btn {
            padding: 4px 8px;
            font-size: 0.8rem;
            background-color: var(--warning);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Header Buttons */
        .header-btn {
            padding: 5px 10px;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
        }

        .btn-add-leaves {
            background: var(--success);
        }

        .btn-reset {
            background: var(--danger);
        }

        .btn-instant {
            background: var(--warning);
        }

        #maps-main-btn {
            background-color: #4a9cff;
            /* Distinct blue color */
            color: white;
        }

        #maps-main-btn:hover {
            background-color: #3a8ce0;
        }

        .btn-equip {
            background-color: var(--success);
        }

        .btn-equip:hover {
            background-color: #6aff9a;
        }

        .btn-stop {
            background-color: var(--danger);
        }

        .btn-stop:hover {
            background-color: #ff6a6a;
        }

        .btn-sell {
            background-color: var(--warning);
        }

        .btn-sell:hover {
            background-color: #ffca4a;
        }

        .btn-upgrade {
            background-color: var(--equip-color);
        }

        .btn-upgrade:hover {
            background-color: #ac7aff;
        }

        .explore-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .explore-option {
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .inventory {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .currency {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            padding: 0.5rem;
            background-color: var(--accent);
            border-radius: 4px;
            margin-bottom: 0.1rem;
        }

        .currency-icon {
            color: var(--warning);
        }

        .items {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .item-compact {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            border: 1px solid transparent;
        }

        .item-compact.equipped {
            border: 2px solid var(--accent-color);
        }

        .item-compact-info {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .item-compact-name {
            line-height: 1.2;
            font-size: 0.80rem;
        }

        .item-compact-stats {
            font-size: 0.8rem;
            color: var(--text);
            line-height: 1.1;
        }

        .item-compact-sell {
            font-size: 0.7rem;
            color: var(--warning);
            line-height: 1.1;
        }

        .item-compact-actions {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.3rem;
        }

        .btn-small {
            padding: 0.3rem 0.5rem;
            font-size: 0.85rem;
            flex: 1;
        }

        .empty-inventory {
            text-align: center;
            padding: 1rem;
            color: var(--text-dim);
            font-style: italic;
        }

        .material-item {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .inventory-limit {
            font-size: 0.8rem;
            color: var(--text-dim);
            text-align: left;
            margin-top: 0.2rem;
            margin-bottom: 0.5rem;
        }

        .explore-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            width: 100%;
            margin-top: -12px !important;
            /* Negative margin to reduce gap above */
            margin-bottom: -15px !important;
            /* Negative margin to reduce gap below */
        }

        #explore-timer {
            text-align: right;
            margin-left: auto;
        }

        #explore-selected-time {
            text-align: left;
            font-weight: normal;
            color: var(--text-dim);
        }


        .progress-bar {
            height: 8px;
            background-color: var(--darker-bg);
            border-radius: 4px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
        }

        .hp-bar {
            background-color: var(--danger);
        }

        .fp-bar {
            background-color: var(--fp-color);
        }

        .exp-bar {
            background-color: var(--exp-color);
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 0.3rem;
        }

        .gem-emoji {
            color: var(--gem-color);
        }

        .modal,
        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            position: relative;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-dim);
        }

        .form-input {
            width: 100%;
            padding: 0.8rem;

            /* Market Styles */
            .market-container {
                width: 100%;
            }

            .market-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .market-title {
                color: var(--accent-color);
                font-size: 1.5rem;
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-btn {
                padding: 0.75rem 1.25rem;
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .sell-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .market-mode {
                display: none;
            }

            .market-mode.active {
                display: block;
            }

            .back-btn {
                padding: 0.5rem 1rem;
                background: var(--darker-bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-primary);
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.9rem;
            }

            .back-btn:hover {
                background: var(--bg);
                border-color: var(--accent-color);
            }

            .view-header {
                display: flex;
                align-items: flex-start;
                gap: 1rem;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .view-title h3 {
                color: var(--accent-color);
                margin: 0 0 0.25rem 0;
                font-size: 1.3rem;
            }

            .view-description {
                color: var(--text-dim);
                margin: 0;
                font-size: 0.95rem;
            }

            .market-items,
            .my-listings {
                max-height: 500px;
                overflow-y: auto;
            }

            .market-item,
            .listing-item {
                display: flex;
                flex-direction: column;
                padding: 1.25rem;
                border: 1px solid var(--border);
                border-radius: 8px;
                margin-bottom: 0.75rem;
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }

            .market-item:hover,
            .listing-item:hover {
                border-color: var(--accent-color);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                transform: translateY(-1px);
            }

            .market-item::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 3px;
                background: linear-gradient(90deg, var(--accent-color), var(--success));
            }

            .market-item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.75rem;
            }

            .market-item-name,
            .listing-item-name {
                font-size: 1.1rem;
                font-weight: bold;
                color: var(--accent-color);
                margin: 0;
            }

            .market-item-price,
            .listing-item-price {
                font-size: 1.2rem;
                font-weight: bold;
                color: var(--success);
                display: flex;
                align-items: center;
                gap: 0.25rem;
            }

            .currency-icon {
                font-size: 0.9rem;
            }

            .market-item-stats {
                font-size: 0.9rem;
                color: var(--text-primary);
                margin-bottom: 0.75rem;
                padding: 0.5rem;
                background-color: rgba(255, 255, 255, 0.03);
                border-radius: 4px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .market-item-footer {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .market-item-seller {
                font-size: 0.85rem;
                color: var(--text-dim);
                font-style: italic;
            }

            .market-item button,
            .listing-item button {
                padding: 0.6rem 1.2rem;
                border-radius: 6px;
                font-weight: 500;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .market-item button:hover,
            .listing-item button:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }

            .btn-success {
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                color: white;
            }

            .btn-success:hover {
                background: linear-gradient(135deg, #4CAF50, var(--success));
            }

            .btn-danger {
                background: linear-gradient(135deg, var(--danger), #f44336);
                border: none;
                color: white;
            }

            .btn-danger:hover {
                background: linear-gradient(135deg, #f44336, var(--danger));
            }

            .btn-icon {
                font-size: 0.9rem;
            }

            /* Simple Market Styles */
            .market-container {
                width: 100%;
            }

            .market-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 2rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border);
            }

            .market-title {
                color: var(--accent-color);
                font-size: 1.5rem;
                margin: 0;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-btn {
                padding: 0.75rem 1.25rem;
                background: linear-gradient(135deg, var(--success), #4CAF50);
                border: none;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .sell-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .market-mode {
                display: none;
            }

            .market-mode.active {
                display: block;
            }

            .sell-interface {
                padding: 1rem 0;
            }

            .sell-section {
                padding: 0;
            }

            .sell-header {
                text-align: center;
                margin-bottom: 2rem;
            }

            .sell-header h3 {
                color: var(--accent-color);
                margin-bottom: 0.5rem;
                font-size: 1.3rem;
            }

            .sell-description {
                color: var(--text-dim);
                font-size: 0.95rem;
                margin: 0;
            }

            .cancel-sell-btn {
                margin-top: 1rem;
                padding: 0.5rem 1rem;
                background: var(--darker-bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-primary);
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.9rem;
            }

            .cancel-sell-btn:hover {
                background: var(--bg);
                border-color: var(--accent-color);
            }

            .sell-item-display {
                padding: 1.25rem;
                background: linear-gradient(135deg, var(--bg) 0%, var(--darker-bg) 100%);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                margin-bottom: 1.5rem;
                min-height: 80px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .no-item-selected {
                color: var(--text-dim);
                font-style: italic;
            }

            .sell-price-input {
                margin-bottom: 2rem;
            }

            .sell-price-input label {
                display: block;
                margin-bottom: 0.75rem;
                color: var(--text-primary);
                font-weight: 500;
            }

            .price-input-wrapper {
                display: flex;
                align-items: center;
                background-color: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                overflow: hidden;
            }

            .price-input-wrapper .currency-icon {
                padding: 0.75rem 1rem;
                background-color: rgba(255, 255, 255, 0.05);
                border-right: 1px solid var(--border);
            }

            .sell-price-input input {
                flex: 1;
                padding: 0.75rem 1rem;
                background-color: transparent;
                border: none;
                color: var(--text-primary);
                font-size: 1rem;
                text-align: right;
            }

            .sell-price-input input:focus {
                outline: none;
            }

            .price-input-wrapper:focus-within {
                border-color: var(--accent-color);
                box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            }

            .inventory-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.75rem;
                margin-bottom: 2rem;
                max-height: 350px;
                overflow-y: auto;
                padding: 1rem;
                background-color: rgba(255, 255, 255, 0.02);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .inventory-item {
                padding: 0.75rem;
                border: 1px solid var(--border);
                border-radius: 6px;
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                cursor: pointer;
                text-align: center;
                transition: all 0.3s ease;
                position: relative;
            }

            .inventory-item:hover {
                border-color: var(--accent-color);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            .inventory-item.selected {
                border-color: var(--success);
                background: linear-gradient(135deg, rgba(76, 175, 80, 0.1) 0%, rgba(46, 125, 50, 0.1) 100%);
                box-shadow: 0 0 0 2px var(--success);
            }

            .inventory-item.selected::after {
                content: '✓';
                position: absolute;
                top: 5px;
                right: 5px;
                background-color: var(--success);
                color: white;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
            }

            .inventory-item-name {
                font-size: 0.85rem;
                font-weight: bold;
                margin-bottom: 0.5rem;
                color: var(--accent-color);
            }

            .inventory-item-stats {
                font-size: 0.75rem;
                color: var(--text-dim);
                line-height: 1.2;
            }

            .sell-form {
                background: linear-gradient(135deg, var(--darker-bg) 0%, var(--bg) 100%);
                padding: 2rem;
                border-radius: 8px;
                border: 1px solid var(--border);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }

            .sell-preview h4,
            .sell-price-section h4 {
                color: var(--accent-color);
                margin-bottom: 1rem;
                font-size: 1.1rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .sell-item-info {
                padding: 1.25rem;
                background: linear-gradient(135deg, var(--bg) 0%, var(--darker-bg) 100%);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                margin-bottom: 1.5rem;
                min-height: 80px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .no-item-selected {
                color: var(--text-dim);
                font-style: italic;
                text-align: center;
            }

            .sell-price-input {
                margin-bottom: 2rem;
            }

            .sell-price-input label {
                display: block;
                margin-bottom: 0.75rem;
                color: var(--text-primary);
                font-weight: 500;
            }

            .price-input-wrapper {
                display: flex;
                align-items: center;
                background-color: var(--bg);
                border: 1px solid var(--border);
                border-radius: 6px;
                overflow: hidden;
            }

            .price-input-wrapper .currency-icon {
                padding: 0.75rem 1rem;
                background-color: rgba(255, 255, 255, 0.05);
                border-left: 1px solid var(--border);
            }

            .sell-price-input input {
                flex: 1;
                padding: 0.75rem 1rem;
                background-color: transparent;
                border: none;
                color: var(--text-primary);
                font-size: 1rem;
                text-align: right;
            }

            .sell-price-input input:focus {
                outline: none;
            }

            .price-input-wrapper:focus-within {
                border-color: var(--accent-color);
                box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            }

            .price-hint {
                font-size: 0.85rem;
                color: var(--text-dim);
                margin-top: 0.5rem;
                font-style: italic;
            }

            .sell-buttons {
                display: flex;
                gap: 1rem;
                justify-content: center;
                margin-top: 2rem;
            }

            .loading {
                text-align: center;
                color: var(--text-dim);
                padding: 3rem 1rem;
                font-style: italic;
            }

            .loading::before {
                content: '⏳';
                font-size: 2rem;
                display: block;
                margin-bottom: 1rem;
            }

            .empty-state {
                text-align: center;
                color: var(--text-dim);
                padding: 3rem 1rem;
            }

            .empty-icon {
                font-size: 3rem;
                margin-bottom: 1rem;
                opacity: 0.6;
            }

            .empty-state h3 {
                color: var(--accent-color);
                margin-bottom: 0.5rem;
                font-size: 1.2rem;
            }

            .empty-state p {
                margin: 0;
                font-size: 0.95rem;
                line-height: 1.4;
            }

            background-color: var(--darker-bg);
            border: 1px solid var(--accent);
            border-radius: 4px;
            color: var(--text);
        }

        .race-options,
        .class-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .race-option,
        .class-option {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .race-option:hover,
        .class-option:hover,
        .race-option.selected,
        .class-option.selected {
            background-color: var(--highlight);
            border: 1px solid var(--accent-color);
        }

        .gender-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .gender-option {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .gender-option:hover,
        .gender-option.selected {
            background-color: var(--highlight);
            border: 1px solid var(--accent-color);
        }

        .players-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            border-bottom: 1px solid var(--accent);
        }

        .player-rank {
            width: 30px;
            text-align: center;
            font-weight: bold;
        }

        .player-name {
            flex: 1;
        }

        .player-level {
            width: 60px;
            text-align: right;
        }

        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .upgrade-content {
            background-color: var(--panel-bg);
            border-radius: 6px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .upgrade-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-color);
        }

        .upgrade-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--accent);
            border-radius: 4px;
        }

        .upgrade-info {
            margin-bottom: 1rem;
        }

        .upgrade-cost {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--warning);
            margin-bottom: 1rem;
        }

        .upgrade-chance {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .upgrade-result {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }

        .upgrade-success {
            background-color: rgba(74, 255, 122, 0.2);
            color: var(--success);
        }

        .upgrade-failure {
            background-color: rgba(255, 74, 74, 0.2);
            color: var(--danger);
        }

        .small-title {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            margin-top: 0.8rem;
            color: var(--accent-color);
            border-bottom: 1px solid var(--accent);
            padding-bottom: 0.2rem;
        }

        .material-item-compact {
            background-color: var(--accent);
            border-radius: 4px;
            padding: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            flex-wrap: nowrap;
        }

        .material-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.8rem;
        }

        .material-price {
            color: var(--text-dim);
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .material-item-compact .btn-small {
            flex: 0 0 60px;
            max-width: 80px;
        }

        .stat-bars-container {
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .stat-bar-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-bar-label {
            width: 30px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .stat-bar-progress {
            flex: 1;
            height: 12px;
            background-color: var(--darker-bg);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar-value {
            width: 50px;
            text-align: right;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .character-details-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            margin-bottom: 1.5rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--accent);
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .highlight-detail {
            color: var(--accent-color);
            font-weight: bold;
            font-size: .1rem;
        }

        .level-detail {
            color: var(--accent-color);
            font-weight: bold;
            font-size: 1rem !important;
            /* !important to override .detail-value */
            /* ← Adjust this for Level size */
        }

        .exp-container {
            margin-bottom: 1.5rem;
        }

        .detail-label {
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .detail-value {
            font-weight: normal;
            color: var(--text);
            font-size: 0.9rem;
        }

        .combat-stats {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .combat-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inventory-item,
        .material-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 0.85rem;
            /* Reduced font size */
        }

        .inventory-item span,
        .material-item span {
            font-size: 0.8rem;
            /* Further reduce text size for items */
        }

        /* Specific style for Leaves/Currency if they appear in list */
        .currency-item {
            font-size: 0.8rem;
        }

        .combat-label {
            font-weight: normal;
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .combat-value {
            font-size: 0.9rem;
            font-weight: normal;
        }

        .item-rarity-t1 {
            color: #f8c291 !important;
            /* Yellow */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .item-rarity-intense {
            color: #f1c40f !important;
            /* Gold/Yellow */
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.3);
        }

        .item-rarity-relic {
            color: #2980b9 !important;
            /* Blue */
            text-shadow: 0 0 5px rgba(41, 128, 185, 0.3);
        }

        /* Mobile Optimization */
        @media (max-width: 720px) {
            header {
                margin: 0;
                padding: 0.5rem 1rem;
                flex-direction: column;
                align-items: stretch;
                gap: 1.5rem;
                position: sticky;
                top: 0;
                width: 100%;
                z-index: 1000;
                background-color: rgba(10, 10, 10, 0.98);
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            }

            .logo {
                margin-bottom: 0.5rem;
                gap: 0.5rem;
            }

            .logo-image {
                height: 32px;
            }

            .logo-title {
                font-size: 1.1rem;
            }

            .logo-subtitle {
                font-size: 0.7rem;
                margin-top: 0.05rem;
            }

            nav {
                width: 100%;
            }

            nav ul {
                justify-content: center;
                gap: 0.3rem;
                padding: 0;
                display: flex;
                flex-wrap: wrap;
                list-style: none;
            }

            /* Create two rows for mobile navigation */
            nav li:nth-child(-n+4) {
                order: 1;
            }

            nav li:nth-child(n+5) {
                order: 2;
            }

            /* Style the logout button for mobile */
            nav li:last-child .btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }

            .dropdown-content {
                right: 0;
                min-width: 180px;
            }

            .mobile-tabs {
                display: flex;
                margin: 0 0 0.5rem;
            }

            /*panel padding*/
            .container {
                margin: 0;
                flex-direction: column;
                height: auto;
                overflow-y: auto;
                padding: 2.0rem;
                padding-bottom: 80px;
                gap: 0.6rem;
                width: 100%;
                max-width: 100%;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
                height: auto;
                overflow: visible;
                padding: 0.75rem;
                /* Reduce padding slightly */
            }

            .panel-title {
                font-size: 1rem;
                margin-bottom: 0.7rem;
            }

            .mobile-tab-panel {
                display: none;
            }

            .mobile-tab-panel.active-mobile {
                display: block;
            }

            .right-panel {
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .inventory {
                height: auto;
            }

            .inventory-scrollable {
                max-height: 55vh;
                overflow-y: auto;
            }

            .battle-log {
                height: 300px;
                /* Slightly shorter to show more actions */
                font-size: 0.8rem;
                line-height: 1.3;
                border: 1px solid rgba(255, 255, 255, 0.05);
            }

            .stat-group {
                grid-template-columns: repeat(4, 1fr);
            }

            .actions {
                flex-direction: column;
                /* Stack actions vertically or wrap */
                gap: 0.4rem;
            }

            .action-buttons {
                flex-wrap: wrap;
                justify-content: space-between;
                /* Distribute buttons */
                gap: 0.4rem;
            }

            .btn {
                flex: 1 1 40%;
                /* Grow and shrink, basis 40% */
                min-width: 100px;
                /* Smaller touch targets */
                padding: 0.6rem 0.4rem;
                font-size: 0.85rem;
            }

            #auth-btn {
                min-width: auto;
                flex: none;
                width: auto;
                padding: 0.4rem 0.6rem;
            }

            .explore-options {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .explore-option {
                flex: 0 0 calc(50% - 0.25rem);
                min-width: 0;
            }

            .explore-option .btn {
                width: 100%;
                padding: 0.55rem 0.4rem;
            }

            .explore-status {
                margin-top: 0 !important;
                margin-bottom: 0.4rem !important;
                padding: 0 0.4rem;
            }

            .combat-stat {
                padding: 0.4rem 0.25rem;
            }

            .skills-group {
                gap: 0.4rem;
            }
        }

        .crafting-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .crafting-content {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .craft-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .craft-tab {
            background-color: var(--accent);
            border: 1px solid transparent;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
            font-size: 1.4rem;
        }

        .craft-tab:hover,
        .craft-tab.active {
            background-color: var(--highlight);
            border-color: var(--accent-color);
        }

        .recipe-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .recipe-item {
            background-color: var(--accent);
            padding: 1rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .recipe-item:hover {
            background-color: var(--highlight);
        }

        .recipe-item.selected {
            border-color: var(--accent-color);
            background-color: var(--highlight);
        }

        .recipe-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .recipe-requirements {
            font-size: 0.9rem;
            color: var(--text-dim);
        }

        .req-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.2rem;
        }

        .req-met {
            color: var(--success);
        }

        .req-missing {
            color: var(--danger);
        }

        /* Skills Section in Left Panel */
        .skills-group {
            margin-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 1rem;
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .skills-header {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .skill-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
            font-size: 0.9rem;
            width: 100%;
        }

        .skill-label {
            color: var(--text-dim);
        }

        .skill-value {
            color: var(--text-color);
        }

        .skill-value.locked {
            color: var(--text-dim);
            font-style: italic;
        }

        .skill-value.unlocked {
            color: var(--accent-color);
        }


        /* Encounter Tracker */
        .encounter-tracker {
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .encounter-item {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
        }

        .encounter-name {
            color: var(--text);
        }

        .encounter-count {
            color: var(--accent-color);
        }

        /* Loading Screen */
        #auth-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--accent);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 1.5rem;
            color: var(--text-dim);
            font-size: 1rem;
            text-align: center;
        }

        .loading-title {
            margin-bottom: 2rem;
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .force-clear-btn {
            margin-top: 2rem;
            padding: 0.8rem 2rem;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
        }

        .force-clear-btn:hover {
            background: #ff6a6a;
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="auth-loading">
        <div class="loading-title">RF Online: Idle Crusade</div>
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Verifying authentication...</div>
        <button class="force-clear-btn" id="force-clear-btn" onclick="forceClearAndReload()">🧹 Force Clear All
            Data</button>
    </div>
    <header>
        <div class="logo">
            <img src="logo.png" alt="RF Online Logo" class="logo-image">
            <div class="logo-text">
                <div class="logo-title">RF Online: Idle Crusade</div>
                <div class="logo-subtitle">RF Online themed semi idle text based rpg game.</div>
            </div>
        </div>
        <nav>
            <ul>
                <li><a href="#" class="active">Game</a></li>
                <li style="display: none;"><a href="#" id="maps-btn">Maps</a></li>
                <li><a href="#" id="arena-btn">Arena</a></li>
                <li><a href="#" id="chip-war-btn">Chip War</a></li>
                <li><a href="#" id="market-btn">Market</a></li>
                <li><a href="#" id="shop-btn">Shop</a></li>
                <li><a href="#" id="guild-btn">Guild</a></li>
                <li><a href="#" id="rankings-btn">Rankings</a></li>
                <li>
                    <button id="auth-btn" class="btn"
                        style="background-color: var(--accent); font-size: 0.9rem;">Logout</button>
                </li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <!-- Left Panel - Character Details -->
        <div class="mobile-tabs" id="mobile-tabs">
            <button class="mobile-tab-btn active" data-tab="character">Character</button>
            <button class="mobile-tab-btn" data-tab="battle">Battle Log</button>
            <button class="mobile-tab-btn" data-tab="inventory">Inventory</button>
        </div>

        <!-- Left Panel - Character Details -->
        <div class="panel left-panel mobile-tab-panel" id="panel-character">
            <div class="panel-header">
                <h2 class="panel-title">CHARACTER</h2>
                <label
                    style="font-size: 0.75rem; display: flex; align-items: center; cursor: pointer; color: var(--text-dim); white-space: nowrap;">
                    <input type="checkbox" id="auto-potion-toggle" checked style="margin-right: 4px;"> Auto Potion
                </label>
            </div>

            <!-- 1. HP and FP Bars -->
            <div class="stat-bars-container">
                <div class="stat-bar-row">
                    <div class="stat-bar-label" style="color: var(--danger)">HP</div>
                    <div class="stat-bar-progress">
                        <div class="progress-fill hp-bar" style="width: 100%"></div>
                    </div>
                    <div class="stat-bar-value hp-value" id="char-hp">100</div>
                </div>
                <div class="stat-bar-row">
                    <div class="stat-bar-label" style="color: var(--fp-color)">FP</div>
                    <div class="stat-bar-progress">
                        <div class="progress-fill fp-bar" style="width: 100%"></div>
                    </div>
                    <div class="stat-bar-value fp-value" id="char-fp">50</div>
                </div>
            </div>

            <!-- 2. Character Details -->
            <div class="character-details-list">
                <!-- Level and Exp -->
                <div class="detail-row">
                    <span class="detail-label">Level</span>
                    <span class="detail-value level-detail" id="char-level">1</span>
                </div>
                <div class="exp-container">
                    <div class="progress-bar" style="height: 8px; margin-top: 0.2rem; margin-bottom: 0.2rem;">
                        <div class="progress-fill exp-bar" style="width: 0%"></div>
                    </div>
                    <div style="text-align: right; font-size: 0.8rem; color: var(--text-dim);">
                        <span id="char-exp">0/100</span>
                    </div>
                </div>

                <!-- Name -->
                <div class="detail-row">
                    <span class="detail-label">Name</span>
                    <span class="detail-value highlight-detail" id="char-name">-</span>
                </div>

                <!-- Other Details -->
                <div class="detail-row">
                    <span class="detail-label">Race</span>
                    <span class="detail-value" id="char-race">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Gender</span>
                    <span class="detail-value" id="char-gender">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Class</span>
                    <span class="detail-value" id="char-class">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Guild</span>
                    <span class="detail-value" id="char-guild">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Location</span>
                    <span class="detail-value" id="char-location">-</span>
                </div>
            </div>

            <!-- 3. Combat Stats -->
            <div class="combat-stats">
                <div class="combat-stat">
                    <span class="combat-label">Attack</span>
                    <span class="combat-value attack-value" id="char-attack">10</span>
                </div>
                <div class="combat-stat">
                    <span class="combat-label">Defense</span>
                    <span class="combat-value defense-value" id="char-defense">5</span>
                </div>
                <div class="combat-stat">
                    <span class="combat-label">Crit Chance</span>
                    <span class="combat-value" id="char-crit" style="color: #ff4444;">5%</span>
                </div>
                <div class="combat-stat" id="lifesteal-stat-container" style="display: none;">
                    <span class="combat-label">Lifesteal</span>
                    <span class="combat-value" id="char-lifesteal" style="color: #00ff00;">0%</span>
                </div>
                <div class="combat-stat" id="dmg-red-stat-container" style="display: none;">
                    <span class="combat-label">Dmg Red.</span>
                    <span class="combat-value" id="char-dmg-red" style="color: #3498db;">0%</span>
                </div>
                <div class="combat-stat" id="speed-stat-container" style="display: none;">
                    <span class="combat-label">Speed</span>
                    <span class="combat-value" id="char-speed" style="color: #ffaa00;">0</span>
                </div>
            </div>

            <!-- 4. Skills -->
            <div class="skills-group">
                <div class="skills-header">Skills</div>
                <div class="skill-row">
                    <span class="skill-label">Basic</span>
                    <span class="skill-value" id="skill-basic">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Expert</span>
                    <span class="skill-value" id="skill-expert">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Elite</span>
                    <span class="skill-value" id="skill-elite">Locked</span>
                </div>
                <div class="skill-row">
                    <span class="skill-label">Ultimate</span>
                    <span class="skill-value" id="skill-ultimate">Locked</span>
                </div>
            </div>
        </div>

        <!-- Center Panel - Battle Logs and Actions -->
        <div class="panel center-panel mobile-tab-panel" id="panel-battle">
            <div class="panel-header">
                <h2 class="panel-title">BATTLE LOG</h2>
            </div>
            <div class="explore-status" id="explore-status" style="display: flex;">
                <span id="explore-selected-time">AFK</span>
                <span id="explore-timer"></span>
            </div>
            <div class="battle-log" id="battle-log">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span> Welcome to RF Online! Start exploring to battle monsters
                    and gain experience.
                </div>
                <div class="log-entry log-exploring" id="exploring-animation" style="display: none;">
                    <span class="log-time" id="exploring-time">[00:00:00]</span>
                    <span id="exploring-text">Exploring</span>
                </div>
            </div>

            <div class="actions">
                <h3 class="panel-title small-title">ACTIONS</h3>
                <div class="action-buttons">
                    <button class="btn" id="explore-btn">Explore</button>
                    <button class="btn btn-secondary" id="maps-main-btn">Maps</button>
                    <button class="btn btn-stop" id="stop-btn" style="display: none;">Stop</button>
                </div>

                <div class="explore-options" id="explore-options" style="display: none;">
                    <!-- Time-based exploration (HQ, Sette Desert) -->
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-30">30 mins</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-60">1 hour</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-360">6 hours</button>
                    </div>
                    <div class="explore-option time-based-explore">
                        <button class="btn" id="explore-720">12 hours</button>
                    </div>

                    <!-- Area-based exploration (Ether Platform) -->
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-wharf">Wharf</button>
                    </div>
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-white-hole">White Hole</button>
                    </div>
                    <div class="explore-option area-based-explore" style="display: none;">
                        <button class="btn" id="explore-lures-lot">Lures Lot</button>
                    </div>
                </div>

                <!-- Monster Encounter Tracker -->
                <div id="encounter-tracker" style="display: none; margin-top: 1rem; font-size: 0.7rem;">
                    <div style="margin-bottom: 0.3rem; color: var(--text-dim);">Last Exploration:</div>
                    <div id="encounter-list"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Inventory -->
        <div class="panel right-panel mobile-tab-panel" id="panel-inventory">
            <div class="inventory">
                <div class="panel-header">
                    <h2 class="panel-title">INVENTORY</h2>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button class="btn btn-secondary" id="craft-btn"
                            style="background-color: #2ecc71; padding: 4px 12px; font-size: 0.8rem; width: auto; min-width: auto; flex: none;">Craft</button>
                        <button class="btn btn-secondary" id="sell-all-btn"
                            style="background-color: #e74c3c; padding: 4px 12px; font-size: 0.8rem; width: auto; min-width: auto; flex: none;">Sell
                            All</button>
                    </div>
                </div>
                <div class="currency">
                    Leaves 🍃 <span id="currency-amount">0</span> &nbsp;|&nbsp; Coins 🪙 <span
                        id="coins-amount">0</span>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 class="panel-title small-title" style="margin-bottom: 0;">ITEMS</h3>
                    <div class="inventory-limit" id="inventory-limit" style="margin-bottom: 0;">0/15</div>
                </div>

                <!-- Scrollable Items Section -->
                <div class="inventory-scrollable">
                    <div class="items" id="inventory-items">
                        <!-- Items will be dynamically added here -->
                    </div>
                    <div class="empty-inventory" id="empty-inventory">Your inventory is empty</div>

                    <div class="upgrade-section">
                        <h3 class="panel-title small-title">OTHER MATERIALS</h3>
                        <div class="items" id="materials-items">
                            <!-- Materials will be dynamically added here -->
                        </div>
                        <div class="empty-inventory" id="empty-materials">No upgrade materials</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Registration Modal -->
    <div class="modal" id="registration-modal">
        <div class="modal-content">
            <h2 class="modal-title">CREATE CHARACTER</h2>
            <div class="form-group">
                <label class="form-label" for="char-name-input">Character Name</label>
                <input type="text" class="form-input" id="char-name-input" placeholder="Enter your character name"
                    maxlength="10">
            </div>

            <div class="form-group">
                <label class="form-label">Select Race</label>
                <div class="race-options">
                    <div class="race-option" data-race="Accretia">Accretia</div>
                    <div class="race-option" data-race="Bellato">Bellato</div>
                    <div class="race-option" data-race="Cora">Cora</div>
                </div>
            </div>

            <div class="form-group" id="gender-selection" style="display: none;">
                <label class="form-label">Select Gender</label>
                <div class="gender-options">
                    <div class="gender-option" data-gender="Male">Male</div>
                    <div class="gender-option" data-gender="Female">Female</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Select Class</label>
                <div class="class-options" id="class-options">
                    <!-- Classes will be dynamically populated based on race -->
                </div>
            </div>

            <button class="btn" id="create-character-btn">Create Character</button>
        </div>
    </div>

    <!-- Players Modal -->
    <div class="modal" id="players-modal">
        <div class="modal-content">
            <h2 class="modal-title">PLAYER RANKINGS</h2>
            <div class="players-list" id="players-list">
                <!-- Player rows will be dynamically added here -->
            </div>
        </div>
    </div>

    <!-- Maps Modal -->
    <div class="modal" id="maps-modal">
        <div class="modal-content">
            <button class="close-modal"
                onclick="document.getElementById('maps-modal').style.display='none'">&times;</button>
            <h2 class="modal-title">MAPS</h2>
            <div class="maps-list" id="maps-list">
                <div class="map-item" id="hq-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; border: 2px solid var(--accent-color);">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">🏠 HQ</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 1-20</div>
                </div>
                <div class="map-item" id="sette-desset-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; opacity: 1;">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">🏜️ Sette Desert</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 20+</div>
                </div>
                <div class="map-item" id="ether-platform-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: pointer; opacity: 1;">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">🌌 Ether Platform</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 30+ <span
                            style="color: var(--warning); font-size: 0.8rem;">(Cost: 1000 Leaves)</span></div>
                </div>
                <div class="map-item" id="volcanic-cauldron-map"
                    style="padding: 1rem; background-color: var(--accent); border-radius: 4px; margin-bottom: 1rem; cursor: not-allowed; opacity: 0.5;">
                    <div class="map-name" style="font-weight: bold; font-size: 1.1rem;">🌋 Volcanic Cauldron</div>
                    <div class="map-level" style="color: var(--text-dim);">Level 40+ <span
                            style="color: var(--danger); font-size: 0.8rem;">(Coming Soon)</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Market Modal -->
    <div class="modal" id="market-modal">
        <style>
            .market-item-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0.75rem 1rem;
                margin-bottom: 0.5rem;
                border-radius: 6px;
                background: var(--panel-bg);
                border: 1px solid rgba(255, 255, 255, 0.1);
                transition: all 0.2s ease;
            }

            .market-item-row:hover {
                background: var(--bg);
                border-color: var(--accent);
                transform: translateX(2px);
            }

            .market-item-row.my-listing {
                background: linear-gradient(90deg, rgba(52, 152, 219, 0.15) 0%, var(--panel-bg) 100%);
                border-left: 3px solid var(--accent-color);
            }

            .market-item-row.my-listing:hover {
                background: linear-gradient(90deg, rgba(52, 152, 219, 0.2) 0%, var(--bg) 100%);
            }

            .market-item-info {
                display: flex;
                align-items: center;
                gap: 1.5rem;
                flex: 1;
            }

            .market-item-name {
                min-width: 200px;
                font-weight: 500;
                color: var(--text);
                font-size: 0.95rem;
            }

            .market-item-stats {
                min-width: 120px;
                color: var(--text-dim);
                font-size: 0.9rem;
            }

            .market-item-price {
                min-width: 100px;
                font-weight: 600;
                color: var(--success);
                font-size: 1rem;
            }

            .market-item-action {
                min-width: 100px;
                text-align: right;
            }

            @media (max-width: 768px) {
                .market-item-row {
                    display: grid;
                    grid-template-columns: 1fr auto;
                    grid-template-areas:
                        "name price"
                        "stats action";
                    gap: 0.4rem;
                    padding: 0.8rem;
                    align-items: center;
                }

                .market-item-info {
                    display: contents;
                }

                .market-item-name {
                    grid-area: name;
                    font-size: 0.9rem;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    min-width: 0;
                }

                .market-item-price {
                    grid-area: price;
                    font-size: 0.95rem;
                    font-weight: bold;
                    text-align: right;
                    margin: 0 0 0 0.5rem;
                    white-space: nowrap;
                }

                .market-item-stats {
                    grid-area: stats;
                    font-size: 0.75rem;
                    color: var(--text-dim);
                    text-align: left;
                    white-space: nowrap;
                    margin: 0;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .market-item-action {
                    grid-area: action;
                    width: auto;
                    min-width: 0;
                    text-align: right;
                    margin: 0;
                }

                .market-item-action button {
                    width: auto;
                    padding: 0.3rem 0.8rem;
                    font-size: 0.8rem;
                    min-width: 70px;
                }
            }
        </style>
        <div class="modal-content" style="max-width: 1000px; padding-bottom: 2rem;">
            <!-- Header with title, sell button, and close button -->
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 2rem; padding-right: 3rem;">
                <h2 class="modal-title" style="margin: 0;">🏪 GLOBAL MARKET</h2>
                <button class="btn btn-success" onclick="showSellMode()"
                    style="padding: 0.3rem 0.6rem; font-size: 0.8rem; flex: none;">
                    <span class="btn-icon">💰</span> Sell Items
                </button>
            </div>
            <button class="close-modal" onclick="document.getElementById('market-modal').style.display='none'"
                style="top: 1.5rem; right: 1.5rem;">×</button>

            <!-- Single unified market view -->
            <div id="market-unified-view">
                <!-- My Listings Section -->
                <div id="my-listings-section" style="margin-bottom: 2rem;">
                    <h3 style="color: var(--text); font-size: 0.8rem; margin-bottom: 1rem; padding-left: 0.5rem;">
                        📋 My Listings
                    </h3>
                    <div id="my-listings-container">
                        <!-- My listings will be loaded here -->
                    </div>
                </div>

                <!-- Market Items Section -->
                <div id="market-items-section">
                    <h3 style="color: var(--text); font-size: 0.8rem; margin-bottom: 1rem; padding-left: 0.5rem;">
                        🛒 Available Items
                    </h3>
                    <div id="market-items-container">
                        <!-- Market items will be loaded here -->
                    </div>
                </div>
            </div>



            <!-- Claim Payments Section -->
            <div id="market-claim-payments" style="display: none;">

                <div id="pending-payments-container">
                    <!-- Pending payments will be loaded here -->
                </div>

                <div id="claim-summary"
                    style="display: none; margin-top: 1.5rem; padding: 1rem; background: var(--panel-bg); border-radius: 8px; text-align: center;">
                    <div id="claim-total"
                        style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color); margin-bottom: 1rem;">
                    </div>
                    <button class="btn btn-primary" onclick="processClaimPayments()" style="padding: 0.5rem 1.5rem;">
                        <span class="btn-icon">💰</span> Claim All Payments
                    </button>
                </div>
            </div>

            <!-- Sell Mode (Modal within modal) -->
            <div id="market-sell-mode" style="display: none;">
                <div style="text-align: center; margin-bottom: 2rem;">
                    <h3 style="color: var(--accent-color); margin-bottom: 0.5rem;">💰 List an Item for Sale</h3>
                    <p style="color: var(--text-dim); font-size: 0.95rem; margin: 0;">Select an unequipped item from
                        your inventory</p>
                </div>

                <div class="inventory-grid" id="sell-inventory" style="margin-bottom: 2rem;">
                    <!-- Inventory items will be loaded here -->
                </div>

                <div class="sell-form" id="sell-form" style="display: none;">
                    <div
                        style="background: var(--panel-bg); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
                        <div id="sell-item-info" style="text-align: center; margin-bottom: 1.5rem;">
                            <!-- Selected item info -->
                        </div>

                        <div style="margin-bottom: 1.5rem;">
                            <label for="sell-price"
                                style="display: block; margin-bottom: 0.75rem; color: var(--text); font-weight: 500;">
                                Set Price: Leaves 🍃
                            </label>
                            <div class="price-input-wrapper">
                                <input type="text" id="sell-price" class="form-input" placeholder="Enter price..."
                                    inputmode="numeric" pattern="[0-9]*" maxlength="5"
                                    style="width: 200px; padding: 0.8rem; background: var(--bg); border: 1px solid var(--accent); color: var(--text); border-radius: 4px;">

                                <!-- Tax Calculation Display -->
                                <div id="sell-tax-display"
                                    style="margin-top: 0.8rem; font-size: 0.9rem; color: var(--text-dim); display: none; background: rgba(0,0,0,0.2); padding: 0.8rem; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.3rem;">
                                        <span>Market Tax (20%):</span>
                                        <span id="sell-tax-amount" style="color: var(--warning);">-0</span>
                                    </div>
                                    <div
                                        style="display: flex; justify-content: space-between; font-weight: bold; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.3rem;">
                                        <span>You Receive:</span>
                                        <span id="sell-net-profit" style="color: var(--success);">0</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div style="display: flex; gap: 1rem; justify-content: center;">
                            <button class="btn btn-secondary" onclick="showUnifiedView()"
                                style="padding: 0.8rem 1.5rem;">
                                Cancel
                            </button>
                            <button class="btn btn-success" id="confirm-sell-btn" style="padding: 0.8rem 1.5rem;">
                                <span class="btn-icon">📤</span> List for Sale
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer Actions (Mobile Friendly) -->
            <div
                style="display: flex; justify-content: space-between; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.05); gap: 1rem; flex-wrap: wrap;">
                <button class="btn btn-secondary" onclick="showUnifiedView()"
                    style="padding: 0.5rem 1rem; font-size: 0.9rem; flex: 1; max-width: 200px;">
                    ← Back to Market
                </button>
                <button class="btn btn-warning" onclick="showClaimPayments()"
                    style="padding: 0.5rem 1rem; font-size: 0.9rem; box-shadow: 0 4px 8px rgba(0,0,0,0.3); flex: 1; max-width: 200px;">
                    <span class="btn-icon">💰</span> Claim Payments
                </button>
            </div>
        </div>
    </div>

    <!-- Arena Modal -->
    <div class="modal" id="arena-modal">
        <style>
            .arena-container {
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
                max-height: calc(90vh - 120px);
            }

            .arena-stats-panel {
                background: linear-gradient(135deg, var(--accent) 0%, var(--highlight) 100%);
                padding: 1.5rem;
                border-radius: 8px;
                border: 2px solid var(--accent-color);
                flex-shrink: 0;
            }

            .arena-stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                margin-top: 1rem;
            }

            .arena-stat-item {
                text-align: center;
            }

            .arena-stat-label {
                font-size: 0.8rem;
                color: var(--text-dim);
                margin-bottom: 0.3rem;
            }

            .arena-stat-value {
                font-size: 1.5rem;
                font-weight: bold;
                color: var(--accent-color);
            }

            .arena-ladder {
                background: var(--darker-bg);
                border-radius: 8px;
                overflow-y: auto;
                flex: 1;
                min-height: 0;
            }

            .arena-ladder-header {
                display: grid;
                grid-template-columns: 60px 1fr 80px 150px 120px;
                gap: 1rem;
                padding: 0.75rem 1rem;
                background: var(--accent);
                font-weight: bold;
                font-size: 0.9rem;
                color: var(--text-dim);
                position: sticky;
                top: 0;
                z-index: 1;
            }

            .arena-ladder-row {
                display: grid;
                grid-template-columns: 60px 1fr 80px 150px 120px;
                gap: 1rem;
                padding: 0.6rem 1rem;
                border-bottom: 1px solid var(--accent);
                align-items: center;
                transition: background 0.2s;
            }

            .arena-ladder-row:hover {
                background: var(--accent);
            }

            .arena-ladder-row.player-row {
                background: rgba(255, 122, 47, 0.1);
                border-left: 3px solid var(--accent-color);
            }

            .arena-rank {
                font-weight: bold;
                font-size: 1.2rem;
                color: var(--accent-color);
                text-align: center;
            }

            .arena-name {
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .arena-rank-inline {
                display: none;
            }

            .arena-name-clickable {
                cursor: pointer;
                transition: all 0.2s;
                position: relative;
            }

            .arena-name-clickable:hover {
                color: var(--accent-color);
                text-shadow: 0 0 10px rgba(255, 122, 47, 0.3);
                transform: translateX(4px);
            }

            .arena-level {
                color: var(--text-dim);
                font-size: 0.9rem;
            }

            .arena-level-inline {
                display: none;
                color: var(--text-dim);
                font-size: 0.85rem;
            }

            .arena-stats-preview {
                font-size: 0.85rem;
                color: var(--text-dim);
                white-space: nowrap;
            }

            .arena-action {
                text-align: right;
            }

            .btn-challenge {
                padding: 0.4rem 1rem;
                font-size: 0.85rem;
                background: var(--accent-color);
                border: none;
                border-radius: 4px;
                color: white;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn-challenge:hover:not(:disabled) {
                background: var(--accent-hover);
                transform: translateY(-2px);
            }

            .btn-challenge:disabled {
                background: var(--accent);
                color: var(--text-dim);
                cursor: not-allowed;
                transform: none;
            }

            .arena-loading {
                text-align: center;
                padding: 3rem;
                color: var(--text-dim);
            }

            .arena-loading-spinner {
                width: 40px;
                height: 40px;
                border: 4px solid var(--accent);
                border-top-color: var(--accent-color);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 0 auto 1rem;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            .arena-header-left {
                display: flex;
                flex-direction: row;
                align-items: baseline;
                gap: 1.5rem;
            }

            .arena-header-left .modal-title {
                margin-bottom: 0;
                line-height: normal;
            }

            @media (max-width: 768px) {
                .arena-header-left {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 0;
                }

                .arena-header-left .modal-title {
                    margin-bottom: 0.25rem;
                    line-height: 1;
                }

                .arena-modal-content {
                    overflow-y: hidden !important;
                    display: flex !important;
                    flex-direction: column;
                }

                .arena-container {
                    display: flex;
                    flex-direction: column;
                    flex: 1;
                    overflow: hidden;
                    max-height: none;
                }

                .arena-stats-panel {
                    flex-shrink: 0;
                    overflow-x: hidden;
                    /* Prevent scrolling */
                    margin-bottom: 0.5rem;
                }

                .arena-ladder {
                    flex: 1;
                    overflow-y: auto;
                    overflow-x: hidden;
                    min-height: 0;
                }

                .arena-ladder-header {
                    display: none;
                }

                .arena-ladder-row {
                    grid-template-columns: 1fr auto;
                    grid-template-rows: auto auto;
                    gap: 0.3rem 0.5rem;
                    padding: 0.8rem;
                    align-items: center;
                }

                .arena-rank {
                    display: none;
                }

                .arena-level {
                    display: none;
                }

                .arena-name {
                    grid-column: 1 / -1;
                    grid-row: 1;
                    font-size: 0.95rem;
                    padding-bottom: 0.2rem;
                }

                .arena-rank-inline {
                    display: inline-flex;
                    font-weight: bold;
                    color: var(--accent-color);
                    margin-right: 0.3rem;
                }

                .arena-stats-preview {
                    grid-column: 1;
                    grid-row: 2;
                    white-space: nowrap;
                    font-size: 0.75rem;
                    text-align: left;
                    display: flex;
                    align-items: center;
                    color: var(--text-dim);
                }

                .mobile-level {
                    display: inline;
                    margin-right: 0.4rem;
                    color: var(--text);
                }

                .arena-action {
                    grid-column: 2;
                    grid-row: 2;
                    text-align: right;
                    width: auto;
                    align-self: center;
                    /* Vertically center in the grid row */
                }

                .btn-challenge {
                    width: auto;
                    min-width: 80px;
                    /* Increase width */
                    padding: 0.4rem 1rem;
                    /* Increase padding */
                    font-size: 0.85rem;
                }
            }

            @media (min-width: 769px) {
                .mobile-level {
                    display: none;
                }
            }
        </style>
        <div class="modal-content arena-modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1.5rem;">
                <div class="arena-header-left">
                    <h2 class="modal-title">⚔️ ARENA</h2>
                    <div style="font-size: 0.9rem; color: var(--text-dim);">Next Reset: <span
                            id="arena-reset-timer">--:--:--</span></div>
                </div>
                <div style="display: flex; gap: 1rem; align-items: center;">
                    <button class="btn-secondary" onclick="showChallengeLogs()"
                        onmouseover="this.style.background='rgba(255,255,255,0.1)'"
                        onmouseout="this.style.background='transparent'"
                        style="padding: 0.5rem 1rem; font-size: 0.9rem; background: transparent; border: 1px solid var(--text-dim); color: inherit; transition: background 0.2s; margin-right: 1.5rem;">📜
                        Challenge Logs</button>
                    <button class="close-modal" onclick="document.getElementById('arena-modal').style.display='none'"
                        style="position: static;">×</button>
                </div>
            </div>

            <div class="arena-container" id="arena-container">
                <!-- Player Stats Panel -->
                <div class="arena-stats-panel">
                    <h3 style="margin: 0 0 0.5rem 0; color: var(--text);">Your Arena Stats</h3>
                    <div class="arena-stats-grid">
                        <div class="arena-stat-item">
                            <div class="arena-stat-label">Current Rank</div>
                            <div class="arena-stat-value" id="player-arena-rank">Unranked</div>
                        </div>
                        <div class="arena-stat-item">
                            <div class="arena-stat-label">PVP Points</div>
                            <div class="arena-stat-value" id="player-pvp-points">100</div>
                        </div>
                        <div class="arena-stat-item">
                            <div class="arena-stat-label">Record</div>
                            <div class="arena-stat-value" id="player-arena-record">0W - 0L</div>
                        </div>
                    </div>
                </div>

                <!-- Arena Ladder -->
                <div class="arena-ladder">
                    <div class="arena-ladder-header">
                        <div>Rank</div>
                        <div>Name</div>
                        <div>Level</div>
                        <div>Stats</div>
                        <div>Action</div>
                    </div>
                    <div id="arena-ladder-content">
                        <div class="arena-loading">
                            <div class="arena-loading-spinner"></div>
                            <div>Loading arena...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Challenge Logs Modal -->
    <div class="modal" id="challenge-logs-modal" style="z-index: 2000;">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2 class="modal-title" style="margin-bottom: 0;">📜 Challenge Logs</h2>
                <button class="close-modal"
                    onclick="document.getElementById('challenge-logs-modal').style.display='none'"
                    style="position: static;">×</button>
            </div>
            <div id="challenge-logs-content" style="max-height: 60vh; overflow-y: auto;">
                <div style="color: var(--text-dim); text-align: center; padding: 2rem;">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Inspection Modal -->
    <div class="modal" id="inspect-modal" style="z-index: 2000;">
        <style>
            .inspect-content {
                background: var(--panel-bg);
                border: 1px solid var(--accent);
                border-radius: 8px;
                padding: 1.5rem;
                max-width: 500px;
                width: 90%;
                position: relative;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            }

            .inspect-header {
                text-align: center;
                margin-bottom: 1.5rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding-bottom: 1rem;
            }

            .inspect-name {
                font-size: 1.5rem;
                font-weight: bold;
                color: var(--accent-color);
                margin-bottom: 0.5rem;
            }

            .inspect-subtitle {
                color: var(--text-dim);
                font-size: 0.9rem;
            }

            .inspect-stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
                margin-bottom: 1.5rem;
                background: rgba(0, 0, 0, 0.2);
                padding: 1rem;
                border-radius: 6px;
            }

            .inspect-stat {
                text-align: center;
            }

            .inspect-stat-label {
                font-size: 0.75rem;
                color: var(--text-dim);
            }

            .inspect-stat-value {
                font-weight: bold;
                color: var(--text);
            }

            .inspect-gear-list {
                display: flex;
                flex-direction: column;
                gap: 0.8rem;
            }

            .inspect-gear-item {
                display: flex;
                align-items: center;
                gap: 1rem;
                background: rgba(255, 255, 255, 0.05);
                padding: 0.8rem;
                border-radius: 6px;
                border: 1px solid transparent;
            }

            .inspect-gear-icon {
                font-size: 1.5rem;
                width: 40px;
                text-align: center;
            }

            .inspect-gear-info {
                flex: 1;
            }

            .inspect-gear-name {
                font-weight: bold;
                color: var(--text);
                font-size: 0.95rem;
            }

            .inspect-gear-stats {
                font-size: 0.8rem;
                color: var(--text-dim);
            }

            .inspect-empty {
                color: var(--text-dim);
                font-style: italic;
                font-size: 0.9rem;
            }

            /* Mobile Responsiveness for Battle Log */
            @media (max-width: 768px) {
                .battle-log {
                    height: 400px;
                    /* Mobile height */
                }
            }

            @media (min-width: 769px) {
                .battle-log {
                    height: 400px;
                    /* Desktop height */
                }
            }
        </style>
        <div class="modal-content inspect-content">
            <button class="close-modal"
                onclick="document.getElementById('inspect-modal').style.display='none'">×</button>

            <div id="inspect-loading" style="text-align: center; padding: 2rem;">
                <div class="arena-loading-spinner"></div>
                <div>Fetching player data...</div>
            </div>

            <div id="inspect-data" style="display: none;">
                <div class="inspect-header">
                    <div class="inspect-name" id="inspect-name">Player Name</div>
                    <div class="inspect-subtitle" id="inspect-details">Level 40 • Bellato • Warrior</div>
                    <div class="inspect-subtitle" id="inspect-guild"
                        style="color: var(--accent-color); font-size: 0.85rem; margin-top: 0.3rem;">Guild: -</div>
                </div>

                <div class="inspect-stats-grid">
                    <div class="inspect-stat">
                        <div class="inspect-stat-label">HP</div>
                        <div class="inspect-stat-value" id="inspect-hp" style="color: var(--danger);">5000</div>
                    </div>
                    <div class="inspect-stat">
                        <div class="inspect-stat-label">Attack</div>
                        <div class="inspect-stat-value" id="inspect-atk" style="color: var(--warning);">250</div>
                    </div>
                    <div class="inspect-stat">
                        <div class="inspect-stat-label">Defense</div>
                        <div class="inspect-stat-value" id="inspect-def" style="color: var(--info);">150</div>
                    </div>
                </div>

                <h3
                    style="font-size: 0.9rem; color: var(--text-dim); margin-bottom: 0.8rem; text-transform: uppercase; letter-spacing: 1px;">
                    Equipped Gear</h3>
                <div class="inspect-gear-list" id="inspect-gear-list">
                    <!-- Gear items will be added here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Chip War Modal -->
    <div class="modal" id="chip-war-modal">
        <div class="modal-content" style="max-width: 800px;">
            <button class="close-modal"
                onclick="document.getElementById('chip-war-modal').style.display='none'">×</button>
            <h2 class="modal-title">⚔️ CHIP WAR <span id="chip-war-reset-timer"
                    style="font-size: 0.7em; color: var(--text-dim); font-weight: normal; margin-left: 0.5rem;"></span>
            </h2>

            <div
                style="margin-bottom: 1.5rem; padding: 1rem; background: var(--accent); border-radius: 6px; border-left: 3px solid var(--accent-color);">
                <div style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">Your Race: <span
                        id="player-race-display" style="color: var(--accent-color); font-weight: bold;">-</span></div>
                <div style="color: var(--text-dim); font-size: 0.85rem;">Attack enemy chips to deal damage! Each race
                    has different travel times.</div>
            </div>

            <div id="chip-list" style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Chips will be dynamically added here -->
            </div>

            <div id="active-attack-display"
                style="display: none; margin-top: 1.5rem; padding: 1rem; background: var(--darker-bg); border-radius: 6px; border: 2px solid var(--warning);">
                <div style="font-weight: bold; color: var(--warning); margin-bottom: 0.5rem;">🗡️ ATTACKING</div>
                <div id="attack-status-text" style="color: var(--text); margin-bottom: 0.5rem;">Traveling to <span
                        id="attack-target-name">-</span>...</div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: var(--text-dim); font-size: 0.9rem;">Time Remaining:</span>
                    <span id="attack-timer-display"
                        style="color: var(--accent-color); font-weight: bold; font-size: 1.1rem;">--</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="modal" id="shop-modal">
        <style>
            .shop-container {
                max-width: 1000px;
                margin: 0 auto;
                padding: 1rem;
            }

            .shop-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1.5rem;
                flex-wrap: wrap;
                gap: 1rem;
            }

            .shop-title {
                font-size: 1.5rem;
                color: var(--text);
                margin: 0;
            }

            .shop-currency-info {
                display: flex;
                gap: 1.5rem;
                flex-wrap: wrap;
            }

            .currency-item {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                background: var(--panel-bg);
                padding: 0.5rem 0.75rem;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .currency-label {
                color: var(--text-dim);
                font-size: 0.8rem;
                font-weight: 500;
            }

            .currency-value {
                font-size: 1rem;
                font-weight: bold;
            }

            .currency-value.leaves {
                color: var(--success);
            }

            .currency-value.pvp {
                color: var(--accent-color);
            }

            .currency-value.coins {
                color: #f39c12;
            }

            .shop-content {
                background: var(--panel-bg);
                border-radius: 6px;
                padding: 1rem;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .shop-items-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 1rem;
            }

            .shop-item {
                background: var(--bg);
                border-radius: 6px;
                padding: 1rem;
                border: 1px solid rgba(255, 255, 255, 0.1);
                transition: border-color 0.2s ease;
            }

            .shop-item:hover {
                border-color: var(--accent);
            }

            .shop-item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.5rem;
            }

            .shop-item-left {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .shop-item-icon {
                font-size: 1.2rem;
                width: 25px;
                text-align: center;
            }

            .shop-item-name {
                font-weight: 600;
                color: var(--text);
                font-size: 0.9rem;
            }

            .shop-item-price {
                color: var(--accent-color);
                font-size: 0.85rem;
                font-weight: 600;
            }

            .shop-item-stats {
                color: var(--text-dim);
                font-size: 0.8rem;
                margin-bottom: 0.75rem;
                text-align: left;
            }

            .shop-item-stats {
                color: var(--text-dim);
                font-size: 0.8rem;
                margin-bottom: 0.75rem;
            }

            .shop-buy-btn {
                background: var(--success);
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                font-weight: 500;
                cursor: pointer;
                width: 100%;
                transition: background-color 0.2s ease;
                font-size: 0.85rem;
            }

            .shop-buy-btn:hover:not(:disabled) {
                background: #27ae60;
            }

            .shop-buy-btn:disabled {
                cursor: not-allowed;
                opacity: 0.4;
            }

            .shop-buy-btn.leaves:disabled {
                background: rgba(39, 174, 96, 0.3);
                border: 1px solid rgba(39, 174, 96, 0.5);
            }

            .shop-buy-btn.pvp:disabled {
                background: rgba(52, 152, 219, 0.3);
                border: 1px solid rgba(52, 152, 219, 0.5);
            }

            .shop-buy-btn.coins:disabled {
                background: rgba(243, 156, 18, 0.3);
                border: 1px solid rgba(243, 156, 18, 0.5);
            }

            .shop-buy-btn.pvp {
                background: var(--accent);
            }

            .shop-buy-btn.pvp:hover:not(:disabled) {
                background: #2980b9;
            }

            .shop-buy-btn.coins {
                background: #f39c12;
            }

            .shop-buy-btn.coins:hover:not(:disabled) {
                background: #e67e22;
            }

            /* Shop Tabs */
            .shop-tabs {
                display: flex;
                gap: 0.5rem;
                margin-bottom: 1.5rem;
                border-bottom: 2px solid var(--accent);
                padding-bottom: 0;
            }

            .shop-tab {
                padding: 0.8rem 1.5rem;
                background: transparent;
                border: none;
                color: var(--text-dim);
                cursor: pointer;
                font-size: 0.95rem;
                font-weight: bold;
                transition: all 0.2s;
                border-bottom: 3px solid transparent;
                margin-bottom: -2px;
            }

            .shop-tab:hover {
                color: var(--text);
                background: rgba(255, 255, 255, 0.05);
            }

            .shop-tab.active {
                color: var(--accent-color);
                border-bottom-color: var(--accent-color);
            }

            .shop-tab.leaves-tab.active {
                color: var(--success);
                border-bottom-color: var(--success);
            }

            .shop-tab.pvp-tab.active {
                color: #3498db;
                border-bottom-color: #3498db;
            }

            .shop-tab.coins-tab.active {
                color: #f39c12;
                border-bottom-color: #f39c12;
            }
        </style>
        <div class="modal-content" style="max-width: 1300px;">
            <button class="close-modal" onclick="document.getElementById('shop-modal').style.display='none'"
                style="top: 1.5rem; right: 1.5rem;">×</button>

            <div class="shop-container">
                <!-- Header with title and currencies -->
                <div class="shop-header">
                    <h2 class="shop-title">🏪 Shop</h2>
                    <div class="shop-currency-info">
                        <div class="currency-item">
                            <div class="currency-label">🍃 Leaves:</div>
                            <div class="currency-value leaves" id="shop-leaves">0</div>
                        </div>
                        <div class="currency-item">
                            <div class="currency-label">⚔️ PVP:</div>
                            <div class="currency-value pvp" id="shop-pvp-points">100</div>
                        </div>
                        <div class="currency-item">
                            <div class="currency-label">🪙 Coins:</div>
                            <div class="currency-value coins" id="shop-coins">0</div>
                        </div>
                    </div>
                </div>

                <!-- Shop Tabs -->
                <div class="shop-tabs">
                    <button class="shop-tab leaves-tab active" onclick="switchShopTab('leaves')">🍃 Leaves Shop</button>
                    <button class="shop-tab pvp-tab" onclick="switchShopTab('pvp')">⚔️ PVP Shop</button>
                    <button class="shop-tab coins-tab" onclick="switchShopTab('coins')">🪙 Coin Shop</button>
                </div>

                <!-- Shop Content -->
                <div class="shop-content">
                    <div class="shop-items-grid" id="shop-items-container">
                        <!-- Items will be loaded here based on selected tab -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Guild Modal -->
    <div class="modal" id="guild-modal">
        <style>
            .guild-container {
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
                max-height: calc(90vh - 120px);
            }

            .guild-header {
                text-align: center;
                margin-bottom: 1rem;
            }

            .guild-title {
                font-size: 1.5rem;
                color: var(--accent-color);
                margin: 0;
            }

            .guild-subtitle {
                color: var(--text-dim);
                font-size: 0.9rem;
                margin-top: 0.5rem;
            }

            .guild-menu {
                display: flex;
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }

            .guild-menu-btn {
                background: linear-gradient(135deg, var(--accent) 0%, var(--highlight) 100%);
                border: 2px solid rgba(255, 122, 47, 0.3);
                border-radius: 8px;
                padding: 1.5rem;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .guild-menu-btn:hover {
                border-color: var(--accent-color);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 122, 47, 0.3);
            }

            .guild-menu-btn .icon {
                font-size: 2rem;
                margin-bottom: 0.5rem;
            }

            .guild-menu-btn .title {
                font-size: 1.2rem;
                font-weight: bold;
                color: var(--accent-color);
                margin-bottom: 0.3rem;
            }

            .guild-menu-btn .description {
                font-size: 0.85rem;
                color: var(--text-dim);
            }

            .guild-menu-btn .cost {
                margin-top: 0.5rem;
                font-size: 0.9rem;
                color: var(--warning);
            }

            .guild-form {
                display: none;
                padding: 1rem;
            }

            .guild-form.active {
                display: block;
            }

            .guild-input-group {
                margin-bottom: 1rem;
            }

            .guild-input-group label {
                display: block;
                color: var(--text-dim);
                font-size: 0.9rem;
                margin-bottom: 0.5rem;
            }

            .guild-input {
                width: 100%;
                padding: 0.8rem;
                background: var(--darker-bg);
                border: 1px solid var(--accent);
                border-radius: 6px;
                color: var(--text);
                font-size: 1rem;
            }

            .guild-input:focus {
                outline: none;
                border-color: var(--accent-color);
            }

            .guild-list {
                max-height: 400px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            .guild-list-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: var(--accent);
                padding: 1rem;
                border-radius: 6px;
                transition: background 0.2s;
            }

            .guild-list-item:hover {
                background: var(--highlight);
            }

            .guild-list-info {
                flex: 1;
            }

            .guild-list-name {
                font-weight: bold;
                color: var(--text);
                font-size: 1rem;
            }

            .guild-list-leader {
                font-size: 0.85rem;
                color: var(--text-dim);
            }

            .guild-list-members {
                font-size: 0.85rem;
                color: var(--accent-color);
            }

            .btn-join-guild {
                padding: 0.5rem 1rem;
                background: var(--success);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                transition: all 0.2s;
            }

            .btn-join-guild:hover {
                background: #6aff9a;
                transform: translateY(-1px);
            }

            /* Guild View (when in a guild) */
            .guild-view {
                display: none;
            }

            .guild-view.active {
                display: block;
            }

            .guild-info-panel {
                background: linear-gradient(135deg, var(--accent) 0%, var(--highlight) 100%);
                padding: 1.5rem;
                border-radius: 8px;
                border: 2px solid var(--accent-color);
                margin-top: 1rem;
                margin-bottom: 1.5rem;
                text-align: center;
            }

            .guild-name-display {
                font-size: 1.8rem;
                font-weight: bold;
                color: var(--accent-color);
                margin-bottom: 0.5rem;
            }

            .guild-bonus {
                font-size: 0.9rem;
                color: var(--success);
                margin-top: 0.5rem;
            }

            .guild-members-section {
                background: var(--darker-bg);
                border-radius: 8px;
                padding: 1rem;
            }

            .guild-members-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid var(--accent);
                margin-bottom: 1rem;
            }

            .guild-members-title {
                font-size: 1rem;
                color: var(--text-dim);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .guild-member-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.6rem 0.8rem;
                border-radius: 4px;
                transition: background 0.2s;
            }

            .guild-member-item:nth-child(even) {
                background: rgba(255, 255, 255, 0.03);
            }

            .guild-member-name {
                color: var(--text);
                font-size: 0.95rem;
            }

            .guild-member-role {
                font-size: 0.8rem;
                padding: 0.2rem 0.5rem;
                border-radius: 3px;
                font-weight: bold;
            }

            .guild-member-role.leader {
                background: var(--accent-color);
                color: white;
            }

            .guild-member-role.member {
                background: #2980b9;
                color: white;
            }

            .btn-leave-guild {
                padding: 0.6rem 1.2rem;
                background: var(--danger);
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85rem;
                transition: all 0.2s;
            }

            .btn-leave-guild:hover {
                background: #e93838;
                transform: translateY(-1px);
            }

            .btn-disband-guild {
                padding: 0.6rem 1.2rem;
                background: #e70000;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85rem;
                transition: all 0.2s;
            }

            .btn-disband-guild:hover {
                background: #c00000;
                transform: translateY(-1px);
            }

            .guild-action-footer {
                display: flex;
                justify-content: flex-end;
                margin-top: 1.5rem;
                padding-top: 1rem;
                border-top: 1px solid var(--accent);
            }

            .guild-empty {
                text-align: center;
                padding: 2rem;
                color: var(--text-dim);
                font-style: italic;
            }

            .guild-back-btn {
                margin-bottom: 1rem;
                padding: 0.5rem 1rem;
                background: var(--accent);
                color: var(--text);
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .guild-back-btn:hover {
                background: var(--highlight);
            }

            .guild-action-buttons {
                display: flex;
                gap: 1rem;
                margin-top: 1rem;
            }

            @media (max-width: 768px) {
                .guild-menu {
                    gap: 0.8rem;
                }

                .guild-menu-btn {
                    padding: 1rem;
                }

                .guild-menu-btn .icon {
                    font-size: 1.5rem;
                }
            }
        </style>
        <div class="modal-content" style="max-width: 600px;">
            <button class="close-modal" onclick="document.getElementById('guild-modal').style.display='none'">×</button>

            <!-- Guild Menu (for players not in a guild) -->
            <div id="guild-menu-view" class="guild-menu-container">
                <div class="guild-header">
                    <h2 class="guild-title">🏰 Guild</h2>
                    <p class="guild-subtitle">Join forces with other players!</p>
                </div>

                <div class="guild-menu">
                    <div class="guild-menu-btn" onclick="showCreateGuildForm()">
                        <div class="icon">⚔️</div>
                        <div class="title">Create Guild</div>
                        <div class="description">Start your own guild and become the leader!</div>
                        <div class="cost">💰 Cost: 1,000 Leaves</div>
                    </div>

                    <div class="guild-menu-btn" onclick="showJoinGuildList()">
                        <div class="icon">🤝</div>
                        <div class="title">Join Guild</div>
                        <div class="description">Browse and join an existing guild</div>
                    </div>
                </div>
            </div>

            <!-- Create Guild Form -->
            <div id="guild-create-view" class="guild-form">
                <button class="guild-back-btn" onclick="showGuildMenu()">← Back</button>
                <div class="guild-header">
                    <h2 class="guild-title">⚔️ Create Guild</h2>
                    <p class="guild-subtitle">Cost: 1,000 Leaves</p>
                </div>

                <div class="guild-input-group">
                    <label for="guild-name-input">Guild Name (letters & numbers only)</label>
                    <input type="text" id="guild-name-input" class="guild-input" placeholder="Enter guild name..."
                        maxlength="10" pattern="[A-Za-z0-9]+">
                </div>

                <div class="guild-action-buttons">
                    <button class="btn btn-secondary" onclick="showGuildMenu()">Cancel</button>
                    <button class="btn" onclick="createGuild()">Create Guild</button>
                </div>
            </div>

            <!-- Join Guild List -->
            <div id="guild-join-view" class="guild-form">
                <button class="guild-back-btn" onclick="showGuildMenu()">← Back</button>
                <div class="guild-header">
                    <h2 class="guild-title">🤝 Join Guild</h2>
                    <p class="guild-subtitle">Select a guild to join</p>
                </div>

                <div class="guild-list" id="guild-list">
                    <div class="guild-empty">Loading guilds...</div>
                </div>
            </div>

            <!-- Guild View (when in a guild) -->
            <div id="guild-detail-view" class="guild-view">
                <div class="guild-info-panel">
                    <div class="guild-name-display" id="guild-name-display">Guild Name</div>
                    <div class="guild-bonus">✨ Guild Bonus: +5 ATK, +5 DEF</div>
                </div>

                <div class="guild-members-section">
                    <div class="guild-members-header">
                        <span class="guild-members-title">Members</span>
                        <span id="guild-member-count" style="color: var(--text-dim);">0/10</span>
                    </div>
                    <div id="guild-members-list">
                        <!-- Members will be loaded here -->
                    </div>
                </div>

                <!-- Action Footer -->
                <div class="guild-action-footer">
                    <!-- Leave Guild button (for members) -->
                    <button class="btn-leave-guild" id="btn-leave-guild" onclick="leaveGuild()"
                        style="display: none;">🚪 Leave Guild</button>

                    <!-- Disband Guild button (for leaders) -->
                    <button class="btn-disband-guild" id="btn-disband-guild" onclick="disbandGuild()"
                        style="display: none;">💥 Disband Guild</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Rankings Modal -->
    <div class="modal" id="rankings-modal">
        <style>
            .rankings-content {
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .rankings-tabs {
                display: flex;
                gap: 0.5rem;
                margin-bottom: 1.5rem;
                border-bottom: 2px solid var(--accent);
                padding-bottom: 0;
            }

            .rankings-tab {
                padding: 0.8rem 1.5rem;
                background: transparent;
                border: none;
                color: var(--text-dim);
                cursor: pointer;
                font-size: 0.95rem;
                font-weight: bold;
                transition: all 0.2s;
                border-bottom: 3px solid transparent;
                margin-bottom: -2px;
            }

            .rankings-tab:hover {
                color: var(--text);
                background: rgba(255, 255, 255, 0.05);
            }

            .rankings-tab.active {
                color: var(--accent-color);
                border-bottom-color: var(--accent-color);
            }

            .rankings-list {
                flex: 1;
                overflow-y: auto;
                max-height: 55vh;
            }

            .rankings-row {
                display: grid;
                grid-template-columns: 50px 1fr auto;
                gap: 1rem;
                padding: 0.8rem 1rem;
                border-radius: 6px;
                transition: background 0.2s;
                align-items: center;
            }

            .rankings-row:nth-child(odd) {
                background: rgba(255, 255, 255, 0.02);
            }

            .rankings-row:hover {
                background: rgba(255, 255, 255, 0.05);
            }

            .rankings-row.top-1 {
                background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), transparent);
                border-left: 3px solid gold;
            }

            .rankings-row.top-2 {
                background: linear-gradient(90deg, rgba(192, 192, 192, 0.15), transparent);
                border-left: 3px solid silver;
            }

            .rankings-row.top-3 {
                background: linear-gradient(90deg, rgba(205, 127, 50, 0.15), transparent);
                border-left: 3px solid #cd7f32;
            }

            .rankings-rank {
                font-weight: bold;
                font-size: 1.1rem;
                color: var(--accent-color);
            }

            .rankings-name {
                font-weight: 500;
                color: var(--text);
            }

            .rankings-name .race-class {
                font-size: 0.8rem;
                color: var(--text-dim);
                margin-left: 0.5rem;
            }

            .rankings-value {
                font-weight: bold;
                color: var(--success);
                text-align: right;
            }

            .rankings-guild-row {
                display: grid;
                grid-template-columns: 50px 1fr auto auto;
                gap: 1rem;
                padding: 0.8rem 1rem;
                border-radius: 6px;
                transition: background 0.2s;
                align-items: center;
            }

            .rankings-guild-row:nth-child(odd) {
                background: rgba(255, 255, 255, 0.02);
            }

            .rankings-guild-row:hover {
                background: rgba(255, 255, 255, 0.05);
            }

            .guild-leader-name {
                font-size: 0.85rem;
                color: var(--text-dim);
            }

            .guild-member-count {
                font-size: 0.9rem;
                color: var(--accent-color);
            }

            .rankings-empty {
                text-align: center;
                padding: 3rem;
                color: var(--text-dim);
                font-style: italic;
            }

            .rankings-loading {
                text-align: center;
                padding: 3rem;
                color: var(--text-dim);
            }
        </style>
        <div class="modal-content rankings-content">
            <button class="close-modal"
                onclick="document.getElementById('rankings-modal').style.display='none'">×</button>
            <h2 class="modal-title" style="margin-bottom: 1rem;">🏆 RANKINGS</h2>

            <div class="rankings-tabs">
                <button class="rankings-tab active" onclick="switchRankingsTab('level')">Top Level</button>
                <button class="rankings-tab" onclick="switchRankingsTab('leaves')">Leaves</button>
                <button class="rankings-tab" onclick="switchRankingsTab('pvp')">PVP Points</button>
                <button class="rankings-tab" onclick="switchRankingsTab('guilds')">Guilds</button>
            </div>

            <div class="rankings-list" id="rankings-list">
                <div class="rankings-loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div class="upgrade-modal" id="upgrade-modal">
        <div class="upgrade-content">
            <h2 class="upgrade-title">WEAPON UPGRADING</h2>
            <div class="upgrade-item" id="upgrade-item-info">
                <!-- Upgrade info will be dynamically added here -->
            </div>
            <div class="upgrade-result" id="upgrade-result" style="display: none;"></div>
            <div class="action-buttons">
                <button class="btn" id="upgrade-confirm-btn">Upgrade</button>
                <button class="btn btn-secondary" id="upgrade-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Crafting Modal -->
    <div class="crafting-modal" id="crafting-modal">
        <div class="crafting-content">
            <h2 class="modal-title">CRAFTING</h2>

            <!-- Craft Category Tabs -->
            <div class="craft-tabs">
                <button class="craft-tab active" data-category="sword">🗡️</button>
                <button class="craft-tab" data-category="staff">🪄</button>
                <button class="craft-tab" data-category="bow">🏹</button>
                <button class="craft-tab" data-category="launcher">🚀</button>
                <button class="craft-tab" data-category="armor">🧥</button>
                <button class="craft-tab" data-category="accessories">💍</button>
            </div>

            <div class="recipe-list" id="recipe-list">
                <!-- Recipes will be dynamically added here -->
            </div>
            <div class="action-buttons">
                <button class="btn" id="craft-confirm-btn" disabled>Craft</button>
                <button class="btn btn-secondary" id="craft-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>


    <!-- Mobile Tabs Script -->
    <script>
        (function () {
            const tabContainer = document.getElementById('mobile-tabs');
            if (!tabContainer) return;

            const buttons = Array.from(tabContainer.querySelectorAll('.mobile-tab-btn'));
            const panels = {
                character: document.getElementById('panel-character'),
                battle: document.getElementById('panel-battle'),
                inventory: document.getElementById('panel-inventory')
            };

            const mediaQuery = window.matchMedia('(max-width: 720px)');
            let activeTab = 'character';

            function setActiveTab(tabName) {
                activeTab = tabName;
                const isMobile = mediaQuery.matches;

                buttons.forEach(button => {
                    button.classList.toggle('active', isMobile && button.dataset.tab === tabName);
                });

                Object.entries(panels).forEach(([name, panel]) => {
                    if (!panel) return;
                    panel.classList.toggle('active-mobile', isMobile && name === tabName);
                });
            }

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    if (!mediaQuery.matches) return;
                    setActiveTab(button.dataset.tab);
                });
            });

            function handleViewportChange() {
                if (mediaQuery.matches) {
                    setActiveTab(activeTab);
                } else {
                    buttons.forEach(button => button.classList.remove('active'));
                    Object.values(panels).forEach(panel => panel?.classList.remove('active-mobile'));
                }
            }

            handleViewportChange();

            if (mediaQuery.addEventListener) {
                mediaQuery.addEventListener('change', handleViewportChange);
            } else if (mediaQuery.addListener) {
                mediaQuery.addListener(handleViewportChange);
            }
        })();
    </script>

    <!-- Firebase SDK -->
    <script type="module">
        // Force Clear Function (must be global for onclick)
        window.forceClearAndReload = function () {
            console.log('🧹 FORCE CLEAR: Clearing all browser data...');

            // Clear all storage
            localStorage.clear();
            sessionStorage.clear();


            // Redirect to index.html
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1000);
        };

        // Show Force Clear button after 3 seconds if still loading
        setTimeout(() => {
            const forceClearBtn = document.getElementById('force-clear-btn');
            if (forceClearBtn && forceClearBtn.style.display !== 'block') {
                forceClearBtn.style.display = 'block';
            }
        }, 3000);

        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getDatabase, ref, set, get, child, update, onValue, onDisconnect, push, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBSmstVBMny75LIw8U8fde6Obz4nZgqTQk",
            authDomain: "idle-crusade-1900b.firebaseapp.com",
            databaseURL: "https://idle-crusade-1900b-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "idle-crusade-1900b",
            storageBucket: "idle-crusade-1900b.firebasestorage.app",
            messagingSenderId: "1026876043394",
            appId: "1:1026876043394:web:ee18a7b584b8359375849b",
            measurementId: "G-P16TS8H0R0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // Expose Firebase functions to global scope for other scripts
        window.getDatabase = getDatabase;
        window.ref = ref;
        window.set = set;
        window.get = get;
        window.child = child;
        window.update = update;
        window.onValue = onValue;
        window.onDisconnect = onDisconnect;
        window.push = push;
        window.serverTimestamp = serverTimestamp;
        window.db = db; // Expose the database instance too

        // Firebase presence system with public access
        console.log('Firebase presence system initializing...');

        // Function to update user's online presence and map
        window.updateUserPresence = function (user, currentMap) {
            console.log('updateUserPresence called with user:', user, 'map:', currentMap);

            if (!user) {
                console.log('updateUserPresence: no user provided');
                return;
            }

            if (!user.uid) {
                console.log('updateUserPresence: user has no uid');
                return;
            }

            try {
                console.log('Setting presence for user', user.uid, 'on map', currentMap);

                // Read current presence data, merge with our data, write back
                const presenceRef = ref(db, 'publicPresence');

                // First read current data
                get(presenceRef).then((snapshot) => {
                    const currentPresence = snapshot.val() || {};
                    console.log('Current Firebase presence:', currentPresence);

                    // Merge our presence data
                    const updatedPresence = {
                        ...currentPresence,
                        [user.uid]: {
                            uid: user.uid,
                            map: currentMap,
                            lastSeen: serverTimestamp(),
                            online: true,
                            characterName: gameState.character?.name || 'Unknown'
                        }
                    };

                    console.log('Writing merged presence data:', updatedPresence);

                    // Write the merged data back
                    set(presenceRef, updatedPresence).then(() => {
                        console.log('✅ Presence set successfully in Firebase for user', user.uid, 'on map', currentMap);
                    }).catch((writeError) => {
                        console.error('❌ Firebase presence write failed:', writeError);
                        // Fallback to localStorage
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        allPresence[user.uid] = updatedPresence[user.uid];
                        localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        console.log('📦 Fallback: Presence set in localStorage');
                    });

                }).catch((readError) => {
                    console.error('❌ Firebase presence read failed:', readError);
                    // Fallback: just write our own data
                    const presenceData = {
                        [user.uid]: {
                            uid: user.uid,
                            map: currentMap,
                            lastSeen: serverTimestamp(),
                            online: true,
                            characterName: gameState.character?.name || 'Unknown'
                        }
                    };

                    set(presenceRef, presenceData).then(() => {
                        console.log('✅ Presence set (new) in Firebase for user', user.uid);
                    }).catch((error) => {
                        console.error('❌ Firebase presence write failed:', error);
                        // Fallback to localStorage
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        allPresence[user.uid] = presenceData[user.uid];
                        localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        console.log('📦 Fallback: Presence set in localStorage');
                    });
                });

            } catch (error) {
                console.error('💥 Exception in updateUserPresence for user', user.uid, ':', error);
                // Fallback to localStorage
                const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                allPresence[user.uid] = {
                    uid: user.uid,
                    map: currentMap,
                    lastSeen: Date.now(),
                    online: true,
                    characterName: gameState.character?.name || 'Unknown'
                };
                localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                console.log('📦 Exception fallback: Presence set in localStorage for user', user.uid);
            }
        };

        // Function to get online players count for a specific map
        window.getOnlinePlayersCount = function (mapName) {
            return new Promise((resolve) => {
                try {
                    // Try Firebase first
                    const presenceRef = ref(db, 'publicPresence');
                    const unsubscribe = onValue(presenceRef, (snapshot) => {
                        try {
                            const allPresence = snapshot.val() || {};
                            console.log('Firebase presence data:', allPresence);
                            console.log('Current user:', window.currentUser?.uid);
                            console.log('Looking for map:', mapName);

                            // Count all online players on this map
                            const playersOnMap = Object.values(allPresence).filter(player => {
                                const matches = player && player.online && player.map === mapName;
                                console.log('Player', player?.uid, 'on map', player?.map, 'online:', player?.online, 'matches:', matches);
                                return matches;
                            });

                            const count = playersOnMap.length;
                            console.log('Firebase count for', mapName, ':', count, 'players found:', playersOnMap.map(p => p.uid));
                            resolve(count || 1); // At least 1 (yourself)

                            // Clean up listener after first read
                            unsubscribe();
                        } catch (error) {
                            console.error('Error processing Firebase presence data:', error);
                            unsubscribe();
                            fallbackToLocalStorage();
                        }
                    }, (error) => {
                        console.log('Firebase read failed, using localStorage fallback:', error.message);
                        fallbackToLocalStorage();
                    });

                    function fallbackToLocalStorage() {
                        try {
                            const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                            console.log('localStorage fallback data:', allPresence);

                            // Count all online players on this map
                            const playersOnMap = Object.values(allPresence).filter(player =>
                                player && player.online && player.map === mapName
                            );

                            const count = playersOnMap.length;
                            console.log('localStorage count for', mapName, ':', count);
                            resolve(count || 1);
                        } catch (error) {
                            console.error('localStorage fallback failed:', error);
                            resolve(1);
                        }
                    }
                } catch (error) {
                    console.error('Error in getOnlinePlayersCount:', error);
                    resolve(1);
                }
            });
        };

        // Debug function to check Firebase presence data
        window.debugPresence = function () {
            console.log('=== DEBUG PRESENCE ===');
            console.log('Current user:', window.currentUser?.uid);
            console.log('Current map:', gameState.currentMap);

            // Check localStorage
            const localData = JSON.parse(localStorage.getItem('playerPresence') || '{}');
            console.log('localStorage presence:', localData);

            // Check Firebase
            const presenceRef = ref(db, 'publicPresence');
            onValue(presenceRef, (snapshot) => {
                const firebaseData = snapshot.val() || {};
                console.log('Firebase presence data:', firebaseData);

                // Count players on current map
                const playersOnMap = Object.values(firebaseData).filter(player =>
                    player && player.online && player.map === gameState.currentMap
                );
                console.log('Players on', gameState.currentMap, ':', playersOnMap.length, playersOnMap.map(p => p.uid));
            }, { onlyOnce: true });
        };

        // Debug function to force refresh all presence
        window.forcePresenceUpdate = function () {
            console.log('=== FORCE PRESENCE UPDATE ===');
            if (window.currentUser) {
                updateUserPresence(window.currentUser, gameState.currentMap);
            }
            setTimeout(() => debugPresence(), 2000);
        };

        // Function to listen for real-time player count updates on current map
        window.listenForMapPlayerUpdates = function (mapName, callback) {
            try {
                // Try Firebase real-time listener first
                const presenceRef = ref(db, 'publicPresence');
                const unsubscribe = onValue(presenceRef, (snapshot) => {
                    try {
                        const allPresence = snapshot.val() || {};
                        console.log('Firebase real-time presence data:', allPresence);

                        // Count all online players on this map
                        const playersOnMap = Object.values(allPresence).filter(player =>
                            player && player.online && player.map === mapName
                        );

                        const count = playersOnMap.length;
                        console.log('Firebase real-time count for', mapName, ':', count);
                        callback(count || 1);
                    } catch (error) {
                        console.error('Error processing Firebase real-time data:', error);
                        callback(1);
                    }
                });

                // Return unsubscribe function
                return unsubscribe;

            } catch (firebaseError) {
                console.log('Firebase real-time failed, using localStorage polling:', firebaseError.message);

                // Fallback to localStorage polling
                const updateCount = () => {
                    try {
                        const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                        const playersOnMap = Object.values(allPresence).filter(player =>
                            player && player.online && player.map === mapName
                        );
                        const count = playersOnMap.length;
                        callback(count || 1);
                    } catch (error) {
                        console.error('Error in localStorage polling:', error);
                        callback(1);
                    }
                };

                // Initial call
                updateCount();

                // Set up periodic checks every 5 seconds
                const intervalId = setInterval(updateCount, 5000);

                // Return cleanup function
                return () => clearInterval(intervalId);
            }
        };

        // Failsafe: Hide loading screen after 8 seconds if something goes wrong
        setTimeout(() => {
            const loadingScreen = document.getElementById('auth-loading');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                console.warn('Authentication check timed out. Hiding loading screen.');
                loadingScreen.style.display = 'none';
            }
        }, 8000);

        // Save to Firebase - ORGANIZED STRUCTURE (User's Preferred Order)
        window.saveToFirebase = function (user, data) {
            if (!user) return;

            // Helper function to calculate lifesteal from equipped weapon
            const getLifesteal = () => {
                const weapon = data.character?.equipped?.weapon;
                if (weapon?.lifesteal) {
                    return {
                        chance: weapon.lifesteal.chance || 0,
                        multiplier: weapon.lifesteal.multiplier || 0
                    };
                }
                return { chance: 0, multiplier: 0 };
            };

            // Helper function to calculate damage reduction from equipped armor
            const getDamageReduction = () => {
                const armor = data.character?.equipped?.armor;
                return armor?.damageReduction || 0;
            };

            // CONFLICT DETECTION: Check if cloud data is newer before saving
            const localSaveTime = data.lastSaveTime || Date.now();
            const metadataRef = ref(db, `users/${user.uid}/metadata`);

            get(metadataRef).then((snapshot) => {
                const cloudMetadata = snapshot.val();
                const cloudSaveTime = cloudMetadata?.lastSaveTime || 0;

                // If cloud data is newer than local data, abort save to prevent data loss
                if (cloudSaveTime > localSaveTime) {
                    console.warn('⚠️ CONFLICT DETECTED: Cloud data is newer than local data.');
                    console.warn(`   Cloud timestamp: ${new Date(cloudSaveTime).toISOString()}`);
                    console.warn(`   Local timestamp: ${new Date(localSaveTime).toISOString()}`);
                    console.warn('   ❌ Save aborted to prevent overwriting newer data.');
                    return; // Abort save
                }

                // Organize data into logical categories (User's preferred order)
                const organizedData = {
                    profile: {
                        name: data.character?.name || '',
                        race: data.character?.race || '',
                        gender: data.character?.gender || '',
                        class: data.character?.class || '',
                        location: data.currentMap || data.character?.location || 'HQ'
                    },
                    currency: {
                        leaves: data.currency || 0,
                        coins: data.coins || 0
                    },
                    inventory: {
                        items: data.inventory || [],
                        materials: data.materials || []
                    },
                    stats: {
                        level: data.character?.level || 1,
                        exp: data.character?.exp || 0,
                        maxExp: data.character?.maxExp || 100,
                        hp: data.character?.hp || 100,
                        maxHp: data.character?.maxHp || 100,
                        fp: data.character?.fp || 100,
                        maxFp: data.character?.maxFp || 100,
                        attack: data.character?.attack || 10,
                        defense: data.character?.defense || 5,
                        criticalChance: data.character?.criticalChance || 0.05,
                        lifesteal: getLifesteal(),
                        damageReduction: getDamageReduction()
                    },
                    equipment: {
                        weapon: data.character?.equipped?.weapon || null,
                        armor: data.character?.equipped?.armor || null,
                        accessory1: data.character?.equipped?.accessory1 || null,
                        accessory2: data.character?.equipped?.accessory2 || null,
                        wings: data.character?.equipped?.wings || null
                    },
                    progression: {
                        currentMap: data.currentMap || 'HQ',
                        bosses: data.bosses || {}
                    },
                    exploration: {
                        isExploring: data.isExploring || false,
                        startTime: data.exploreStartTime || null,
                        duration: data.exploreDuration || 0,
                        area: data.exploreArea || null,
                        isTraveling: data.isTraveling || false
                    },
                    settings: {
                        autoPotion: data.autoPotion || false
                    },
                    guild: data.guild || null,
                    metadata: {
                        lastSaveTime: Date.now(),
                        version: '2.1' // Updated version with user's preferred structure
                    }
                };

                // Save each category separately (in user's preferred order)
                const updates = {};
                updates[`users/${user.uid}/profile`] = organizedData.profile;
                updates[`users/${user.uid}/currency`] = organizedData.currency;
                updates[`users/${user.uid}/inventory`] = organizedData.inventory;
                updates[`users/${user.uid}/stats`] = organizedData.stats;
                updates[`users/${user.uid}/equipment`] = organizedData.equipment;
                updates[`users/${user.uid}/progression`] = organizedData.progression;
                updates[`users/${user.uid}/exploration`] = organizedData.exploration;
                updates[`users/${user.uid}/settings`] = organizedData.settings;
                updates[`users/${user.uid}/guild`] = organizedData.guild;
                updates[`users/${user.uid}/metadata`] = organizedData.metadata;

                // Use update() to save all categories atomically
                update(ref(db), updates)
                    .then(() => {
                        console.log('✅ Data saved to Firebase (Organized Structure v2.1)');
                    })
                    .catch((error) => {
                        console.error('❌ Error saving to Firebase:', error);
                    });
            }).catch((error) => {
                console.error('❌ Error checking cloud timestamp:', error);
                // If we can't check the timestamp, proceed with save (fail-safe)
                console.warn('⚠️ Proceeding with save despite timestamp check failure.');
            });
        };

        // Load from Firebase - SUPPORTS OLD & NEW STRUCTURE
        window.loadFromFirebase = function (user) {
            return new Promise((resolve, reject) => {
                if (!user) {
                    reject('No user provided');
                    return;
                }

                const dbRef = ref(db);

                // First, try to load from NEW organized structure
                get(child(dbRef, `users/${user.uid}/metadata`)).then((metadataSnapshot) => {
                    const version = metadataSnapshot.exists() ? metadataSnapshot.val().version : null;
                    if (version === '2.0' || version === '2.1') {
                        // NEW STRUCTURE EXISTS - Load from organized structure
                        console.log(`📦 Loading from organized structure (v${version})...`);

                        Promise.all([
                            get(child(dbRef, `users/${user.uid}/profile`)),
                            get(child(dbRef, `users/${user.uid}/stats`)),
                            get(child(dbRef, `users/${user.uid}/equipment`)),
                            get(child(dbRef, `users/${user.uid}/inventory`)),
                            get(child(dbRef, `users/${user.uid}/currency`)),
                            get(child(dbRef, `users/${user.uid}/progression`)),
                            get(child(dbRef, `users/${user.uid}/exploration`)),
                            get(child(dbRef, `users/${user.uid}/settings`)),
                            get(child(dbRef, `users/${user.uid}/guild`))
                        ]).then(([profile, stats, equipment, inventory, currency, progression, exploration, settings, guild]) => {
                            // Reconstruct the game data from organized structure
                            const profileData = profile.val() || {};
                            const statsData = stats.val() || {};
                            const equipmentData = equipment.val() || {};
                            const inventoryData = inventory.val() || {};
                            const currencyData = currency.val() || {};
                            const progressionData = progression.val() || {};
                            const explorationData = exploration.val() || {};
                            const settingsData = settings.val() || {};
                            const guildData = guild.val() || null;

                            const reconstructedData = {
                                character: {
                                    name: profileData.name,
                                    race: profileData.race,
                                    gender: profileData.gender,
                                    class: profileData.class,
                                    location: profileData.location,
                                    level: statsData.level,
                                    hp: statsData.hp,
                                    maxHp: statsData.maxHp,
                                    fp: statsData.fp,
                                    maxFp: statsData.maxFp,
                                    attack: statsData.attack,
                                    defense: statsData.defense,
                                    exp: statsData.exp,
                                    maxExp: statsData.maxExp,
                                    criticalChance: statsData.criticalChance,
                                    equipped: {
                                        weapon: equipmentData.weapon,
                                        armor: equipmentData.armor,
                                        accessory1: equipmentData.accessory1,
                                        accessory2: equipmentData.accessory2,
                                        wings: equipmentData.wings
                                    }
                                },
                                inventory: inventoryData.items || [],
                                materials: inventoryData.materials || [],
                                currency: currencyData.leaves || 0,
                                coins: currencyData.coins || 0,
                                currentMap: progressionData.currentMap || 'HQ',
                                bosses: progressionData.bosses || {},
                                isExploring: explorationData.isExploring || false,
                                exploreStartTime: explorationData.startTime || null,
                                exploreDuration: explorationData.duration || 0,
                                exploreArea: explorationData.area || null,
                                autoPotion: settingsData.autoPotion || false,
                                guild: guildData
                            };

                            localStorage.setItem('rfOnlineGame', JSON.stringify(reconstructedData));

                            // Verify localStorage was set successfully
                            const verifyData = localStorage.getItem('rfOnlineGame');
                            if (verifyData) {
                                console.log('✅ Data loaded from NEW organized structure and saved to localStorage');
                            } else {
                                console.error('❌ Failed to save data to localStorage');
                            }

                            sessionStorage.removeItem('firebaseReloadCount');

                            // Small delay to ensure localStorage is fully written
                            setTimeout(() => {
                                resolve(); // Resolve promise when loading is complete
                            }, 100);
                        }).catch((error) => {
                            console.error('❌ Error loading organized structure:', error);
                            const loadingScreen = document.getElementById('auth-loading');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            reject(error);
                        });
                    } else {
                        // Try to load from OLD flat structure
                        console.log('🔍 Checking for OLD structure...');
                        get(child(dbRef, `users/${user.uid}/character`)).then((snapshot) => {
                            if (snapshot.exists()) {
                                console.log('📦 OLD structure detected! Migrating to NEW structure...');
                                const oldData = snapshot.val();

                                // Save to localStorage
                                localStorage.setItem('rfOnlineGame', JSON.stringify(oldData));

                                // Verify localStorage was set successfully
                                const verifyData = localStorage.getItem('rfOnlineGame');
                                if (verifyData) {
                                    console.log('✅ OLD structure migrated and saved to localStorage');
                                } else {
                                    console.error('❌ Failed to save old data to localStorage');
                                }

                                // Migrate to new structure automatically
                                console.log('🔄 Auto-migrating data to organized structure...');
                                window.saveToFirebase(user, oldData);

                                // Delete old structure after successful migration
                                set(ref(db, `users/${user.uid}/character`), null)
                                    .then(() => {
                                        console.log('🗑️ Old structure cleaned up');
                                    });

                                sessionStorage.removeItem('firebaseReloadCount');

                                // Small delay to ensure localStorage is fully written
                                setTimeout(() => {
                                    resolve(); // Resolve promise
                                }, 100);
                            } else {
                                // No data at all - new player
                                console.log("📝 No cloud data available. New player detected.");
                                localStorage.removeItem('rfOnlineGame');

                                if (!sessionStorage.getItem('newPlayerReset')) {
                                    sessionStorage.setItem('newPlayerReset', 'true');
                                    window.location.reload();
                                } else {
                                    sessionStorage.removeItem('newPlayerReset');
                                }
                                resolve(); // Resolve even for new players
                            }
                        }).catch((error) => {
                            console.error("❌ Error loading from Firebase:", error);
                            const loadingScreen = document.getElementById('auth-loading');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            reject(error);
                        });
                    }
                }).catch((error) => {
                    console.error("❌ Error checking metadata:", error);
                    const loadingScreen = document.getElementById('auth-loading');
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    reject(error);
                });
            });
        };

        // Check authentication state
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                console.log('🚫 No user logged in, redirecting to login page...');
                console.log('📊 Debug Info:');
                console.log('   - Current URL:', window.location.href);
                console.log('   - localStorage:', localStorage.getItem('rfOnlineGame') ? 'HAS DATA' : 'EMPTY');
                console.log('   - sessionStorage:', sessionStorage.getItem('currentSessionId') ? 'HAS SESSION' : 'NO SESSION');

                // Clear any stuck data
                console.log('🧹 Clearing stuck session data...');
                sessionStorage.removeItem('currentSessionId');
                sessionStorage.removeItem('newPlayerReset');
                sessionStorage.removeItem('firebaseReloadCount');

                // Show visual message before redirect
                const loadingScreen = document.getElementById('auth-loading');
                if (loadingScreen) {
                    const loadingText = document.getElementById('loading-text');
                    if (loadingText) {
                        loadingText.innerHTML = '🚫 Not logged in<br><small>Redirecting to login page...</small>';
                        loadingText.style.color = 'var(--danger)';
                    }
                }

                // Delay redirect slightly to allow console logging to be visible
                setTimeout(() => {
                    console.log('🔄 Redirecting to index.html...');
                    window.location.href = 'index.html';
                }, 1000);
            } else {
                console.log('User authenticated:', user.email);
                window.currentUser = user;

                // Set initial presence immediately when user logs in
                setTimeout(() => {
                    if (typeof updateUserPresence === 'function') {
                        updateUserPresence(user, 'HQ'); // Default to HQ when logging in
                    }
                }, 3000); // Wait a bit longer for Firebase to be fully ready

                // SESSION MANAGEMENT: Always generate new session ID (prevents duplicate tabs)
                const sessionId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                sessionStorage.setItem('currentSessionId', sessionId);

                // Write session ID to Firebase (will logout previous tabs)
                set(ref(db, `users/${user.uid}/activeSession`), sessionId)
                    .then(() => {
                        console.log('✅ Session ID set:', sessionId);
                    })
                    .catch((error) => {
                        console.error('❌ Error setting session ID:', error);
                    });

                // Monitor session changes (skip initial trigger)
                let isFirstCheck = true;
                const sessionRef = ref(db, `users/${user.uid}/activeSession`);
                onValue(sessionRef, (snapshot) => {
                    const activeSessionId = snapshot.val();
                    const currentSessionId = sessionStorage.getItem('currentSessionId');

                    // Skip the first check (initial value)
                    if (isFirstCheck) {
                        isFirstCheck = false;
                        return;
                    }

                    if (activeSessionId && currentSessionId && activeSessionId !== currentSessionId) {
                        console.log('🚫 Session invalidated. Another device logged in.');
                        console.log('📊 Session Debug:');
                        console.log('   - Active Session ID:', activeSessionId);
                        console.log('   - Current Session ID:', currentSessionId);

                        alert('Your account has been logged in from another device. You will be disconnected.');

                        // Clear session data
                        sessionStorage.clear();
                        localStorage.removeItem('rfOnlineGame');

                        // Redirect to login page
                        console.log('🔄 Redirecting to index.html due to session conflict...');
                        window.location.href = 'index.html';
                    }
                });

                // ALWAYS load from Firebase first, then initialize game
                console.log('🔄 Loading data from Firebase...');

                // Update loading text
                const loadingText = document.getElementById('loading-text');
                if (loadingText) loadingText.textContent = 'Loading your character...';

                window.loadFromFirebase(user).then(() => {
                    console.log('✅ Firebase data loaded, initializing game...');
                    initGame();

                    // Hide loading screen after initGame completes
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('auth-loading');
                        if (loadingScreen) {
                            loadingScreen.style.display = 'none';
                            loadingScreen.remove(); // Completely remove from DOM
                        }
                    }, 100); // Reduced from 200ms
                }).catch((error) => {
                    console.error('❌ Failed to load from Firebase:', error);
                    // Fall back to localStorage if Firebase fails
                    console.log('⚠️ Falling back to localStorage...');
                    initGame();

                    // Hide loading screen even on error
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('auth-loading');
                        if (loadingScreen) {
                            loadingScreen.style.display = 'none';
                            loadingScreen.remove(); // Completely remove from DOM
                        }
                    }, 100); // Reduced from 200ms
                });
            }
        });
    </script>

    <script>
        // Game state
        const gameState = {
            character: null,
            isExploring: false,
            exploreTimer: null,
            battleTimer: null,
            stopTimer: null,
            regenTimer: null,
            exploreStartTime: null,
            exploreDuration: 0,
            battleLog: [],
            inventory: [],
            materials: [],
            currency: 0,
            coins: 0,
            autoPotion: true, // Auto Potion enabled by default
            lastPotionTime: 0, // Track last potion use for cooldown
            // BOSS TIMER STATE
            bossCheckTimer: null,        // Timer for 15-min boss checks
            bossEncounterQueued: false,  // Flag: boss queued for next battle
            bossEncountered: false,      // Flag: boss already encountered this exploration
            // ENCOUNTER TRACKING
            encounterStats: {},          // Track monster encounters: { "Monster Name": count }
            // BOSS STATE
            bosses: {
                "Arghol Wasp": {
                    name: "Arghol Wasp",
                    level: 15,
                    maxHp: 5000,
                    currentHp: 5000,
                    attack: 150,
                    defense: 150,
                    isAlive: true,
                    lastDefeated: null
                },
                "Turncoat Knight": {
                    name: "Turncoat Knight",
                    level: 30,
                    maxHp: 10000,
                    currentHp: 10000,
                    attack: 200,
                    defense: 200,
                    isAlive: true,
                    lastDefeated: null
                },
                "Calliana Princess": {
                    name: "Calliana Princess",
                    level: 50,
                    maxHp: 15000,
                    currentHp: 15000,
                    attack: 300,
                    defense: 300,
                    isAlive: true,
                    lastDefeated: null
                }
            },
            currentMap: "HQ", // Default map
            // CHIP WAR STATE
            chips: {
                Accretia: {
                    race: "Accretia",
                    maxHp: 50000,
                    currentHp: 50000
                },
                Bellato: {
                    race: "Bellato",
                    maxHp: 50000,
                    currentHp: 50000
                },
                Cora: {
                    race: "Cora",
                    maxHp: 50000,
                    currentHp: 50000
                }
            },
            chipAttack: {
                isAttacking: false,
                targetRace: null,
                startTime: null,
                travelTime: 0, // in seconds
                damage: 0
            },
            chipNuke: {
                lastNukeTime: 0, // for 180-second cooldown
                lastNukeTimestamp: 0 // timestamp of last nuke use
            },
            // ARENA STATE
            arenaBattleInProgress: false // Prevent opening Arena during a battle
        };

        // Class base stats and level up system (Nerfed by ~35% total)
        const classStats = {
            Warrior: { hp: 130, fp: 35, attack: 20, defense: 13, criticalChance: 0.05 },
            Ranger: { hp: 100, fp: 55, attack: 17, defense: 10, criticalChance: 0.10 },
            Mystic: { hp: 85, fp: 100, attack: 14, defense: 6, criticalChance: 0.05 },
            Launcher: { hp: 85, fp: 100, attack: 14, defense: 6, criticalChance: 0.05 }
        };

        // Level up stat increases (Nerfed by ~35% total)
        const statIncrease = {
            Warrior: { hp: 32, fp: 10, attack: 2, defense: 2 },
            Ranger: { hp: 24, fp: 16, attack: 3, defense: 2 },
            Mystic: { hp: 16, fp: 26, attack: 3, defense: 1 },
            Launcher: { hp: 16, fp: 26, attack: 3, defense: 1 }
        };

        // Race-class mappings
        const raceClasses = {
            Accretia: ["Warrior", "Ranger", "Launcher"],
            Bellato: ["Warrior", "Ranger", "Mystic"],
            Cora: ["Warrior", "Ranger", "Mystic"]
        };

        // Class Skills Definition
        const classSkills = {
            Warrior: [
                { name: "Slash", level: 15, damageMult: 1.3, fpCost: 15, type: "Basic" },
                { name: "Clout Chop", level: 20, damageMult: 1.6, fpCost: 25, type: "Expert" },
                { name: "Pressure", level: 25, damageMult: 2.0, fpCost: 40, type: "Elite" },
                { name: "Bash Explosion", level: 30, damageMult: 2.5, fpCost: 60, type: "Ultimate" }
            ],
            Mystic: [
                { name: "Prism Shard", level: 15, damageMult: 1.4, fpCost: 15, type: "Basic" },
                { name: "Flame Arrow", level: 20, damageMult: 1.7, fpCost: 25, type: "Expert" },
                { name: "Blaze Pearl", level: 25, damageMult: 2.2, fpCost: 40, type: "Elite" },
                { name: "Force Impact", level: 30, damageMult: 2.7, fpCost: 60, type: "Ultimate" }
            ],
            Launcher: [
                { name: "Heavy Shot", level: 15, damageMult: 1.4, fpCost: 15, type: "Basic" },
                { name: "Compound Siege", level: 20, damageMult: 1.7, fpCost: 25, type: "Expert" },
                { name: "Chain Rocket", level: 25, damageMult: 2.2, fpCost: 40, type: "Elite" },
                { name: "Final Blast", level: 30, damageMult: 2.7, fpCost: 60, type: "Ultimate" }
            ],
            Ranger: [
                { name: "Fast Shot", level: 15, damageMult: 1.3, fpCost: 15, type: "Basic" },
                { name: "Aiming Shot", level: 20, damageMult: 1.6, fpCost: 25, type: "Expert" },
                { name: "Destructive Shot", level: 25, damageMult: 2.0, fpCost: 40, type: "Elite" },
                { name: "Inspired Shell", level: 30, damageMult: 2.5, fpCost: 60, type: "Ultimate" }
            ]
        };

        // Monster definitions
        const monsters = {
            // HQ Monsters
            // 30 mins Exploration Monsters
            "Young Flym": {
                level: 1,
                hp: 18,
                attack: 8,
                defense: 3,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Rusty Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Launcher", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Wing": {
                level: 2,
                hp: 25,
                attack: 12,
                defense: 5,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Rusty Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Launcher", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Flym": {
                level: 3,
                hp: 35,
                attack: 15,
                defense: 8,
                explorationTime: 30,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 1, chance: 1.0 },
                    { type: "item", name: "Rusty Sword", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Wand", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Bow", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Launcher", stats: { attack: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Rusty Armor", stats: { defense: 2 }, sellValue: 1, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },

            // 1 hour Exploration Monsters
            "Stinkbug": {
                level: 4,
                hp: 45,
                attack: 18,
                defense: 10,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Soft Launcher", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Desert Klan": {
                level: 5,
                hp: 55,
                attack: 22,
                defense: 12,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Soft Launcher", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Demolis": {
                level: 6,
                hp: 65,
                attack: 25,
                defense: 15,
                explorationTime: 60,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 2, chance: 1.0 },
                    { type: "item", name: "Sword Breaker", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Battle Staff", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Assemble Bow", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Soft Launcher", stats: { attack: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Leather Shirt", stats: { defense: 5 }, sellValue: 2, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },

            // 6 hours Exploration Monsters
            "Splinter Brat": {
                level: 7,
                hp: 80,
                attack: 30,
                defense: 18,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyr Sword", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Basic Launcher", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Light Tunic", stats: { defense: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Lunker": {
                level: 8,
                hp: 95,
                attack: 35,
                defense: 22,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyr Sword", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Basic Launcher", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Light Tunic", stats: { defense: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Warbeast": {
                level: 9,
                hp: 110,
                attack: 40,
                defense: 25,
                explorationTime: 360,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 3, chance: 1.0 },
                    { type: "item", name: "Valkyr Sword", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "War Wand", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Tower Bow", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Basic Launcher", stats: { attack: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Light Tunic", stats: { defense: 8 }, sellValue: 3, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },

            // 12 hours Exploration Monsters
            "Ratmoth": {
                level: 10,
                hp: 130,
                attack: 45,
                defense: 30,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Light Launcher", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Snatcher Cheat": {
                level: 11,
                hp: 150,
                attack: 50,
                defense: 35,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Light Launcher", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },
            "Splinter": {
                level: 12,
                hp: 180,
                attack: 55,
                defense: 40,
                explorationTime: 720,
                map: "HQ",
                drops: [
                    { type: "currency", amount: 4, chance: 1.0 },
                    { type: "item", name: "Zweihander", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Red Bead", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Beam Cross-Bow", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Light Launcher", stats: { attack: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Coil Armor", stats: { defense: 12 }, sellValue: 4, chance: 0.03 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.05 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 0.05 }
                ]
            },

            // BOSS - Arghol Wasp
            "Arghol Wasp": {
                level: 15,
                hp: 5000,
                attack: 150,
                defense: 150,
                explorationTime: 720,
                map: "HQ",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 100, chance: 1.0 },
                    { type: "item", name: "Arghol Blade", stats: { attack: 15 }, sellValue: 10, chance: 0.5 },
                    { type: "item", name: "Arghol Staff", stats: { attack: 15 }, sellValue: 10, chance: 0.5 },
                    { type: "item", name: "Arghol Bow", stats: { attack: 15 }, sellValue: 10, chance: 0.5 },
                    { type: "item", name: "Arghol Launcher", stats: { attack: 15 }, sellValue: 10, chance: 0.5 },
                    { type: "item", name: "Arghol Armor", stats: { defense: 15 }, sellValue: 10, chance: 0.5 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.009 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Mighty Ring", stats: { attack: 25, defense: 25 }, sellValue: 3, chance: 0.002 },
                    { type: "item", name: "Cosmic Ring", stats: { attack: 30, defense: 30 }, sellValue: 3, chance: 0.001 },
                    { type: "item", name: "Basic Wings", stats: { attack: 5, defense: 5 }, movementSpeed: 1.0, isWings: true, sellValue: 5, chance: 0.5 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 10 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 10 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 5, chance: 1.0, quantity: 2 },
                    { type: "material", name: "Wild Herb", stats: {}, sellValue: 1, chance: 1.0, quantity: 10 }

                ]
            },

            // Sette Desert Monsters
            "Bulky Lunker": {
                level: 25,
                hp: 300,
                attack: 80,
                defense: 60,
                explorationTime: 30,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 5, chance: 1.0 },
                    { type: "item", name: "Bastard Sword", stats: { attack: 20 }, sellValue: 5, chance: 0.02 },
                    { type: "item", name: "Black Wand", stats: { attack: 20 }, sellValue: 5, chance: 0.02 },
                    { type: "item", name: "Long Bow", stats: { attack: 20 }, sellValue: 5, chance: 0.02 },
                    { type: "item", name: "Heavy Launcher", stats: { attack: 20 }, sellValue: 5, chance: 0.02 },
                    { type: "item", name: "Iron Tunic", stats: { defense: 20 }, sellValue: 5, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Ghost": {
                level: 26,
                hp: 350,
                attack: 90,
                defense: 65,
                explorationTime: 30,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 6, chance: 1.0 },
                    { type: "item", name: "Claymore", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Field Staff", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Battle Bow", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Dusty Launcher", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Steel Core", stats: { defense: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Ghost II": { // Hack for 1 hour
                level: 26,
                hp: 380,
                attack: 95,
                defense: 70,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 6, chance: 1.0 },
                    { type: "item", name: "Claymore", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Field Staff", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Battle Bow", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Dusty Launcher", stats: { attack: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Steel Core", stats: { defense: 22 }, sellValue: 6, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Rigor Lapis": {
                level: 27,
                hp: 450,
                attack: 100,
                defense: 75,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Raging Wave",
                drops: [
                    { type: "currency", amount: 7, chance: 1.0 },
                    { type: "item", name: "Big Breaker", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Dual Wand", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Dual Bow", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Flame Thrower", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Duple Armor", stats: { defense: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Rigor Lapis II": { // Hack for 6 hours
                level: 27,
                hp: 500,
                attack: 110,
                defense: 80,
                explorationTime: 360,
                map: "Sette Desert",
                skill: "Raging Wave",
                drops: [
                    { type: "currency", amount: 7, chance: 1.0 },
                    { type: "item", name: "Big Breaker", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Dual Wand", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Dual Bow", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Flame Thrower", stats: { attack: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Duple Armor", stats: { defense: 25 }, sellValue: 7, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Grumble Hook": {
                level: 28,
                hp: 550,
                attack: 120,
                defense: 85,
                explorationTime: 60,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 8, chance: 1.0 },
                    { type: "item", name: "Beam Sword", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Beam Bead", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Beam Bow", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Hook Launcher", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Sprits Cloak", stats: { defense: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Grumble Hook II": { // Hack for 6 hours
                level: 28,
                hp: 600,
                attack: 130,
                defense: 90,
                explorationTime: 360,
                map: "Sette Desert",
                skill: "Wind Blast",
                drops: [
                    { type: "currency", amount: 8, chance: 1.0 },
                    { type: "item", name: "Beam Sword", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Beam Bead", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Beam Bow", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Hook Launcher", stats: { attack: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Sprits Cloak", stats: { defense: 28 }, sellValue: 8, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Turncoat": {
                level: 29,
                hp: 700,
                attack: 140,
                defense: 100,
                explorationTime: 60,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 9, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Bazooka", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Turncoat II": { // Hack for 6 hours
                level: 29,
                hp: 750,
                attack: 150,
                defense: 110,
                explorationTime: 360,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 9, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Bazooka", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },
            "Turncoat III": { // Hack for 12 hours
                level: 29,
                hp: 800,
                attack: 160,
                defense: 120,
                explorationTime: 720,
                map: "Sette Desert",
                drops: [
                    { type: "currency", amount: 9, chance: 1.0 },
                    { type: "item", name: "Scale Sword", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Blue Wand", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Siege Bow", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Bazooka", stats: { attack: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Soul Armor", stats: { defense: 32 }, sellValue: 9, chance: 0.02 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.005 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.004 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.06 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 0.06 }
                ]
            },

            // BOSS - Turncoat Knight
            "Turncoat Knight": {
                level: 30,
                hp: 10000,
                attack: 200,
                defense: 200,
                explorationTime: 720,
                map: "Sette Desert",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 150, chance: 1.0 },
                    { type: "item", name: "Turncoat Sword", stats: { attack: 35 }, sellValue: 15, chance: 0.5 },
                    { type: "item", name: "Turncoat Staff", stats: { attack: 35 }, sellValue: 15, chance: 0.5 },
                    { type: "item", name: "Turncoat Bow", stats: { attack: 35 }, sellValue: 15, chance: 0.5 },
                    { type: "item", name: "Turncoat Launcher", stats: { attack: 35 }, sellValue: 15, chance: 0.5 },
                    { type: "item", name: "Turncoat Armor", stats: { defense: 35 }, sellValue: 15, chance: 0.5 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.010 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.009 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Mighty Ring", stats: { attack: 25, defense: 25 }, sellValue: 3, chance: 0.002 },
                    { type: "item", name: "Cosmic Ring", stats: { attack: 30, defense: 30 }, sellValue: 3, chance: 0.001 },
                    { type: "item", name: "Polished Wings", stats: { attack: 6, defense: 6 }, movementSpeed: 1.0, isWings: true, sellValue: 5, chance: 0.5 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 15 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 15 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 10, chance: 1.0, quantity: 4 },
                    { type: "material", name: "Empty Box", stats: {}, sellValue: 2, chance: 1.0, quantity: 5 }
                ]
            },

            // ETHER PLATFORM MONSTERS
            // Wharf Area
            "Chooty": {
                level: 40,
                hp: 500,
                attack: 100,
                defense: 100,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 10, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.10 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Hobo Mite": {
                level: 41,
                hp: 600,
                attack: 120,
                defense: 110,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 11, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.12 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Hobo Sword": {
                level: 41,
                hp: 600,
                attack: 120,
                defense: 110,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 11, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.12 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Hobo Turnpike": {
                level: 41,
                hp: 650,
                attack: 130,
                defense: 115,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 12, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.14 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Hobo Cutter": {
                level: 41,
                hp: 650,
                attack: 130,
                defense: 115,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 12, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.14 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Passer Alpha": {
                level: 44,
                hp: 675,
                attack: 145,
                defense: 120,
                area: "Wharf",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 13, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.14 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },

            // White Hole Area
            "Hobo Robber": {
                level: 45,
                hp: 700,
                attack: 150,
                defense: 125,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 14, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.16 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Hobo Blade": {
                level: 45,
                hp: 700,
                attack: 150,
                defense: 125,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 14, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.16 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Passer Beta": {
                level: 46,
                hp: 725,
                attack: 155,
                defense: 130,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 15, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.18 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Calliana Atroc": {
                level: 47,
                hp: 750,
                attack: 165,
                defense: 145,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 16, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.2 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Calliana Crew": {
                level: 47,
                hp: 750,
                attack: 165,
                defense: 145,
                area: "White Hole",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 16, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.2 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },

            // Lures Lot Area
            "Calliana Atroc II": { // Duplicate for Lures Lot
                level: 47,
                hp: 750,
                attack: 165,
                defense: 145,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 16, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.3 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Calliana Crew II": { // Duplicate for Lures Lot
                level: 47,
                hp: 750,
                attack: 165,
                defense: 145,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 16, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.3 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Calliana Archer": {
                level: 49,
                hp: 800,
                attack: 175,
                defense: 155,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 17, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.4 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },
            "Assassin Builder B": {
                level: 50,
                hp: 850,
                attack: 200,
                defense: 160,
                area: "Lures Lot",
                map: "Ether Platform",
                drops: [
                    { type: "currency", amount: 18, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 0.5 },
                    { type: "item", name: "Estoc", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Black Stick Bead", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Beam Siege Bow", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Missile Launcher", stats: { attack: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Glow Suit", stats: { defense: 45 }, sellValue: 10, chance: 0.01 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.007 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.006 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.005 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 0.07 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 0.07 }
                ]
            },

            // BOSS - Calliana Princess (Lures Lot only)
            "Calliana Princess": {
                level: 50,
                hp: 15000,
                attack: 300,
                defense: 300,
                area: "Lures Lot",
                map: "Ether Platform",
                isBoss: true,
                drops: [
                    { type: "currency", amount: 200, chance: 1.0 },
                    { type: "material", name: "Winter Box", sellValue: 20, chance: 1.0, quantity: 50 },
                    { type: "material", name: "Snowflake", sellValue: 15, chance: 1.0, quantity: 1 },
                    { type: "item", name: "Calliana Sword", stats: { attack: 55 }, sellValue: 20, chance: 0.5 },
                    { type: "item", name: "Calliana Staff", stats: { attack: 55 }, sellValue: 20, chance: 0.5 },
                    { type: "item", name: "Calliana Bow", stats: { attack: 55 }, sellValue: 20, chance: 0.5 },
                    { type: "item", name: "Calliana Launcher", stats: { attack: 55 }, sellValue: 20, chance: 0.5 },
                    { type: "item", name: "Calliana Armor", stats: { defense: 55 }, sellValue: 20, chance: 0.9 },
                    { type: "item", name: "Novice Ring", stats: { attack: 5, defense: 5 }, sellValue: 3, chance: 0.11 },
                    { type: "item", name: "Mild Ring", stats: { attack: 10, defense: 10 }, sellValue: 3, chance: 0.10 },
                    { type: "item", name: "Normal Ring", stats: { attack: 15, defense: 15 }, sellValue: 3, chance: 0.009 },
                    { type: "item", name: "Power Ring", stats: { attack: 20, defense: 20 }, sellValue: 3, chance: 0.008 },
                    { type: "item", name: "Mighty Ring", stats: { attack: 25, defense: 25 }, sellValue: 3, chance: 0.002 },
                    { type: "item", name: "Cosmic Ring", stats: { attack: 30, defense: 30 }, sellValue: 3, chance: 0.001 },
                    { type: "item", name: "Advanced Wings", stats: { attack: 7, defense: 7 }, movementSpeed: 1.0, isWings: true, sellValue: 5, chance: 0.5 },
                    { type: "material", name: "Red Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 20 },
                    { type: "material", name: "Blue Gem", stats: {}, sellValue: 1, chance: 1.0, quantity: 20 },
                    { type: "material", name: "Shiny Gem", stats: {}, sellValue: 10, chance: 1.0, quantity: 6 }
                ]
            }
        };

        // Crafting Recipes
        const craftingRecipes = {
            // Arghol Series (From Arghol Wasp)
            "T1 Arghol Blade": {
                name: "T1 Arghol Blade",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 30,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Blade", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 900
                }
            },
            "T1 Arghol Staff": {
                name: "T1 Arghol Staff",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 30,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 900
                }
            },
            "T1 Arghol Bow": {
                name: "T1 Arghol Bow",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 30,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 900
                }
            },
            "T1 Arghol Launcher": {
                name: "T1 Arghol Launcher",
                type: "weapon",
                stats: { attack: 50 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 30,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Launcher", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 900
                }
            },
            "T1 Arghol Armor": {
                name: "T1 Arghol Armor",
                type: "armor",
                stats: { defense: 50 },
                damageReduction: 0.10,
                sellValue: 30,
                rarity: "t1",
                requirements: {
                    item: { name: "Arghol Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 5, "Blue Gem": 5, "Shiny Gem": 1 },
                    currency: 900
                }
            },

            // Turncoat Series (From Turncoat)
            "T1 Turncoat Sword": {
                name: "T1 Turncoat Sword",
                type: "weapon",
                stats: { attack: 70 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 35,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Sword", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 2 },
                    currency: 1200
                }
            },
            "T1 Turncoat Staff": {
                name: "T1 Turncoat Staff",
                type: "weapon",
                stats: { attack: 70 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 35,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 2 },
                    currency: 1200
                }
            },
            "T1 Turncoat Bow": {
                name: "T1 Turncoat Bow",
                type: "weapon",
                stats: { attack: 70 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 35,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 2 },
                    currency: 1200
                }
            },
            "T1 Turncoat Launcher": {
                name: "T1 Turncoat Launcher",
                type: "weapon",
                stats: { attack: 70 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 35,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Launcher", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 2 },
                    currency: 1200
                }
            },
            "T1 Turncoat Armor": {
                name: "T1 Turncoat Armor",
                type: "armor",
                stats: { defense: 70 },
                damageReduction: 0.15,
                sellValue: 35,
                rarity: "t1",
                requirements: {
                    item: { name: "Turncoat Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 8, "Blue Gem": 8, "Shiny Gem": 2 },
                    currency: 1200
                }
            },
            "T1 Calliana Sword": {
                name: "T1 Calliana Sword",
                type: "weapon",
                stats: { attack: 90 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 40,
                rarity: "t1",
                requirements: {
                    item: { name: "Calliana Sword", upgradeLevel: 5 },
                    materials: { "Red Gem": 11, "Blue Gem": 11, "Shiny Gem": 3 },
                    currency: 1500
                }
            },
            "T1 Calliana Staff": {
                name: "T1 Calliana Staff",
                type: "weapon",
                stats: { attack: 90 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 40,
                rarity: "t1",
                requirements: {
                    item: { name: "Calliana Staff", upgradeLevel: 5 },
                    materials: { "Red Gem": 11, "Blue Gem": 11, "Shiny Gem": 3 },
                    currency: 1500
                }
            },
            "T1 Calliana Bow": {
                name: "T1 Calliana Bow",
                type: "weapon",
                stats: { attack: 90 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 40,
                rarity: "t1",
                requirements: {
                    item: { name: "Calliana Bow", upgradeLevel: 5 },
                    materials: { "Red Gem": 11, "Blue Gem": 11, "Shiny Gem": 3 },
                    currency: 1500
                }
            },
            "T1 Calliana Launcher": {
                name: "T1 Calliana Launcher",
                type: "weapon",
                stats: { attack: 90 },
                lifesteal: { chance: 0.20, multiplier: 0.50 },
                sellValue: 40,
                rarity: "t1",
                requirements: {
                    item: { name: "Calliana Launcher", upgradeLevel: 5 },
                    materials: { "Red Gem": 11, "Blue Gem": 11, "Shiny Gem": 3 },
                    currency: 1500
                }
            },
            "T1 Calliana Armor": {
                name: "T1 Calliana Armor",
                type: "armor",
                stats: { defense: 90 },
                damageReduction: 0.20,
                sellValue: 40,
                rarity: "t1",
                requirements: {
                    item: { name: "Calliana Armor", upgradeLevel: 5 },
                    materials: { "Red Gem": 11, "Blue Gem": 11, "Shiny Gem": 3 },
                    currency: 1500
                }
            },

            // Accessory Crafting Recipes
            "Novice Ring ★": {
                name: "Novice Ring ★",
                type: "accessory",
                stats: { attack: 10, defense: 10 },
                sellValue: 6,
                rarity: "common",
                successRate: 0.30, // 30% success rate
                requirements: {
                    items: [{ name: "Novice Ring", quantity: 2 }], // Requires 2 Novice Rings
                    materials: {},
                    currency: 100
                }
            },
            "Mild Ring ★": {
                name: "Mild Ring ★",
                type: "accessory",
                stats: { attack: 15, defense: 15 },
                sellValue: 6,
                rarity: "common",
                successRate: 0.30, // 30% success rate
                requirements: {
                    items: [{ name: "Mild Ring", quantity: 2 }], // Requires 2 Mild Rings
                    materials: {},
                    currency: 100
                }
            },
            "Normal Ring ★": {
                name: "Normal Ring ★",
                type: "accessory",
                stats: { attack: 20, defense: 20 },
                sellValue: 6,
                rarity: "common",
                successRate: 0.30, // 30% success rate
                requirements: {
                    items: [{ name: "Normal Ring", quantity: 2 }], // Requires 2 Novice Rings
                    materials: {},
                    currency: 100
                }
            },
            "Power Ring ★": {
                name: "Power Ring ★",
                type: "accessory",
                stats: { attack: 25, defense: 25 },
                sellValue: 6,
                rarity: "common",
                successRate: 0.30, // 30% success rate
                requirements: {
                    items: [{ name: "Power Ring", quantity: 2 }], // Requires 2 Novice Rings
                    materials: {},
                    currency: 100
                }
            },
        };

        // Upgrade system
        const upgradeSystem = {
            // Upgrade bonuses per level
            bonuses: {
                1: { attack: 5, defense: 5 },
                2: { attack: 10, defense: 10 },
                3: { attack: 15, defense: 15 },
                4: { attack: 20, defense: 20 },
                5: { attack: 25, defense: 25 },
                6: { attack: 30, defense: 30 },
                7: { attack: 35, defense: 35 },
            },
            // Success chances per level
            chances: {
                1: 1.0,  // 100%
                2: 0.9,  // 90%
                3: 0.8,  // 80%
                4: 0.7,  // 70%
                5: 0.5,  // 50%
                6: 0.4,  // 40%
                7: 0.3   // 30%
            },
            // Cost per level - Weapons use Red Gems, Armors use Blue Gems
            costs: {
                1: { "Red Gem": 1, "Blue Gem": 1, "currency": 100 },
                2: { "Red Gem": 2, "Blue Gem": 2, "currency": 100 },
                3: { "Red Gem": 3, "Blue Gem": 3, "currency": 100 },
                4: { "Red Gem": 4, "Blue Gem": 4, "currency": 100 },
                5: { "Red Gem": 5, "Blue Gem": 5, "currency": 100 },
                6: { "Red Gem": 6, "Blue Gem": 6, "currency": 100 },
                7: { "Red Gem": 7, "Blue Gem": 7, "currency": 100 }
            },
            // Destroy on +5, +6, +7 failure
            destroyOnFailure: [5, 6, 7]
        };

        // DOM elements
        const registrationModal = document.getElementById('registration-modal');
        const playersModal = document.getElementById('players-modal');
        const mapsModal = document.getElementById('maps-modal');
        const marketModal = document.getElementById('market-modal');
        const upgradeModal = document.getElementById('upgrade-modal');
        const exploreBtn = document.getElementById('explore-btn');
        const exploreOptions = document.getElementById('explore-options');
        const stopBtn = document.getElementById('stop-btn');
        const playersBtn = document.getElementById('players-btn');
        const mapsBtn = document.getElementById('maps-btn');
        const createCharacterBtn = document.getElementById('create-character-btn');
        const battleLog = document.getElementById('battle-log');
        const inventoryItems = document.getElementById('inventory-items');
        const materialsItems = document.getElementById('materials-items');
        const emptyInventory = document.getElementById('empty-inventory');
        const emptyMaterials = document.getElementById('empty-materials');
        const exploreStatus = document.getElementById('explore-status');
        const exploreTimer = document.getElementById('explore-timer');
        const upgradeItemInfo = document.getElementById('upgrade-item-info');
        const upgradeResult = document.getElementById('upgrade-result');
        const upgradeConfirmBtn = document.getElementById('upgrade-confirm-btn');
        const upgradeCancelBtn = document.getElementById('upgrade-cancel-btn');
        const inventoryLimit = document.getElementById('inventory-limit');
        const setteDessetMap = document.getElementById('sette-desset-map');
        const craftingModal = document.getElementById('crafting-modal');
        const craftBtn = document.getElementById('craft-btn');
        const craftConfirmBtn = document.getElementById('craft-confirm-btn');
        const craftCancelBtn = document.getElementById('craft-cancel-btn');
        const recipeList = document.getElementById('recipe-list');

        // Current item being upgraded
        let currentUpgradeItem = null;
        let selectedRecipe = null;
        let currentCategory = 'sword'; // Track current crafting category

        // Process offline battles
        function processOfflineBattles(count, map, duration, area = null) {
            const char = gameState.character;
            let totalExp = 0;
            let totalCurrency = 0;
            let totalDrops = [];
            let battlesWon = 0;
            let battlesLost = 0;

            // Get monsters for this exploration
            let availableMonsters;
            if (area) {
                // Area-based exploration (Ether Platform)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.area === area && monster.map === map
                );
            } else {
                // Time-based exploration (HQ, Sette Desert)
                const exploreMinutes = duration / 60000;
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.explorationTime === exploreMinutes && monster.map === map
                );
            }

            if (availableMonsters.length === 0) return;

            for (let i = 0; i < count; i++) {
                const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                const [monsterName, monster] = availableMonsters[randomIndex];

                // Simplified Battle Logic for Offline
                // Assume player wins if level is sufficient, or use simple stats comparison
                // For now, let's give the player the benefit of the doubt for offline progress
                // unless they are severely underleveled.

                let playerWins = true;
                if (char.level < monster.level - 5) {
                    // 50% chance if underleveled
                    playerWins = Math.random() > 0.5;
                }

                if (playerWins) {
                    battlesWon++;

                    // EXP
                    if (char.level < 40) {
                        // Use the new formula: Monster Level * 3
                        const expGain = monster.level * 1;
                        totalExp += expGain;
                    }

                    // Currency
                    if (monster.drops) {
                        monster.drops.forEach(drop => {
                            if (Math.random() < drop.chance) {
                                if (drop.type === 'currency') {
                                    totalCurrency += drop.amount;
                                } else {
                                    totalDrops.push({ ...drop, itemName: drop.name }); // Store item name
                                }
                            }
                        });
                    }
                } else {
                    battlesLost++;
                }
            }

            // Apply Results
            if (totalExp > 0) {
                char.exp += totalExp;
                while (char.exp >= char.maxExp && char.level < 40) {
                    char.exp -= char.maxExp;
                    char.level++;
                    // EXP Required Formula: Moderate exponential progression (100 * 1.15^(level-1))
                    char.maxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));

                    // Update stats
                    const base = classStats[char.class];
                    const increases = statIncrease[char.class];
                    char.maxHp += increases.hp;
                    char.maxFp += increases.fp;
                    char.attack += increases.attack;
                    char.defense += increases.defense;

                    char.hp = char.maxHp;
                    char.fp = char.maxFp;
                }
            }

            gameState.currency += totalCurrency;

            // Process Drops
            const consolidatedDrops = {};
            totalDrops.forEach(drop => {
                if (drop.type === 'item' || drop.type === 'material') {
                    const name = drop.itemName;
                    if (!consolidatedDrops[name]) {
                        consolidatedDrops[name] = { ...drop, count: 0 };
                    }
                    consolidatedDrops[name].count++;
                }
            });

            // Add to inventory
            Object.values(consolidatedDrops).forEach(drop => {
                if (drop.type === 'material') {
                    const existingMat = gameState.materials.find(m => m.name === drop.name);
                    if (existingMat) {
                        existingMat.quantity += drop.count;
                    } else {
                        gameState.materials.push({
                            name: drop.name,
                            sellValue: drop.sellValue,
                            quantity: drop.count,
                            type: 'material'
                        });
                    }
                } else if (drop.type === 'item') {
                    // For items, we add them individually or stack if stackable (but equipment isn't stackable usually)
                    // In this game, equipment is individual.
                    // Limit offline equipment drops to avoid inventory overflow?
                    // Let's add up to 10 items to avoid spam, convert rest to currency?
                    // For now, just add them.
                    for (let k = 0; k < drop.count; k++) {
                        // Check inventory limit
                        if (gameState.inventory.length >= 20) {
                            // Only log once per item type to avoid spam
                            if (k === 0) {
                                addToBattleLog(`Inventory full! Could not pick up remaining ${drop.name}s.`, 'warning');
                            }
                            continue;
                        }

                        gameState.inventory.push({
                            name: drop.name,
                            stats: { ...drop.stats },
                            sellValue: drop.sellValue,
                            quantity: 1,
                            type: 'item',
                            upgradeLevel: 0,
                            rarity: 'common'
                        });
                    }
                }
            });

            // Log Summary
            addToBattleLog(`📝 Offline Report: Won ${battlesWon} battles.`, 'success');
            if (totalExp > 0) addToBattleLog(`✨ Gained ${totalExp} EXP.`, 'exp');
            if (totalCurrency > 0) addToBattleLog(`💰 Gained ${totalCurrency} Leaves.`, 'gold');

            const dropNames = Object.keys(consolidatedDrops);
            if (dropNames.length > 0) {
                addToBattleLog(`📦 Looted: ${dropNames.join(', ')}`, 'loot');
            }

            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameState();
        }

        // Resume exploration
        function resumeExploration(remainingTime, savedData) {
            addToBattleLog(`Resuming exploration... ${formatExplorationTime(Math.floor(remainingTime / 60000))} remaining.`);

            // Restore UI state
            exploreOptions.style.display = 'none';
            exploreBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            exploreStatus.style.display = 'flex';
            // Restore exploreArea if it exists
            if (savedData.exploreArea) {
                gameState.exploreArea = savedData.exploreArea;
                document.getElementById('explore-selected-time').textContent = `Explore Time: ${savedData.exploreArea}`;
            } else {
                const minutes = gameState.exploreDuration / 60000;
                let displayText;
                if (minutes < 60) {
                    displayText = `${minutes}m`;
                } else {
                    displayText = `${minutes / 60}h`;
                }
                document.getElementById('explore-selected-time').textContent = `Explore Time: ${displayText}`;
            }


            // Restart timers
            gameState.exploreTimer = setInterval(() => {
                const elapsed = Date.now() - gameState.exploreStartTime;
                const remaining = Math.max(0, gameState.exploreDuration - elapsed);

                const elapsedMinutes = Math.floor(elapsed / 60000);
                const elapsedSeconds = Math.floor((elapsed % 60000) / 1000);

                exploreTimer.textContent = `Elapsed ${Math.floor(elapsedMinutes)}:${elapsedSeconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    finishExploration();
                }

                // Auto-save every minute
                if (elapsedSeconds === 0) {
                    saveGameState();
                }
            }, 1000);

            startBattles();
        }

        // Initialize the game
        function initGame() {
            // Check if character exists in localStorage with integrity validation
            const savedData = loadGameState();

            if (savedData) {
                gameState.character = savedData.character;
                // Initialize new properties if they don't exist in saved data (for migration)
                if (savedData.currency === undefined) savedData.currency = 0;
                if (savedData.coins === undefined) savedData.coins = savedData.gold || 0;
                if (savedData.materials === undefined) savedData.materials = [];

                gameState.inventory = savedData.inventory || [];
                gameState.materials = savedData.materials || [];
                gameState.currency = savedData.currency || 0;
                gameState.coins = savedData.coins || 0; // Load coins
                gameState.currentMap = savedData.currentMap || "HQ";

                // Load guild data if exists
                if (savedData.guild) {
                    gameState.guild = savedData.guild;
                }

                // MIGRATION: Fix maxExp for characters with incorrect formulas
                // Correct formula is 100 * 1.15^(level-1)
                const char = gameState.character;
                if (char && char.level && char.maxExp) {
                    const correctMaxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));

                    // Check against old formulas and any incorrect values
                    const oldFormula1 = Math.floor(50 * Math.pow(1.2, char.level - 1));  // Old 1.2 curve
                    const oldFormula2 = Math.floor(100 * Math.pow(1.3, char.level - 1)); // Migration was using 1.3

                    // If maxExp doesn't match correct formula, fix it
                    if (char.maxExp !== correctMaxExp) {
                        console.log(`Fixing maxExp from ${char.maxExp} to ${correctMaxExp} (level ${char.level})`);
                        char.maxExp = correctMaxExp;
                        addToBattleLog(`🔧 EXP requirements corrected!`, 'success');
                    }
                }

                // Load boss state if exists, otherwise use default
                if (savedData.bosses) {
                    // Merge saved boss data with defaults, ensuring all bosses have required properties
                    Object.keys(gameState.bosses).forEach(bossName => {
                        if (savedData.bosses[bossName]) {
                            // Merge saved data but ensure isAlive is set
                            gameState.bosses[bossName] = {
                                ...gameState.bosses[bossName],
                                ...savedData.bosses[bossName],
                                // If isAlive is undefined in saved data, default to true
                                isAlive: savedData.bosses[bossName].isAlive !== undefined ? savedData.bosses[bossName].isAlive : true
                            };
                        }
                        // If boss doesn't exist in saved data, keep default (isAlive: true)
                    });
                } else if (savedData.boss) {
                    // Migrate old single boss state
                    gameState.bosses["Arghol Wasp"] = {
                        ...gameState.bosses["Arghol Wasp"],
                        ...savedData.boss,
                        isAlive: savedData.boss.isAlive !== undefined ? savedData.boss.isAlive : true
                    };
                }

                // TEMPORARILY DISABLED: RESUME EXPLORATION IF IT WAS IN PROGRESS
                // This was causing issues where exploration would resume even after death
                /*
                if (savedData.isExploring) {
                    gameState.isExploring = true;
                    gameState.exploreStartTime = Date.now(); // Reset start time to now
                    gameState.exploreDuration = savedData.exploreDuration;
                    gameState.currentMap = savedData.currentMap;
 
                    // Resume exploration with full duration (no offline progress)
                    addToBattleLog(`🔄 Resuming exploration in ${savedData.currentMap}...`, 'info');
                    resumeExploration(savedData.exploreDuration, savedData);
                }
                */


                // Force update boss static stats (MaxHP, Level, etc.) from source
                // This fixes issues where old save data has outdated boss stats (e.g. Turncoat Knight 25k HP)
                const defaultBosses = {
                    "Arghol Wasp": { maxHp: 5000, attack: 150, defense: 150, level: 15 },
                    "Turncoat Knight": { maxHp: 10000, attack: 200, defense: 200, level: 30 },
                    "Calliana Princess": { maxHp: 15000, attack: 300, defense: 300, level: 50 }
                };

                Object.entries(defaultBosses).forEach(([bossName, stats]) => {
                    if (gameState.bosses[bossName]) {
                        gameState.bosses[bossName].maxHp = stats.maxHp;
                        gameState.bosses[bossName].attack = stats.attack;
                        gameState.bosses[bossName].defense = stats.defense;
                        gameState.bosses[bossName].level = stats.level;
                        // Clamp current HP to new Max HP
                        if (gameState.bosses[bossName].currentHp > stats.maxHp) {
                            gameState.bosses[bossName].currentHp = stats.maxHp;
                        }
                    }
                });

                // Fix object references lost during JSON serialization and recalculate stats
                if (gameState.character.equipped) {
                    const char = gameState.character;

                    // Initialize ALL equipment slots if they don't exist (for old/corrupted saves)
                    if (!char.equipped.weapon) char.equipped.weapon = null;
                    if (!char.equipped.armor) char.equipped.armor = null;
                    if (!char.equipped.accessory1) char.equipped.accessory1 = null;
                    if (!char.equipped.accessory2) char.equipped.accessory2 = null;
                    if (!char.equipped.hasOwnProperty('wings')) {
                        char.equipped.wings = null;
                    }

                    const slots = ['weapon', 'armor', 'accessory1', 'accessory2', 'wings'];
                    const claimedItems = new Set();

                    // Reset stats to base (Class + Level) to ensure accuracy
                    const base = classStats[char.class];
                    const increases = statIncrease[char.class];
                    const levels = char.level - 1;

                    char.maxHp = Math.floor(base.hp + (levels * increases.hp));
                    char.maxFp = Math.floor(base.fp + (levels * increases.fp));
                    char.attack = Math.floor(base.attack + (levels * increases.attack));
                    char.defense = Math.floor(base.defense + (levels * increases.defense));
                    char.criticalChance = base.criticalChance || 0.05; // Reset crit chance

                    // Recalculate MaxExp with proper exponential curve
                    char.maxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));

                    // Ensure maxExp is correct for current level using proper 1.15 curve
                    const correctMaxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));
                    if (char.maxExp !== correctMaxExp) {
                        char.maxExp = correctMaxExp;
                    }

                    // Re-link equipped items and apply stats
                    slots.forEach(slot => {
                        if (char.equipped[slot]) {
                            const savedItem = char.equipped[slot];
                            // Find matching item in inventory
                            const match = gameState.inventory.find(i =>
                                !claimedItems.has(i) &&
                                i.name === savedItem.name &&
                                i.upgradeLevel === savedItem.upgradeLevel &&
                                JSON.stringify(i.stats) === JSON.stringify(savedItem.stats)
                            );

                            if (match) {
                                // Re-link reference to inventory object
                                char.equipped[slot] = match;
                                claimedItems.add(match);

                                // Apply stats
                                const itemLevel = match.upgradeLevel || 0;
                                const isAccessory = slot.includes('accessory');
                                const isWings = slot === 'wings';

                                if (isAccessory || isWings) {
                                    // Accessories and Wings have both attack and defense
                                    char.attack += match.stats.attack || 0;
                                    char.defense += match.stats.defense || 0;
                                } else {
                                    const isArmor = slot === 'armor';
                                    const statType = isArmor ? 'defense' : 'attack';
                                    const bonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                                    char[statType] += (match.stats[statType] || 0) + bonus;
                                }
                            } else {
                                // Ghost item found! Clear it.
                                console.warn(`Removed ghost item from ${slot}: ${savedItem.name}`);
                                char.equipped[slot] = null;
                            }
                        }
                    });
                }

                // Re-apply guild bonus if player is in a guild
                if (gameState.guild && gameState.guild.guildId) {
                    gameState.character.attack += 5;
                    gameState.character.defense += 5;
                }

                // Check boss respawn
                checkBossRespawn();

                updateCharacterDisplay();
                updateInventoryDisplay();
                updateMapsAccessibility(); // Update map access based on level

                // Set up user presence in Firebase (will initialize after delay)
                if (window.currentUser) {
                    // Presence will be set up when Firebase is ready
                    setTimeout(() => {
                        if (typeof updateUserPresence === 'function') {
                            console.log('Setting user presence for map:', gameState.currentMap);
                            updateUserPresence(window.currentUser, gameState.currentMap);
                        }
                    }, 2500);
                }

                // Show player count immediately

                // Set up real-time currency sync from Firebase
                if (window.currentUser) {
                    setTimeout(async () => {
                        try {
                            const { ref, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                            const currencyRef = ref(window.db, `users/${window.currentUser.uid}/currency`);

                            onValue(currencyRef, (snapshot) => {
                                const firebaseCurrency = snapshot.val();
                                if (firebaseCurrency !== null && firebaseCurrency !== undefined) {
                                    // Handle both object format and legacy number format
                                    let newLeaves = gameState.currency;

                                    if (typeof firebaseCurrency === 'object') {
                                        newLeaves = firebaseCurrency.leaves || 0;
                                    } else {
                                        newLeaves = firebaseCurrency;
                                    }

                                    // Only update if there's an actual change (to avoid save loops)
                                    if (newLeaves !== gameState.currency) {
                                        gameState.currency = newLeaves;

                                        // Update UI
                                        document.getElementById('currency-amount').textContent = gameState.currency;

                                        console.log(`Currency synced from Firebase: ${newLeaves} Leaves`);
                                    }
                                }
                            });
                        } catch (error) {
                            console.error('Failed to set up currency sync:', error);
                        }
                    }, 2500);
                }

                // Start real-time map player updates
                setTimeout(() => {
                }, 2500);

                // Process pending market payments
                if (window.currentUser) {
                    setTimeout(async () => {
                        try {
                            await processPendingMarketPayments();
                        } catch (error) {
                            console.error('Failed to process pending payments:', error);
                        }
                    }, 3000);
                }

                // Fix UI if exploration finished but UI wasn't reset
                if (!gameState.isExploring) {
                    exploreBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    exploreStatus.style.display = 'flex';
                    document.getElementById('explore-selected-time').textContent = 'AFK';
                    document.getElementById('explore-timer').textContent = '';
                    mapsBtn.disabled = false;
                    mapsBtn.style.opacity = '1';
                    mapsBtn.style.cursor = 'pointer';

                    // Enable Maps button (center panel)
                    const mapsMainBtnInit = document.getElementById('maps-main-btn');
                    if (mapsMainBtnInit) {
                        mapsMainBtnInit.disabled = false;
                        mapsMainBtnInit.style.opacity = '1';
                        mapsMainBtnInit.style.cursor = 'pointer';
                    }
                }

                // Start HP regeneration timer
                startHPRegeneration();
            } else {
                // Show registration modal if no character exists
                registrationModal.style.display = 'flex';
            }

            // Set up event listeners
            setupEventListeners();
        }

        // Save game state to localStorage
        async function saveGameState() {
            const gameData = {
                character: gameState.character,
                inventory: gameState.inventory,
                materials: gameState.materials,
                currency: gameState.currency,
                coins: gameState.coins,
                currentMap: gameState.currentMap,
                bosses: gameState.bosses,
                guild: gameState.guild || null, // Guild membership data
                // Exploration State
                isExploring: gameState.isExploring,
                exploreStartTime: gameState.exploreStartTime,
                exploreDuration: gameState.exploreDuration,
                exploreArea: gameState.exploreArea || null, // Ensure not undefined
                autoPotion: gameState.autoPotion,
                lastSaveTime: Date.now()
            };

            // SIMPLE ANTI-CHEAT: Only detect extreme console manipulation
            // This won't interfere with normal gameplay
            const violations = detectConsoleCheat(gameData);
            if (violations.length > 0) {
                console.error('🚫 CONSOLE CHEAT DETECTED:', violations);

                // Log to Firebase
                for (const violation of violations) {
                    await logCheatAttempt('console_manipulation', violation);
                }

                // Show warning
                addToBattleLog('⚠️ Console manipulation detected. Save blocked.', 'danger');
                return; // Block save
            }

            // Generate checksum
            const checksum = generateChecksum(gameData);

            // Save with checksum
            const saveData = {
                data: gameData,
                checksum: checksum,
                timestamp: Date.now()
            };

            localStorage.setItem('rfOnlineGame', JSON.stringify(saveData));

            // Sync with Firebase
            if (window.saveToFirebase && window.currentUser) {
                console.log('Attempting to sync with Firebase...');
                // Deep clone and sanitize to remove any other undefined values
                const cleanData = JSON.parse(JSON.stringify(gameData));
                window.saveToFirebase(window.currentUser, cleanData);
            } else {
                console.log('Skipping Firebase sync: saveToFirebase or currentUser missing', {
                    hasSaveFn: !!window.saveToFirebase,
                    user: window.currentUser
                });
            }
        }

        // ============================================
        // SECURITY: Data Integrity System
        // ============================================

        // Generate checksum for data validation
        function generateChecksum(data) {
            const str = JSON.stringify(data);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString(36);
        }

        // Validate data integrity
        function validateDataIntegrity(data, checksum) {
            const calculatedChecksum = generateChecksum(data);
            return calculatedChecksum === checksum;
        }

        // Log cheat attempt to Firebase
        async function logCheatAttempt(cheatType, details) {
            if (!window.currentUser) {
                console.warn('Cannot log cheat: No user authenticated');
                return;
            }

            const timestamp = Date.now();
            // Use global Firebase functions exposed in module script
            const db = window.getDatabase ? window.getDatabase() : null;

            if (!db) {
                console.error('❌ Firebase not initialized or not accessible globally');
                return;
            }

            const cheatLogRef = window.ref(db, `cheatLogs/${window.currentUser.uid}/${timestamp}`);

            const logData = {
                userId: window.currentUser.uid,
                email: window.currentUser.email,
                characterName: gameState.character?.name || 'Unknown',
                cheatType: cheatType,
                details: details,
                timestamp: timestamp,
                timestampReadable: new Date(timestamp).toISOString(),
                userAgent: navigator.userAgent,
                screenResolution: `${window.screen.width}x${window.screen.height}`
            };

            try {
                await window.set(cheatLogRef, logData);
                console.error('🚫 CHEAT LOGGED TO FIREBASE:', cheatType, details);
                console.log('📍 Firebase path:', `cheatLogs/${window.currentUser.uid}/${timestamp}`);
            } catch (error) {
                console.error('❌ Failed to log cheat to Firebase:', error);
            }
        }

        // SIMPLE CONSOLE CHEAT DETECTION
        // Only detects extreme, impossible jumps that indicate console manipulation
        // Does NOT interfere with normal gameplay
        function detectConsoleCheat(data) {
            const violations = [];
            const char = data.character;

            if (!char) return violations;

            // Get previous save for comparison
            let previousData = null;
            try {
                const savedGame = localStorage.getItem('rfOnlineGame');
                if (savedGame) {
                    const parsed = JSON.parse(savedGame);
                    previousData = parsed.data || parsed;
                }
            } catch (error) {
                // No previous save, allow
                return violations;
            }

            if (!previousData || !previousData.character) {
                return violations; // First save, allow
            }

            const prevChar = previousData.character;

            // 1. EXTREME level jump (5+ levels at once = console cheat)
            const levelDiff = char.level - prevChar.level;
            if (levelDiff >= 2) {
                violations.push({
                    type: 'extreme_level_jump',
                    before: prevChar.level,
                    after: char.level,
                    difference: levelDiff,
                    reason: `Level jumped ${levelDiff} levels at once (console manipulation)`
                });
            }

            // 2. EXTREME currency jump (100k+ at once = console cheat)
            const currencyDiff = data.currency - previousData.currency;
            if (currencyDiff >= 80000) {
                violations.push({
                    type: 'extreme_currency_jump',
                    before: previousData.currency,
                    after: data.currency,
                    difference: currencyDiff,
                    reason: `Currency jumped by ${currencyDiff} (console manipulation)`
                });
            }

            // 3. EXTREME coins jump (10k+ at once = console cheat)
            const coinsDiff = data.coins - previousData.coins;
            if (coinsDiff >= 5) {
                violations.push({
                    type: 'extreme_coins_jump',
                    before: previousData.coins,
                    after: data.coins,
                    difference: coinsDiff,
                    reason: `Coins jumped by ${coinsDiff} (console manipulation)`
                });
            }

            // 4. EXTREME inventory jump (100+ items at once = console cheat)
            const invDiff = data.inventory.length - previousData.inventory.length;
            if (invDiff >= 30) {
                violations.push({
                    type: 'extreme_inventory_jump',
                    before: previousData.inventory.length,
                    after: data.inventory.length,
                    difference: invDiff,
                    reason: `Inventory jumped by ${invDiff} items (console manipulation)`
                });
            }

            return violations;
        }

        // Modified loadGameState with checksum validation
        function loadGameState() {
            const savedGame = localStorage.getItem('rfOnlineGame');
            if (!savedGame) return null;

            try {
                const saveData = JSON.parse(savedGame);

                // Check if old format (no checksum)
                if (!saveData.checksum) {
                    console.warn('⚠️ Old save format detected. Migrating...');
                    return saveData; // Old format, accept it
                }

                // Validate checksum
                if (!validateDataIntegrity(saveData.data, saveData.checksum)) {
                    console.error('🚫 DATA CORRUPTION DETECTED!');

                    // Log the cheat attempt
                    logCheatAttempt('localStorage_manipulation', {
                        attemptedData: saveData.data,
                        reason: 'Checksum mismatch'
                    });

                    addToBattleLog('⚠️ Save data corruption detected. Loading from cloud...', 'warning');

                    // Clear corrupted local save
                    localStorage.removeItem('rfOnlineGame');

                    // Force reload from Firebase
                    if (window.currentUser) {
                        window.loadFromFirebase(window.currentUser).then(() => {
                            location.reload();
                        });
                    }
                    return null;
                }

                return saveData.data;
            } catch (error) {
                console.error('Failed to load save data:', error);
                return null;
            }
        }

        // Check if boss should respawn
        function checkBossRespawn() {
            Object.values(gameState.bosses).forEach(boss => {
                if (!boss.isAlive && boss.lastDefeated) {
                    const timeSinceDefeat = Date.now() - boss.lastDefeated;
                    const respawnTime = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                    if (timeSinceDefeat >= respawnTime) {
                        // Respawn boss
                        boss.isAlive = true;
                        boss.currentHp = boss.maxHp;
                        boss.lastDefeated = null;
                        addToBattleLog(`👾 ${boss.name} has respawned!`);
                    }
                }
            });
            saveGameState();
        }

        function changeMap(mapName) {
            gameState.currentMap = mapName;
            // Update character location
            if (gameState.character) {
                gameState.character.location = mapName;
                document.getElementById('char-location').textContent = mapName;
            }
            addToBattleLog(`Traveling to ${mapName}...`);

            // Update user's presence in Firebase with new map
            if (window.currentUser && typeof updateUserPresence === 'function') {
                updateUserPresence(window.currentUser, mapName);
            }

            // Update map players display
            updateMapPlayersDisplay();

            // Update map selection UI
            document.querySelectorAll('.map-item').forEach(mapItem => {
                mapItem.style.border = 'none';
            });
            document.getElementById(`${mapName.toLowerCase().replace(' ', '-')}-map`).style.border = '2px solid var(--accent-color)';

            saveGameState();
        }

        // Show maps modal
        function showMaps() {
            updateMapsAccessibility();
            mapsModal.style.display = 'flex';
        }

        // Update maps accessibility based on level
        function updateMapsAccessibility() {
            const char = gameState.character;
            if (!char) return;

            // HQ: Always accessible
            const hqMap = document.getElementById('hq-map');
            if (hqMap) {
                hqMap.classList.add('map-unlocked');


                hqMap.onclick = () => {
                    changeMap('HQ');
                    mapsModal.style.display = 'none';
                };
            }

            // Sette Desert: Level 20+
            const setteMap = document.getElementById('sette-desset-map');
            if (setteMap) {
                if (char.level >= 20) {
                    setteMap.classList.add('map-unlocked');
                    setteMap.style.opacity = '1';
                    setteMap.style.cursor = 'pointer';


                    setteMap.onclick = () => {
                        changeMap('Sette Desert');
                        mapsModal.style.display = 'none';
                    };
                    const levelText = setteMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.style.color = 'var(--success)';
                        levelText.textContent = 'Level 20+ (Unlocked)';
                    }
                } else {
                    setteMap.classList.remove('map-unlocked');
                    setteMap.style.opacity = '0.5';
                    setteMap.style.cursor = 'not-allowed';
                    setteMap.onclick = null;
                    const levelText = setteMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.style.color = 'var(--text-dim)';
                        levelText.textContent = 'Level 20+ (Locked)';
                    }
                }
            }

            // Ether Platform: Level 30+
            const etherMap = document.getElementById('ether-platform-map');
            if (etherMap) {
                if (char.level >= 30) {
                    etherMap.classList.add('map-unlocked');
                    etherMap.style.opacity = '1';
                    etherMap.style.cursor = 'pointer';


                    etherMap.onclick = () => {
                        // Check for travel cost (1000 Leaves)
                        if (gameState.currentMap === 'Ether Platform') {
                            addToBattleLog('You are already at Ether Platform.', 'warning');
                            return;
                        }

                        if (gameState.currency >= 1000) {
                            if (confirm('Travel to Ether Platform? Cost: 1000 Leaves')) {
                                gameState.currency -= 1000;
                                document.getElementById('currency-amount').textContent = gameState.currency;
                                changeMap('Ether Platform');
                                mapsModal.style.display = 'none';
                            }
                        } else {
                            addToBattleLog('Not enough Leaves to travel to Ether Platform (Cost: 1000).', 'warning');
                        }
                    };
                    const levelText = etherMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.innerHTML = 'Level 30+ <span style="color: var(--success); font-size: 0.8rem;">(Unlocked)</span>';
                    }
                } else {
                    etherMap.classList.remove('map-unlocked');
                    etherMap.style.opacity = '0.5';
                    etherMap.style.cursor = 'not-allowed';
                    etherMap.onclick = null;
                    const levelText = etherMap.querySelector('.map-level');
                    if (levelText) {
                        levelText.innerHTML = 'Level 30+ <span style="color: var(--text-dim); font-size: 0.8rem;">(Locked)</span>';
                    }
                }
            }

            // Volcanic Cauldron: Level 40+ (Coming Soon - visual teaser only)
            const volcanicMap = document.getElementById('volcanic-cauldron-map');
            if (volcanicMap) {
                // Always show as disabled teaser
                volcanicMap.classList.remove('map-unlocked');
                volcanicMap.style.opacity = '0.5';
                volcanicMap.style.cursor = 'default';
                volcanicMap.onclick = null; // No click handler - just visual

                const levelText = volcanicMap.querySelector('.map-level');
                if (levelText) {
                    levelText.innerHTML = 'Level 40+ <span style="color: var(--danger); font-size: 0.8rem;">(Coming Soon)</span>';
                }
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Race selection
            document.querySelectorAll('.race-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.race-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');

                    const race = option.getAttribute('data-race');

                    // Update gender selection visibility
                    const genderSelection = document.getElementById('gender-selection');
                    if (race === 'Accretia') {
                        genderSelection.style.display = 'none';
                        // Clear any selected gender
                        document.querySelectorAll('.gender-option').forEach(g => g.classList.remove('selected'));
                    } else {
                        genderSelection.style.display = 'block';
                    }

                    // Update class options
                    updateClassOptions(race);
                });
            });

            // Gender selection
            document.querySelectorAll('.gender-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.gender-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                });
            });

            // Class selection
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('class-option')) {
                    document.querySelectorAll('.class-option').forEach(o => o.classList.remove('selected'));
                    e.target.classList.add('selected');
                }
            });

            // Create character button
            createCharacterBtn.addEventListener('click', createCharacter);

            // Explore button
            exploreBtn.addEventListener('click', () => {
                const isVisible = exploreOptions.style.display === 'flex';
                exploreOptions.style.display = isVisible ? 'none' : 'flex';

                // Show/hide appropriate buttons based on current map
                if (!isVisible) {
                    const isEtherPlatform = gameState.currentMap === 'Ether Platform';
                    document.querySelectorAll('.time-based-explore').forEach(el => {
                        el.style.display = isEtherPlatform ? 'none' : 'block';
                    });
                    document.querySelectorAll('.area-based-explore').forEach(el => {
                        el.style.display = isEtherPlatform ? 'block' : 'none';
                    });
                }
            });

            // Time-based exploration buttons (HQ, Sette Desert)
            document.getElementById('explore-30').addEventListener('click', () => startExploration(30));
            document.getElementById('explore-60').addEventListener('click', () => startExploration(60));
            document.getElementById('explore-360').addEventListener('click', () => startExploration(360));
            document.getElementById('explore-720').addEventListener('click', () => startExploration(720));

            // Area-based exploration buttons (Ether Platform)
            document.getElementById('explore-wharf').addEventListener('click', () => startExploration('Wharf'));
            document.getElementById('explore-white-hole').addEventListener('click', () => startExploration('White Hole'));
            document.getElementById('explore-lures-lot').addEventListener('click', () => startExploration('Lures Lot'));

            // Stop button
            stopBtn.addEventListener('click', stopExploration);

            // Players button
            if (playersBtn) {
                playersBtn.addEventListener('click', showPlayers);
            }

            // Maps button (navigation)
            mapsBtn.addEventListener('click', showMaps);

            // Market button
            const marketBtn = document.getElementById('market-btn');
            if (marketBtn) {
                marketBtn.addEventListener('click', showMarket);
            }

            // Arena button
            const arenaBtn = document.getElementById('arena-btn');
            if (arenaBtn) {
                arenaBtn.addEventListener('click', showArena);
            }

            // Shop button
            const shopBtn = document.getElementById('shop-btn');
            if (shopBtn) {
                shopBtn.addEventListener('click', showShop);
            }

            // Market confirm sell button
            const confirmSellBtn = document.getElementById('confirm-sell-btn');
            if (confirmSellBtn) {
                confirmSellBtn.addEventListener('click', confirmSell);
            }

            // Clean up presence when user leaves
            window.addEventListener('beforeunload', () => {
                if (window.currentUser) {
                    try {
                        // Try Firebase cleanup first
                        const presenceRef = ref(db, `publicPresence/${window.currentUser.uid}`);
                        set(presenceRef, null).catch(() => {
                            // Firebase cleanup failed, try localStorage
                            const allPresence = JSON.parse(localStorage.getItem('playerPresence') || '{}');
                            delete allPresence[window.currentUser.uid];
                            localStorage.setItem('playerPresence', JSON.stringify(allPresence));
                        });
                    } catch (error) {
                        console.error('Error cleaning up presence:', error);
                    }
                }
            });

            // Maps button (center panel)
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.addEventListener('click', showMaps);
            }

            // Craft button
            craftBtn.addEventListener('click', openCraftingModal);
            craftCancelBtn.addEventListener('click', closeCraftingModal);

            // Craft tab event listeners
            document.querySelectorAll('.craft-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.craft-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentCategory = tab.dataset.category;
                    renderRecipes(tab.dataset.category);
                });
            });
            craftConfirmBtn.addEventListener('click', async () => {
                // 1. Add pulsing class and disable
                craftConfirmBtn.classList.add('btn-pulsing');
                craftConfirmBtn.disabled = true;

                // 2. Wait 2 seconds (3 pulses)
                await new Promise(resolve => setTimeout(resolve, 2000));

                // 3. Remove pulsing class
                craftConfirmBtn.classList.remove('btn-pulsing');

                // 4. Execute logic
                craftItem();

                // 5. Change to "Crafted!" and Green
                // Note: craftItem checks for selectedRecipe, so we should only change UI if successful?
                // But craftItem doesn't return success/fail. It checks inside.
                // We'll assume if it runs, it was clickable (enabled).
                if (selectedRecipe) {
                    craftConfirmBtn.textContent = "Crafted!";
                    craftConfirmBtn.classList.add('btn-success');

                    // Reset after 2 seconds
                    setTimeout(() => {
                        craftConfirmBtn.textContent = "Craft";
                        craftConfirmBtn.classList.remove('btn-success');
                        craftConfirmBtn.disabled = false; // Re-enable
                        // Re-check requirements to set disabled state correctly
                        if (selectedRecipe) selectRecipe(selectedRecipe);
                    }, 2000);
                }
            });

            // Sell All button
            const sellAllBtn = document.getElementById('sell-all-btn');
            if (sellAllBtn) {
                sellAllBtn.addEventListener('click', sellAllUnequippedItems);
            }


            // Upgrade buttons
            upgradeConfirmBtn.addEventListener('click', async () => {
                // 1. Add pulsing class and disable
                upgradeConfirmBtn.classList.add('btn-pulsing');
                upgradeConfirmBtn.disabled = true;
                const originalText = upgradeConfirmBtn.textContent;

                // 2. Wait 2 seconds (3 pulses)
                await new Promise(resolve => setTimeout(resolve, 2000));

                // 3. Remove pulsing class and re-enable
                upgradeConfirmBtn.classList.remove('btn-pulsing');
                upgradeConfirmBtn.disabled = false;

                // 4. Execute logic
                confirmUpgrade();
            });
            upgradeCancelBtn.addEventListener('click', () => {
                upgradeModal.style.display = 'none';
                currentUpgradeItem = null;
            });

            // Logout button
            const authBtn = document.getElementById('auth-btn');
            if (authBtn) {
                authBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to logout?')) {
                        // Sign out from Firebase
                        import('https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js')
                            .then(({ getAuth, signOut }) => {
                                const auth = getAuth();
                                signOut(auth).then(() => {
                                    window.location.href = 'index.html';
                                });
                            });
                    }
                });
            }


            // Instant finish button
            // Instant finish button - REMOVED (Element missing)
            // document.getElementById('instant-finish-btn')?.addEventListener('click', instantFinishExploration);

            // Global click listener for modals
            window.addEventListener('click', (e) => {
                if (e.target === registrationModal) {
                    // Prevent closing registration modal by clicking outside
                } else if (e.target === playersModal) {
                    playersModal.style.display = 'none';
                } else if (e.target === mapsModal) {
                    mapsModal.style.display = 'none';
                } else if (e.target === marketModal) {
                    marketModal.style.display = 'none';
                } else if (e.target === document.getElementById('arena-modal')) {
                    document.getElementById('arena-modal').style.display = 'none';
                } else if (e.target === upgradeModal) {
                    upgradeModal.style.display = 'none';
                } else if (e.target === craftingModal) {
                    craftingModal.style.display = 'none';
                } else if (e.target === document.getElementById('guild-modal')) {
                    document.getElementById('guild-modal').style.display = 'none';
                }
            });

            // Close buttons
            document.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', () => {
                    playersModal.style.display = 'none';
                    mapsModal.style.display = 'none';
                    upgradeModal.style.display = 'none';
                    craftingModal.style.display = 'none';
                });
            });

            // Mobile Tab Switching Logic
            window.switchTab = function (tabName) {
                // Map tab names to IDs if necessary, or assume direct mapping
                // Buttons have data-tab="character", "battle", "inventory"
                // Panels have id="panel-character", "panel-battle", "panel-inventory"

                // Normalize tab name
                let normalizedTab = tabName;
                if (tabName === 'log-panel') normalizedTab = 'battle'; // Handle legacy/alias

                let targetId = 'panel-' + normalizedTab;

                // Only apply tab switching on mobile
                if (window.innerWidth <= 720) {
                    // 1. Update buttons
                    document.querySelectorAll('.mobile-tab-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.tab === normalizedTab);
                    });

                    // 2. Update panels using active-mobile class (works with CSS)
                    document.querySelectorAll('.mobile-tab-panel').forEach(panel => {
                        panel.classList.toggle('active-mobile', panel.id === targetId);
                    });
                }
            }

            // Bind click events to mobile tab buttons
            document.querySelectorAll('.mobile-tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    switchTab(btn.dataset.tab);
                });
            });
        }

        // Update class options based on selected race
        function updateClassOptions(race) {
            const classOptions = document.getElementById('class-options');
            classOptions.innerHTML = '';

            raceClasses[race].forEach(className => {
                const classOption = document.createElement('div');
                classOption.className = 'class-option';
                classOption.textContent = className;
                classOptions.appendChild(classOption);
            });
        }

        // Create a new character
        async function createCharacter() {
            const nameInput = document.getElementById('char-name-input');
            const selectedRace = document.querySelector('.race-option.selected');
            const selectedGender = document.querySelector('.gender-option.selected');
            const selectedClass = document.querySelector('.class-option.selected');

            // Check if Accretia race (no gender required)
            const isAccretia = selectedRace && selectedRace.getAttribute('data-race') === 'Accretia';

            if (nameInput.value.length > 16) {
                alert('Character name must be 16 characters or less.');
                return;
            }

            if (!nameInput.value || !selectedRace || !selectedClass ||
                (!isAccretia && !selectedGender)) {
                alert('Please fill in all character details.');
                return;
            }

            const characterName = nameInput.value.trim();

            // Check for duplicate names (case-insensitive)
            try {
                // Check if Firebase is available
                if (!window.getDatabase || !window.ref || !window.get || !window.set) {
                    console.error('Firebase functions not available');
                    alert('Unable to check name availability. Please try again in a moment.');
                    return;
                }

                // Check if user is authenticated
                if (!window.currentUser?.uid) {
                    console.error('User not authenticated');
                    alert('You must be logged in to create a character.');
                    return;
                }

                // Normalize name for case-insensitive comparison (lowercase, no spaces)
                const normalizedName = characterName.toLowerCase().replace(/\s+/g, '');
                console.log('Checking name:', characterName, 'normalized:', normalizedName);

                const db = window.getDatabase();
                const nameRef = window.ref(db, `characterNames/${normalizedName}`);
                const nameSnapshot = await window.get(nameRef);

                console.log('Name check result:', nameSnapshot.exists() ? 'exists' : 'available');

                if (nameSnapshot.exists()) {
                    const existingNameData = nameSnapshot.val();
                    console.log('Name already exists:', existingNameData);
                    console.log('Existing UID:', existingNameData.uid);
                    console.log('Current UID:', window.currentUser.uid);
                    console.log('UIDs match:', existingNameData.uid === window.currentUser.uid);

                    // Block ALL duplicate names - no exceptions for character creation
                    console.log('BLOCKING: Name already taken');
                    alert('This character name is already taken. Please choose a different name.');
                    return;
                } else {
                    console.log('ALLOWING: Name is available');
                }

                const race = selectedRace.getAttribute('data-race');
                const gender = isAccretia ? 'None' : selectedGender.getAttribute('data-gender');
                const charClass = selectedClass.textContent;

                // Create character object
                gameState.character = {
                    name: characterName,
                    race: race,
                    gender: gender,
                    class: charClass,
                    level: 1,
                    exp: 0,
                    maxExp: 100,
                    hp: classStats[charClass].hp,
                    maxHp: classStats[charClass].hp,
                    fp: classStats[charClass].fp,
                    maxFp: classStats[charClass].fp,
                    attack: classStats[charClass].attack,
                    defense: classStats[charClass].defense,
                    location: `${race} HQ`,
                    equipped: {
                        weapon: null,
                        armor: null,
                        accessory1: null,
                        accessory2: null,
                        wings: null  // Dedicated Wings slot
                    },
                    criticalChance: classStats[charClass].criticalChance || 0.05
                };

                // Register the name in Firebase (case-insensitive index)
                if (window.currentUser) {
                    await window.set(nameRef, {
                        uid: window.currentUser.uid,
                        name: characterName,
                        createdAt: Date.now()
                    });
                }

                // Save game state
                saveGameState();

                // Update display and close modal
                updateCharacterDisplay();
                registrationModal.style.display = 'none';

                // Start HP regeneration timer
                startHPRegeneration();

                // Add welcome message to battle log
                addToBattleLog(`Welcome, ${gameState.character.name}! Your journey begins at ${gameState.character.location}.`);

            } catch (error) {
                console.error('Error checking/registering character name:', error);
                alert('Failed to create character. Please try again.');
            }
        }

        // Update character display
        function updateCharacterDisplay() {
            const char = gameState.character;
            if (!char) return;

            sanitizeStats();

            document.getElementById('char-name').textContent = char.name;
            document.getElementById('char-race').textContent = char.race;
            document.getElementById('char-gender').textContent = char.gender;
            document.getElementById('char-class').textContent = char.class;
            // Update guild display
            const guildDisplay = document.getElementById('char-guild');
            if (gameState.guild && gameState.guild.guildName) {
                guildDisplay.textContent = gameState.guild.guildName;
            } else {
                guildDisplay.textContent = '-';
            }
            // Use currentMap as the source of truth for location
            document.getElementById('char-location').textContent = gameState.currentMap || char.location;
            document.getElementById('char-level').textContent = char.level;
            document.getElementById('char-hp').textContent = char.hp;
            document.getElementById('char-fp').textContent = char.fp;
            // Use effective stats including accessory bonuses
            const effectiveStats = calculateEffectiveStats();
            document.getElementById('char-attack').textContent = effectiveStats.attack;
            document.getElementById('char-defense').textContent = effectiveStats.defense;
            document.getElementById('char-crit').textContent = Math.floor((char.criticalChance || 0.05) * 100) + '%';

            // Update EXP text display
            document.getElementById('char-exp').textContent = `${char.exp}/${char.maxExp}`;

            // Update Lifesteal Display
            const lifestealContainer = document.getElementById('lifesteal-stat-container');
            const lifestealValue = document.getElementById('char-lifesteal');

            if (char.equipped.weapon && char.equipped.weapon.lifesteal) {
                lifestealContainer.style.display = 'flex';
                lifestealValue.textContent = `${Math.round(char.equipped.weapon.lifesteal.chance * 100)}%`;
            } else {
                lifestealContainer.style.display = 'none';
            }

            // Update Damage Reduction Display
            const dmgRedContainer = document.getElementById('dmg-red-stat-container');
            const dmgRedValue = document.getElementById('char-dmg-red');

            if (char.equipped.armor && char.equipped.armor.damageReduction) {
                dmgRedContainer.style.display = 'flex';
                dmgRedValue.textContent = `${Math.round(char.equipped.armor.damageReduction * 100)}%`;
            } else {
                dmgRedContainer.style.display = 'none';
            }

            // Update Speed Display (Movement Speed from Wings)
            const speedContainer = document.getElementById('speed-stat-container');
            const speedValue = document.getElementById('char-speed');

            let totalMovementSpeed = 0;
            if (char.equipped.accessory1?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory1.movementSpeed;
            }
            if (char.equipped.accessory2?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory2.movementSpeed;
            }
            if (char.equipped.wings?.movementSpeed) {
                totalMovementSpeed += char.equipped.wings.movementSpeed;
            }

            if (totalMovementSpeed > 0) {
                speedContainer.style.display = 'flex';
                speedValue.textContent = totalMovementSpeed;
            } else {
                speedContainer.style.display = 'none';
            }

            // Update progress bars
            document.querySelector('.exp-bar').style.width = `${(char.exp / char.maxExp) * 100}%`;
            document.querySelector('.hp-bar').style.width = `${(char.hp / char.maxHp) * 100}%`;
            document.querySelector('.fp-bar').style.width = `${(char.fp / char.maxFp) * 100}%`;

            // Update Skills Display
            const mySkills = classSkills[char.class] || [];
            const basicSkill = mySkills.find(s => s.type === 'Basic');
            const expertSkill = mySkills.find(s => s.type === 'Expert');
            const eliteSkill = mySkills.find(s => s.type === 'Elite');
            const ultimateSkill = mySkills.find(s => s.type === 'Ultimate');

            const basicEl = document.getElementById('skill-basic');
            const expertEl = document.getElementById('skill-expert');
            const eliteEl = document.getElementById('skill-elite');
            const ultimateEl = document.getElementById('skill-ultimate');

            if (basicSkill) {
                if (char.level >= basicSkill.level) {
                    basicEl.textContent = basicSkill.name;
                    basicEl.className = 'skill-value unlocked';
                } else {
                    basicEl.textContent = `Unlocks at Lv${basicSkill.level}`;
                    basicEl.className = 'skill-value locked';
                }
            }

            if (expertSkill) {
                if (char.level >= expertSkill.level) {
                    expertEl.textContent = expertSkill.name;
                    expertEl.className = 'skill-value unlocked';
                } else {
                    expertEl.textContent = `Unlocks at Lv${expertSkill.level}`;
                    expertEl.className = 'skill-value locked';
                }
            }

            if (eliteSkill) {
                if (char.level >= eliteSkill.level) {
                    eliteEl.textContent = eliteSkill.name;
                    eliteEl.className = 'skill-value unlocked';
                } else {
                    eliteEl.textContent = `Unlocks at Lv${eliteSkill.level}`;
                    eliteEl.className = 'skill-value locked';
                }
            }

            if (ultimateSkill) {
                if (char.level >= ultimateSkill.level) {
                    ultimateEl.textContent = ultimateSkill.name;
                    ultimateEl.className = 'skill-value unlocked';
                } else {
                    ultimateEl.textContent = `Unlocks at Lv${ultimateSkill.level}`;
                    ultimateEl.className = 'skill-value locked';
                }
            }

            // Update maps accessibility
            updateMapsAccessibility();
        }


        // Update maps accessibility based on level
        // Update maps accessibility based on level
        function updateMapsAccessibility() {
            const hqMap = document.getElementById('hq-map');
            const setteMap = document.getElementById('sette-desset-map');
            const etherMap = document.getElementById('ether-platform-map');

            // Reset styles
            hqMap.style.border = 'none';
            setteMap.style.border = 'none';
            etherMap.style.border = 'none';

            // Highlight current map
            if (gameState.currentMap === 'HQ') {
                hqMap.style.border = '2px solid var(--accent-color)';
            } else if (gameState.currentMap === 'Sette Desert') {
                setteMap.style.border = '2px solid var(--accent-color)';
            } else if (gameState.currentMap === 'Ether Platform') {
                etherMap.style.border = '2px solid var(--accent-color)';
            }

            // HQ Click Handler
            hqMap.onclick = async () => {
                if (gameState.currentMap !== 'HQ') {
                    // Special check for Ether Platform return - NO PULSE
                    if (gameState.currentMap === 'Ether Platform') {
                        if (gameState.currency >= 1000) {
                            if (confirm("Purchase a ticket to HQ for 1,000 Leaves? (Travel time: 2 mins)")) {
                                gameState.currency -= 1000;
                                document.getElementById('currency-amount').textContent = gameState.currency;
                                mapsModal.style.display = 'none';
                                startHQTravel();
                            }
                        } else {
                            addToBattleLog('You need 1,000 Leaves to buy a ticket to HQ.', 'warning');
                        }
                        return;
                    }

                    // Standard instant travel for other maps (e.g. Sette) - WITH PULSE
                    // Add pulsing and disable all maps
                    hqMap.classList.add('btn-pulsing');
                    setteMap.style.pointerEvents = 'none';
                    etherMap.style.pointerEvents = 'none';
                    hqMap.style.pointerEvents = 'none';

                    // Wait 2 seconds (3 pulses)
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Remove pulsing
                    hqMap.classList.remove('btn-pulsing');
                    setteMap.style.pointerEvents = '';
                    etherMap.style.pointerEvents = '';
                    hqMap.style.pointerEvents = '';

                    gameState.currentMap = 'HQ';
                    document.getElementById('char-location').textContent = gameState.currentMap;
                    addToBattleLog('Traveled to HQ.');
                    mapsModal.style.display = 'none';
                    updateMapsAccessibility();
                    saveGameState();
                }
            };
            // Sette Desert Logic
            if (gameState.currentMap === 'Ether Platform') {
                setteMap.style.opacity = '0.5';
                setteMap.style.cursor = 'not-allowed';
                setteMap.onclick = () => {
                    addToBattleLog('You cannot travel directly to Sette Desert from Ether Platform.', 'warning');
                };
            } else {
                setteMap.style.opacity = '1';
                setteMap.style.cursor = 'pointer';

                setteMap.onclick = async () => {
                    if (gameState.currentMap !== 'Sette Desert') {
                        if (gameState.character.level >= 20) {
                            // Add pulsing and disable all maps
                            setteMap.classList.add('btn-pulsing');
                            hqMap.style.pointerEvents = 'none';
                            etherMap.style.pointerEvents = 'none';
                            setteMap.style.pointerEvents = 'none';

                            // Wait 2 seconds (3 pulses)
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            // Remove pulsing
                            setteMap.classList.remove('btn-pulsing');
                            hqMap.style.pointerEvents = '';
                            etherMap.style.pointerEvents = '';
                            setteMap.style.pointerEvents = '';

                            // Execute travel
                            gameState.currentMap = 'Sette Desert';
                            document.getElementById('char-location').textContent = gameState.currentMap;
                            addToBattleLog('Traveled to Sette Desert.');
                            mapsModal.style.display = 'none';
                            updateMapsAccessibility();
                            saveGameState();
                        } else {
                            addToBattleLog('You need to be Level 20 to enter Sette Desert.', 'warning');
                        }
                    }
                };
            }

            // Ether Platform Click Handler
            if (gameState.currentMap === 'Sette Desert') {
                etherMap.style.opacity = '0.5';
                etherMap.style.cursor = 'not-allowed';
                etherMap.onclick = () => {
                    addToBattleLog('You cannot travel directly to Ether Platform from Sette Desert.', 'warning');
                };
            } else {
                etherMap.style.opacity = '1';
                etherMap.style.cursor = 'pointer';

                etherMap.onclick = () => {
                    if (gameState.currentMap !== 'Ether Platform') {
                        if (gameState.currentMap !== 'HQ') {
                            addToBattleLog('You can only take the ship to Ether Platform from HQ.', 'warning');
                            return;
                        }

                        if (gameState.character.level >= 30) {
                            if (gameState.currency >= 1000) {
                                // NO PULSE - Direct confirmation
                                if (confirm("Purchase a ticket to Ether Platform for 1,000 Leaves? (Travel time: 2 mins)")) {
                                    gameState.currency -= 1000;
                                    document.getElementById('currency-amount').textContent = gameState.currency;
                                    mapsModal.style.display = 'none';
                                    startEtherTravel();
                                }
                            } else {
                                addToBattleLog('You need 1,000 Leaves to buy a ticket to Ether Platform.', 'warning');
                            }
                        } else {
                            addToBattleLog('You need to be Level 30 to enter Ether Platform.', 'warning');
                        }
                    }
                };
            }
        }

        // Flat EXP system for balanced monster rewards
        function getMonsterExpGain(monsterName, monster) {
            // HQ Monsters: 10-100 EXP (current values)
            const hqExpValues = {
                'Young Flym': 10,
                'Wing': 20,
                'Flym': 25,
                'Stinkbug': 30,
                'Desert Klan': 35,
                'Demolis': 40,
                'Splinter Brat': 45,
                'Lunker': 50,
                'Warbeast': 55,
                'Ratmoth': 60,
                'Snatcher Cheat': 65,
                'Splinter': 70,
                'Arghol Wasp': 90
            };

            // Sette Desert Monsters: 100-200 EXP
            const setteExpValues = {
                'Bulky Lunker': 100,
                'Ghost': 120,
                'Ghost II': 125,
                'Rigor Lapis': 130,
                'Rigor Lapis II': 135,
                'Grumble Hook': 140,
                'Grumble Hook II': 145,
                'Turncoat': 150,
                'Turncoat II': 155,
                'Turncoat III': 160,
                'Turncoat Knight': 180
            };

            // Ether Platform Monsters: 200-400 EXP
            const etherExpValues = {
                'Chooty': 180,
                'Hobo Mite': 185,
                'Hobo Sword': 185,
                'Hobo Turnpike': 195,
                'Hobo Cutter': 195,
                'Passer Alpha': 210,
                'Hobo Robber': 230,
                'Hobo Blade': 230,
                'Passer Beta': 240,
                'Calliana Atroc': 250,
                'Calliana Crew': 250,
                'Assassin Builder B': 270,
                'Calliana Princess': 300
            };

            // Return EXP based on monster name (works for all maps)
            if (hqExpValues[monsterName]) return hqExpValues[monsterName];
            if (setteExpValues[monsterName]) return setteExpValues[monsterName];
            if (etherExpValues[monsterName]) return etherExpValues[monsterName];

            // Fallback for unknown monsters
            return 100;
        }

        // Handle Ship Travel
        function startEtherTravel() {
            gameState.isTraveling = true;

            // Disable controls
            exploreBtn.disabled = true;
            mapsBtn.disabled = true;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }
            exploreBtn.style.opacity = '0.5';
            exploreBtn.style.cursor = 'not-allowed';
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            addToBattleLog("Ticket purchased. Boarding the transport ship...", "info");

            // Show travel status
            exploreStatus.style.display = 'flex';
            document.getElementById('explore-selected-time').textContent = "Traveling to Ether";

            let timeLeft = 120; // 2 minutes
            addToBattleLog(`🛫 Ship departs! Estimated travel time: 2 minutes.`);

            const travelTimer = setInterval(() => {
                timeLeft--;
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                exploreTimer.textContent = `Arriving in ${mins}:${secs.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(travelTimer);
                    completeEtherTravel();
                }
            }, 1000);
        }

        function completeEtherTravel() {
            gameState.isTraveling = false;
            gameState.currentMap = 'Ether Platform';

            // Reset UI
            exploreStatus.style.display = 'none';
            exploreBtn.disabled = false;
            mapsBtn.disabled = false;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = false;
                mapsMainBtn.style.opacity = '1';
                mapsMainBtn.style.cursor = '';
            }
            exploreBtn.style.opacity = '1';
            exploreBtn.style.cursor = '';
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = '';

            addToBattleLog("You have arrived at Ether Platform.", "success");

            // Update UI
            updateMapsAccessibility();
            document.getElementById('char-location').textContent = gameState.currentMap;
            saveGameState();
        }

        // Handle HQ Travel (Return trip)
        function startHQTravel() {
            gameState.isTraveling = true;

            // Disable controls
            exploreBtn.disabled = true;
            mapsBtn.disabled = true;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }
            exploreBtn.style.opacity = '0.5';
            exploreBtn.style.cursor = 'not-allowed';
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            addToBattleLog("Ticket purchased. Boarding the transport ship to HQ...", "info");

            // Show travel status
            exploreStatus.style.display = 'flex';
            document.getElementById('explore-selected-time').textContent = "Traveling to HQ";

            let timeLeft = 120; // 2 minutes
            addToBattleLog(`🛫 Ship departs! Estimated travel time: 2 minutes.`);

            const travelTimer = setInterval(() => {
                timeLeft--;
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                exploreTimer.textContent = `Arriving in ${mins}:${secs.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(travelTimer);
                    completeHQTravel();
                }
            }, 1000);
        }

        function completeHQTravel() {
            gameState.isTraveling = false;
            gameState.currentMap = 'HQ';

            // Reset UI
            exploreStatus.style.display = 'none';
            exploreBtn.disabled = false;
            mapsBtn.disabled = false;
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = false;
                mapsMainBtn.style.opacity = '1';
                mapsMainBtn.style.cursor = '';
            }
            exploreBtn.style.opacity = '1';
            exploreBtn.style.cursor = '';
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = '';

            addToBattleLog("You have arrived at HQ.", "success");

            // Update UI
            updateMapsAccessibility();
            document.getElementById('char-location').textContent = gameState.currentMap;
            saveGameState();
        }

        // Show maps modal
        function showMaps() {
            // Hide explore options when Maps is opened
            exploreOptions.style.display = 'none';
            updateMapsAccessibility();
            mapsModal.style.display = 'flex';

            // Add hover effects to all unlocked maps
            console.log('showMaps called, adding hover effects');
            const char = gameState.character;
            if (char) {
                // HQ - always unlocked
                const hqMap = document.getElementById('hq-map');
                if (hqMap) {
                    hqMap.style.transition = 'all 0.1s ease';
                    hqMap.addEventListener('mouseenter', () => {
                        console.log('Hovering HQ');
                        hqMap.style.opacity = '0.7';
                        hqMap.style.transform = 'translateY(-1px)';
                    });
                    hqMap.addEventListener('mouseleave', () => {
                        hqMap.style.opacity = '1';
                        hqMap.style.transform = 'translateY(0)';
                    });
                }

                // Sette Desert - level 20+ AND not in Ether Platform
                if (char.level >= 20 && gameState.currentMap !== 'Ether Platform') {
                    const setteMap = document.getElementById('sette-desset-map');
                    if (setteMap) {
                        setteMap.style.transition = 'all 0.1s ease';
                        setteMap.addEventListener('mouseenter', () => {
                            console.log('Hovering Sette');
                            setteMap.style.opacity = '0.7';
                            setteMap.style.transform = 'translateY(-1px)';
                        });
                        setteMap.addEventListener('mouseleave', () => {
                            setteMap.style.opacity = '1';
                            setteMap.style.transform = 'translateY(0)';
                        });
                    }
                }

                // Ether Platform - level 30+ AND not in Sette Desert
                if (char.level >= 30 && gameState.currentMap !== 'Sette Desert') {
                    const etherMap = document.getElementById('ether-platform-map');
                    if (etherMap) {
                        etherMap.style.transition = 'all 0.1s ease';
                        etherMap.addEventListener('mouseenter', () => {
                            console.log('Hovering Ether');
                            etherMap.style.opacity = '0.7';
                            etherMap.style.transform = 'translateY(-1px)';
                        });
                        etherMap.addEventListener('mouseleave', () => {
                            etherMap.style.opacity = '1';
                            etherMap.style.transform = 'translateY(0)';
                        });
                    }
                }
            }
        }




        // Update encounter tracker display
        function updateEncounterDisplay() {
            const encounterList = document.getElementById('encounter-list');
            const encounterTracker = document.getElementById('encounter-tracker');

            // Show tracker if has encounters (even after exploration ends)
            if (Object.keys(gameState.encounterStats).length > 0) {
                encounterTracker.style.display = 'block';
            } else {
                encounterTracker.style.display = 'none';
                return;
            }

            // Sort by count (descending)
            const sorted = Object.entries(gameState.encounterStats)
                .sort((a, b) => b[1] - a[1]);

            // Build HTML
            encounterList.innerHTML = sorted.map(([name, count]) => `
                <div class="encounter-item">
                    <span class="encounter-name">${name}</span>
                    <span class="encounter-count">×${count}</span>
                </div>
            `).join('');
        }

        // Get boss name for current map
        function getMapBossName() {
            const mapBosses = {
                "HQ": "Arghol Wasp",
                "Sette Desert": "Turncoat Knight",
                "Ether Platform": "Calliana Princess"
            };
            return mapBosses[gameState.currentMap] || null;
        }

        // Check for boss encounter (called after 5 minutes in 12h exploration)
        function checkBossEncounter() {
            if (!gameState.isExploring) return;
            if (gameState.bossEncountered) return; // Already encountered

            const mapBossName = getMapBossName();
            if (!mapBossName) {
                console.log("No boss for this map");
                return;
            }

            const mapBoss = gameState.bosses[mapBossName];
            if (!mapBoss || !mapBoss.isAlive) {
                console.log("Boss is dead or missing:", mapBossName);
                return;
            }

            // 100% guaranteed boss encounter
            gameState.bossEncounterQueued = true;
            gameState.bossEncountered = true;
            console.log("Boss encounter queued:", mapBossName);
            addToBattleLog(`⚠️ You sense a powerful presence nearby...`, 'warning');
        }


        // Start exploration
        function startExploration(param) {
            if (gameState.isExploring) {
                addToBattleLog('You are already exploring!');
                return;
            }

            exploreOptions.style.display = 'none';
            gameState.isExploring = true;

            // Determine if this is time-based or area-based exploration
            const isAreaBased = typeof param === 'string';
            let minutes, area, displayText;

            if (isAreaBased) {
                // Area-based exploration (Ether Platform)
                area = param;
                minutes = 720; // Fixed 12 hours for all areas
                displayText = area;
                gameState.exploreArea = area;
            } else {
                // Time-based exploration (HQ, Sette Desert)
                minutes = param;
                area = null;
                gameState.exploreArea = null;
                if (minutes < 60) {
                    displayText = `${minutes}m`;
                } else {
                    displayText = `${minutes / 60}h`;
                }
            }

            gameState.exploreDuration = minutes * 60 * 1000;
            gameState.exploreStartTime = Date.now();

            // Reset boss flags and encounter stats
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            // Show stop button and hide explore button
            exploreBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            exploreStatus.style.display = 'flex';

            // Disable Maps button
            mapsBtn.disabled = true;
            mapsBtn.style.opacity = '0.5';
            mapsBtn.style.cursor = 'not-allowed';

            // Disable Maps button (center panel)
            const mapsMainBtn = document.getElementById('maps-main-btn');
            if (mapsMainBtn) {
                mapsMainBtn.disabled = true;
                mapsMainBtn.style.opacity = '0.5';
                mapsMainBtn.style.cursor = 'not-allowed';
            }

            document.getElementById('explore-selected-time').textContent = `Explore Time: ${displayText}`;
            exploreTimer.textContent = "Elapsed 0:00"; // Initial state

            if (isAreaBased) {
                addToBattleLog(`You start exploring ${area}...`);
            } else {
                addToBattleLog(`You start exploring for ${minutes < 60 ? minutes + ' minutes' : minutes / 60 + ' hours'}...`);
            }

            // Reset boss flags
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;

            // Start boss check timer for 12h explorations (HQ, Sette Desert) or Lures Lot area
            if (minutes === 720 && !isAreaBased) {
                // Time-based 12h exploration (HQ, Sette Desert)
                gameState.bossCheckTimer = setTimeout(checkBossEncounter, 5 * 60 * 1000);
            } else if (area === 'Lures Lot') {
                // Area-based Lures Lot - Calliana Princess after 5 minutes
                gameState.bossCheckTimer = setTimeout(checkBossEncounter, 5 * 60 * 1000);
            }

            // Start battle timer after 30 seconds
            setTimeout(() => {
                if (gameState.isExploring) {
                    addToBattleLog('You venture deeper into the wilderness...');
                    startBattles();
                }
            }, 30 * 1000);

            // Update explore timer display
            gameState.exploreTimer = setInterval(() => {
                const elapsed = Date.now() - gameState.exploreStartTime;
                const remaining = Math.max(0, gameState.exploreDuration - elapsed);

                const elapsedMinutes = Math.floor(elapsed / 60000);
                const elapsedSeconds = Math.floor((elapsed % 60000) / 1000);

                exploreTimer.textContent = `Elapsed ${Math.floor(elapsedMinutes)}:${elapsedSeconds.toString().padStart(2, '0')}`;

                if (remaining <= 0) {
                    finishExploration();
                }

                // Auto-save every minute
                if (elapsedSeconds === 0) {
                    saveGameState();
                }
            }, 1000);

            saveGameState();
        }

        // Format exploration time for display
        function formatExplorationTime(minutes) {
            if (minutes < 60) {
                return `${minutes} minutes`;
            } else if (minutes < 1440) {
                const hours = minutes / 60;
                return `${hours} ${hours === 1 ? 'hour' : 'hours'}`;
            } else {
                const days = minutes / 1440;
                return `${days} ${days === 1 ? 'day' : 'days'}`;
            }
        }

        // Start battles
        function startBattles() {
            if (gameState.battleTimer) {
                clearInterval(gameState.battleTimer);
            }

            scheduleNextBattle();
        }

        // Schedule next battle
        function scheduleNextBattle() {
            if (!gameState.isExploring) return;

            let baseInterval = 60000 + Math.random() * 30000; // 60-90 seconds

            // Calculate movement speed bonus from equipped accessories
            const char = gameState.character;
            let totalMovementSpeed = 0;

            if (char.equipped.accessory1?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory1.movementSpeed;
            }
            if (char.equipped.accessory2?.movementSpeed) {
                totalMovementSpeed += char.equipped.accessory2.movementSpeed;
            }

            // Apply movement speed: 1 MS = 10% faster encounters
            const encounterMultiplier = 1.0 - (totalMovementSpeed * 0.10);
            const interval = baseInterval * encounterMultiplier;

            gameState.battleTimer = setTimeout(() => {
                if (gameState.isExploring) {
                    simulateBattle();
                    scheduleNextBattle();
                }
            }, interval);
        }

        // Exploring animation functions
        let exploringAnimationInterval = null;
        let exploringAnimationDotCount = 0;

        function updateExploringTimestamp() {
            const exploringTime = document.getElementById('exploring-time');
            if (exploringTime) {
                const timeString = new Date().toLocaleTimeString('en-US', { hour12: false });
                exploringTime.textContent = `[${timeString}]`;
            }
        }

        function startExploringAnimation() {
            const exploringElement = document.getElementById('exploring-animation');
            const exploringText = document.getElementById('exploring-text');
            if (!exploringElement || !gameState.isExploring) return;

            exploringElement.style.display = 'flex';
            exploringAnimationDotCount = 0;
            updateExploringTimestamp();
            if (exploringText) {
                exploringText.textContent = 'Exploring';
            }

            // Clear any existing animation
            if (exploringAnimationInterval) {
                clearInterval(exploringAnimationInterval);
            }

            // Start cycling animation
            exploringAnimationInterval = setInterval(() => {
                if (!gameState.isExploring) {
                    stopExploringAnimation();
                    return;
                }

                exploringAnimationDotCount = (exploringAnimationDotCount + 1) % 4;
                const dots = '.'.repeat(exploringAnimationDotCount);
                const exploringTextEl = document.getElementById('exploring-text');
                if (exploringTextEl) {
                    exploringTextEl.textContent = `Exploring${dots}`;
                }
            }, 500); // Change every 500ms
        }

        function pauseExploringAnimation() {
            const exploringElement = document.getElementById('exploring-animation');
            if (exploringElement) {
                exploringElement.style.display = 'none';
            }
        }

        function resumeExploringAnimation() {
            const exploringElement = document.getElementById('exploring-animation');
            if (exploringElement && gameState.isExploring) {
                exploringElement.style.display = 'flex';
                updateExploringTimestamp();
            }
        }

        function stopExploringAnimation() {
            if (exploringAnimationInterval) {
                clearInterval(exploringAnimationInterval);
                exploringAnimationInterval = null;
            }
            const exploringElement = document.getElementById('exploring-animation');
            if (exploringElement) {
                exploringElement.style.display = 'none';
            }
            const exploringText = document.getElementById('exploring-text');
            if (exploringText) {
                exploringText.textContent = 'Exploring';
            }
        }

        // Stop exploration immediately
        function stopExploration() {
            if (!gameState.isExploring) return;

            // Use different messaging based on current location
            const returnMessage = gameState.currentMap === 'Sette Desert'
                ? 'Exploration finished. Returning to safezone in 30 seconds...'
                : 'Exploration finished. Returning to HQ in 30 seconds...';

            addToBattleLog(returnMessage);

            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearTimeout(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            // Stop exploring animation
            stopExploringAnimation();

            gameState.isExploring = false;

            // HIDE INSTANT FINISH BUTTON
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            gameState.stopTimer = setTimeout(() => {
                exploreBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                // Set to AFK mode instead of hiding
                document.getElementById('explore-selected-time').textContent = 'AFK';
                document.getElementById('explore-timer').textContent = '';

                // Enable Maps button after returning to HQ
                mapsBtn.disabled = false;
                mapsBtn.style.opacity = '1';
                mapsBtn.style.cursor = 'pointer';

                // Enable Maps button (center panel)
                const mapsMainBtnStop = document.getElementById('maps-main-btn');
                if (mapsMainBtnStop) {
                    mapsMainBtnStop.disabled = false;
                    mapsMainBtnStop.style.opacity = '1';
                    mapsMainBtnStop.style.cursor = 'pointer';
                }

                // Use different messaging based on current location
                const returnedMessage = gameState.currentMap === 'Sette Desert'
                    ? 'Returned to safezone.'
                    : 'Returned to HQ.';

                addToBattleLog(returnedMessage);
                gameState.stopTimer = null;
                saveGameState();
            }, 30 * 1000);

            saveGameState();
        }

        // Finish exploration when time runs out
        function finishExploration() {
            if (!gameState.isExploring) return;

            // Use different messaging based on current location
            const returnMessage = gameState.currentMap === 'Sette Desert'
                ? 'Exploration finished. Returning to safezone in 30 seconds...'
                : 'Exploration finished. Returning to HQ in 30 seconds...';

            addToBattleLog(returnMessage);

            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearTimeout(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }
            gameState.bossEncounterQueued = false;
            gameState.bossEncountered = false;
            gameState.encounterStats = {};
            updateEncounterDisplay();

            gameState.isExploring = false;

            // HIDE INSTANT FINISH BUTTON
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            gameState.stopTimer = setTimeout(() => {
                exploreBtn.style.display = 'block';
                stopBtn.style.display = 'none';
                // Set to AFK mode instead of hiding
                document.getElementById('explore-selected-time').textContent = 'AFK';
                document.getElementById('explore-timer').textContent = '';

                // Enable Maps button after returning
                mapsBtn.disabled = false;
                mapsBtn.style.opacity = '1';
                mapsBtn.style.cursor = 'pointer';

                // Enable Maps button (center panel)
                const mapsMainBtnFinish = document.getElementById('maps-main-btn');
                if (mapsMainBtnFinish) {
                    mapsMainBtnFinish.disabled = false;
                    mapsMainBtnFinish.style.opacity = '1';
                    mapsMainBtnFinish.style.cursor = 'pointer';
                }

                // Use different messaging based on current location
                const returnedMessage = gameState.currentMap === 'Sette Desert'
                    ? 'Returned to safezone.'
                    : 'Returned to HQ.';

                addToBattleLog(returnedMessage);
                gameState.stopTimer = null;
                saveGameState();
            }, 30 * 1000);

            saveGameState();
        }

        // Instant finish exploration function (SIMPLIFIED - for testing only)
        function instantFinishExploration() {
            if (!gameState.isExploring) {
                addToBattleLog('You are not currently exploring!');
                return;
            }

            addToBattleLog('Instantly finishing exploration...');

            // Clear all timers
            if (gameState.exploreTimer) {
                clearInterval(gameState.exploreTimer);
                gameState.exploreTimer = null;
            }

            if (gameState.battleTimer) {
                clearTimeout(gameState.battleTimer);
                gameState.battleTimer = null;
            }

            if (gameState.bossCheckTimer) {
                clearInterval(gameState.bossCheckTimer);
                gameState.bossCheckTimer = null;
            }

            // Calculate how many battles should happen based on exploration duration
            const exploreMinutes = gameState.exploreDuration / 60000;
            let battleCount;

            if (exploreMinutes === 30) battleCount = 8;
            else if (exploreMinutes === 60) battleCount = 12;
            else if (exploreMinutes === 360) battleCount = 20;
            else if (exploreMinutes === 720) battleCount = 30;
            else battleCount = 15; // Default

            addToBattleLog(`Simulating ${battleCount} battles from your exploration...`);

            // For 12h explorations, queue a boss encounter at a random battle
            if (exploreMinutes === 720 && !gameState.bossEncountered) {
                const mapBossName = getMapBossName();
                if (mapBossName) {
                    const mapBoss = gameState.bosses[mapBossName];
                    if (mapBoss && mapBoss.isAlive) {
                        // 100% guaranteed boss encounter
                        const randomBattleIndex = Math.floor(Math.random() * battleCount);
                        console.log(`Boss queued for battle ${randomBattleIndex + 1}/${battleCount}`);

                        // Queue the boss for that specific battle
                        setTimeout(() => {
                            gameState.bossEncounterQueued = true;
                        }, randomBattleIndex * 300);
                    }
                }
            }

            // Run battles by calling simulateBattle() repeatedly
            let battlesCompleted = 0;

            const battleInterval = setInterval(() => {
                if (battlesCompleted < battleCount) {
                    // Call the SAME battle function used in normal exploration
                    simulateBattle();

                    battlesCompleted++;
                    exploreTimer.textContent = `Finishing: ${battlesCompleted}/${battleCount}`;
                } else {
                    clearInterval(battleInterval);

                    // Restore HP and FP
                    gameState.character.hp = gameState.character.maxHp;
                    gameState.character.fp = gameState.character.maxFp;

                    finishInstantExploration();
                }
            }, 300); // 300ms between each battle
        }

        // Finish the instant exploration
        function finishInstantExploration() {
            addToBattleLog('Exploration instantly completed!');

            // Reset UI
            exploreBtn.style.display = 'block';
            stopBtn.style.display = 'none';
            // Set to AFK mode instead of hiding
            document.getElementById('explore-selected-time').textContent = 'AFK';
            document.getElementById('explore-timer').textContent = '';
            const instantFinishBtn = document.getElementById('instant-finish-btn');
            if (instantFinishBtn) {
                instantFinishBtn.style.display = 'none';
            }

            // Enable Maps button
            mapsBtn.disabled = false;
            mapsBtn.style.opacity = '1';
            mapsBtn.style.cursor = 'pointer';

            // Enable Maps button (center panel)
            const mapsMainBtnInstant = document.getElementById('maps-main-btn');
            if (mapsMainBtnInstant) {
                mapsMainBtnInstant.disabled = false;
                mapsMainBtnInstant.style.opacity = '1';
                mapsMainBtnInstant.style.cursor = 'pointer';
            }

            gameState.isExploring = false;

            // Update character display
            updateCharacterDisplay();
            saveGameState();
        }

        // Simulate a battle
        function simulateBattle() {
            if (!gameState.isExploring) return;

            const char = gameState.character;

            // Get monsters for current exploration (EXCLUDE BOSSES - they are handled by timer)
            let availableMonsters;
            if (gameState.exploreArea) {
                // Area-based exploration (Ether Platform)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.area === gameState.exploreArea &&
                    monster.map === gameState.currentMap &&
                    !monster.isBoss  // Exclude bosses from regular pool
                );
            } else {
                // Time-based exploration (HQ, Sette Desert)
                availableMonsters = Object.entries(monsters).filter(([name, monster]) =>
                    monster.explorationTime === (gameState.exploreDuration / 60000) &&
                    monster.map === gameState.currentMap &&
                    !monster.isBoss  // Exclude bosses from regular pool
                );
            }

            if (availableMonsters.length === 0) {
                addToBattleLog("No monsters available in this area.", 'warning');
                return;
            }

            // BOSS ENCOUNTER CHECK (New Timer System)
            let selectedMonster;
            let selectedMonsterName;

            // Check if boss is queued from 15-min timer
            if (gameState.bossEncounterQueued) {
                const mapBossName = getMapBossName();
                if (mapBossName) {
                    selectedMonsterName = mapBossName;
                    selectedMonster = monsters[selectedMonsterName];
                    gameState.bossEncounterQueued = false; // Clear flag
                    addToBattleLog(`<span class="log-boss-encounter">❗Monster Boss Alert: ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
                } else {
                    // Fallback if map changed or error
                    const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                    [selectedMonsterName, selectedMonster] = availableMonsters[randomIndex];
                    addToBattleLog(`<span class="log-encounter">You encounter a ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
                }
            } else {
                // Regular monster encounter
                if (availableMonsters.length === 0) {
                    addToBattleLog("No monsters available in this area.", 'warning');
                    return;
                }
                const randomIndex = Math.floor(Math.random() * availableMonsters.length);
                [selectedMonsterName, selectedMonster] = availableMonsters[randomIndex];
                addToBattleLog(`<span class="log-encounter">You encounter a ${selectedMonsterName} Lv.${selectedMonster.level}!</span>`, 'encounter');
            }

            // Show exploring animation after first encounter
            if (gameState.isExploring && Object.keys(gameState.encounterStats).length === 0) {
                startExploringAnimation();
            }

            // Pause exploring animation during battle
            pauseExploringAnimation();

            // Track encounter
            if (!gameState.encounterStats[selectedMonsterName]) {
                gameState.encounterStats[selectedMonsterName] = 0;
            }
            gameState.encounterStats[selectedMonsterName]++;
            updateEncounterDisplay();

            // Calculate Base Damage
            const baseCharDamage = Math.max(1, char.attack - Math.floor(selectedMonster.defense / 3));
            let monsterDamage = Math.max(1, selectedMonster.attack - Math.floor(char.defense / 2));

            // Apply Damage Reduction from Armor
            let damageReductionAmount = 0;
            if (char.equipped.armor && char.equipped.armor.damageReduction) {
                damageReductionAmount = Math.floor(monsterDamage * char.equipped.armor.damageReduction);
                monsterDamage -= damageReductionAmount;
            }

            let monsterHp = selectedMonster.isBoss ? gameState.bosses[selectedMonsterName].currentHp : selectedMonster.hp;
            let charHp = char.hp;

            while (monsterHp > 0 && charHp > 0) {
                // Calculate Crit for this hit
                const criticalChance = char.criticalChance || 0.05;
                const isCritical = Math.random() < criticalChance;
                const damageMultiplier = isCritical ? 1.5 : 1;

                // Apply Crit to Base Damage
                let charDamage = Math.floor(baseCharDamage * damageMultiplier);

                // Skill Usage Logic
                let currentAttackDamage = charDamage;
                let skillUsed = null;

                // Check for available skills
                const mySkills = classSkills[char.class] || [];
                const availableSkills = mySkills.filter(skill => char.level >= skill.level && char.fp >= skill.fpCost);

                // 30% chance to use a skill if available
                if (availableSkills.length > 0 && Math.random() < 0.2) {
                    // Pick a random available skill
                    const randomSkillIndex = Math.floor(Math.random() * availableSkills.length);
                    skillUsed = availableSkills[randomSkillIndex];

                    // Apply skill effects
                    currentAttackDamage = Math.floor(charDamage * skillUsed.damageMult);
                    char.fp -= skillUsed.fpCost;
                }

                monsterHp -= currentAttackDamage;

                if (skillUsed) {
                    addToBattleLog(`You used <span style="color: #00ffff;">${skillUsed.name}</span>! Hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                } else if (isCritical) {
                    addToBattleLog(`⚡ CRITICAL HIT! You hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                } else {
                    addToBattleLog(`You hit ${selectedMonsterName} for <span class="log-player-damage">${currentAttackDamage} damage</span>.`, 'damage');
                }

                // Lifesteal Logic
                if (char.equipped.weapon && char.equipped.weapon.lifesteal) {
                    const ls = char.equipped.weapon.lifesteal;
                    if (Math.random() < ls.chance) {
                        const healAmount = Math.floor(currentAttackDamage * ls.multiplier);
                        if (healAmount > 0) {
                            charHp = Math.min(char.maxHp, charHp + healAmount);
                            addToBattleLog(`💚 Lifesteal! Recovered <span style="color: #00ff00;">${healAmount} HP</span>.`, 'heal');
                        }
                    }
                }
                if (monsterHp <= 0) {
                    addToBattleLog(`<span class="log-success">💪 You defeated ${selectedMonsterName}!</span>`, 'success');

                    // Handle boss defeat
                    if (selectedMonster.isBoss) {
                        const bossState = gameState.bosses[selectedMonsterName];
                        // Reset boss for next exploration
                        bossState.isAlive = true;
                        bossState.currentHp = bossState.maxHp;
                        addToBattleLog(`<span class="log-boss-victory">🎉 Victory! You defeated 👾 ${selectedMonsterName}!</span>`, 'level');
                    }

                    if (char.level < 40) {
                        // Flat EXP system: Different EXP per map for balanced progression
                        const expGain = getMonsterExpGain(selectedMonsterName, selectedMonster);
                        char.exp += expGain;
                        addToBattleLog(`You gained <span class="log-exp">${expGain} EXP points</span>.`, 'exp');

                        if (char.exp >= char.maxExp) {
                            levelUp();
                        }
                    }

                    checkDrops(selectedMonster);
                    break;
                }

                // BOSS SPECIAL ATTACK
                if (selectedMonster.isBoss && Math.random() < 0.3) { // 30% chance for special attack
                    const specialDamage = Math.floor(selectedMonster.attack * 0.5); // 50% of attack as bonus
                    charHp -= specialDamage;
                    addToBattleLog(`👾 ${selectedMonsterName} uses Special Attack! <span class="log-damage">${specialDamage} damage</span>.`, 'damage');
                } else {
                    // Regular attack
                    charHp -= monsterDamage;
                    let logMsg = `${selectedMonsterName} hits you for <span class="log-damage">${monsterDamage} damage</span>.`;
                    if (damageReductionAmount > 0) {
                        logMsg += ` <span style="color: #3498db; font-size: 0.8em;"> -${damageReductionAmount} DMG</span>`;
                    }
                    addToBattleLog(logMsg, 'damage');
                }

                // Auto Potion Logic (2-second cooldown)
                const currentTime = Date.now();
                if (gameState.autoPotion && charHp < char.maxHp * 0.5 && charHp > 0) {
                    if (gameState.currency >= 5 && (currentTime - gameState.lastPotionTime) >= 1000) {
                        const healAmount = Math.floor(char.maxHp * 0.3);
                        const fpAmount = Math.floor(char.maxFp * 0.3);
                        charHp = Math.min(char.maxHp, charHp + healAmount);
                        char.fp = Math.min(char.maxFp, char.fp + fpAmount);
                        gameState.currency -= 5;
                        gameState.lastPotionTime = currentTime; // Update last potion time
                        addToBattleLog(`🧪 Auto Potion! <span style="color: #00ff00;">+${healAmount} HP</span> and <span style="color: #4a9cff;">+${fpAmount} FP</span>. Consumed -5 🍃`, 'heal');
                        document.getElementById('currency-amount').textContent = gameState.currency;
                    }
                }

                if (charHp <= 0) {
                    console.log('DEATH CONDITION MET - charHp:', charHp, 'monsterHp:', monsterHp, 'isBoss:', selectedMonster.isBoss);
                    addToBattleLog(`<span class="log-damage">You have been defeated!</span>`, 'danger');

                    // Handle death location logic
                    if (gameState.currentMap === "Sette Desert") {
                        addToBattleLog(`You died and respawned at HQ.`, 'info');
                        gameState.currentMap = "HQ";
                        char.location = "HQ";
                        updateMapsAccessibility(); // Update UI to reflect map change
                    } else {
                        addToBattleLog(`You died and returned to your saved location.`, 'info');
                    }

                    // Update boss HP if it was a boss battle
                    if (selectedMonster.isBoss) {
                        gameState.bosses[selectedMonsterName].currentHp = monsterHp;
                        addToBattleLog(`👾 ${selectedMonsterName} has ${gameState.bosses[selectedMonsterName].currentHp}/${gameState.bosses[selectedMonsterName].maxHp} HP remaining.`);
                    }

                    char.hp = char.maxHp;
                    char.fp = char.maxFp;

                    if (gameState.exploreTimer) {
                        clearInterval(gameState.exploreTimer);
                        gameState.exploreTimer = null;
                    }

                    if (gameState.battleTimer) {
                        clearTimeout(gameState.battleTimer);
                        gameState.battleTimer = null;
                    }

                    if (gameState.bossCheckTimer) {
                        clearTimeout(gameState.bossCheckTimer);
                        gameState.bossCheckTimer = null;
                    }

                    exploreBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    exploreStatus.style.display = 'none';
                    const instantFinishBtn = document.getElementById('instant-finish-btn');
                    if (instantFinishBtn) {
                        instantFinishBtn.style.display = 'none';
                    }

                    // Enable Maps button
                    mapsBtn.disabled = false;
                    mapsBtn.style.opacity = '1';
                    mapsBtn.style.cursor = 'pointer';

                    // Enable Maps button (center panel)
                    const mapsMainBtnDeath = document.getElementById('maps-main-btn');
                    if (mapsMainBtnDeath) {
                        mapsMainBtnDeath.disabled = false;
                        mapsMainBtnDeath.style.opacity = '1';
                        mapsMainBtnDeath.style.cursor = 'pointer';
                    }

                    console.log('RESETTING EXPLORATION STATE - isExploring was:', gameState.isExploring);
                    gameState.isExploring = false;
                    gameState.bossEncounterQueued = false;
                    gameState.bossEncountered = false;
                    gameState.encounterStats = {};
                    stopExploringAnimation();
                    console.log('EXPLORATION STATE RESET - isExploring now:', gameState.isExploring);

                    updateCharacterDisplay();
                    saveGameState();
                    return;
                }
            }

            // Update boss HP if it survived (shouldn't happen here as loop breaks on death, but for safety)
            if (selectedMonster.isBoss && monsterHp > 0) {
                gameState.bosses[selectedMonsterName].currentHp = monsterHp;
            }

            char.hp = charHp;
            updateCharacterDisplay();
            saveGameState();

            // Resume exploring animation after battle
            resumeExploringAnimation();
        }

        // Check for monster drops
        function checkDrops(monster) {
            monster.drops.forEach(drop => {
                if (Math.random() < drop.chance) {
                    if (drop.type === 'currency') {
                        const amount = drop.quantity || drop.amount;
                        gameState.currency += amount;
                        addToBattleLog(`You found <span class="log-loot">${amount} ${getEmoji('currency')} Leaves</span>!`, 'loot');
                    } else if (drop.type === 'item') {
                        // Check inventory space ONLY for items
                        const quantity = drop.quantity || 1;
                        if (gameState.inventory.length + quantity > 20) {
                            addToBattleLog(`Inventory full! Could not pick up ${drop.name}.`, 'warning');
                            return;
                        }

                        // Determine type dynamically
                        let itemType = 'weapon';
                        if (drop.name.toLowerCase().includes('armor') || drop.name.toLowerCase().includes('core') || drop.name.toLowerCase().includes('tunic') || drop.name.toLowerCase().includes('cloak') || drop.name.toLowerCase().includes('robe')) {
                            itemType = 'armor';
                        } else if (drop.name.toLowerCase().includes('ring')) {
                            itemType = 'accessory';
                        }

                        gameState.inventory.push({
                            name: drop.name,
                            stats: drop.stats,
                            sellValue: drop.sellValue,
                            quantity: 1,
                            type: itemType,
                            upgradeLevel: 0,
                            movementSpeed: drop.movementSpeed || null,
                            isWings: drop.isWings || false,
                            lifesteal: drop.lifesteal || null,
                            damageReduction: drop.damageReduction || null,
                            rarity: drop.rarity || null
                        });


                        addToBattleLog(`You found ${quantity > 1 ? quantity + ' ' : ''}<span class="log-loot">${getEmoji(drop.name.toLowerCase())} ${drop.name}${quantity > 1 ? 's' : ''}</span>!`, 'loot');
                        updateInventoryDisplay();
                    } else if (drop.type === 'material') {
                        const quantity = drop.quantity || 1;
                        const existingMaterial = gameState.materials.find(material => material.name === drop.name);

                        if (existingMaterial) {
                            existingMaterial.quantity += quantity;
                        } else {
                            gameState.materials.push({
                                name: drop.name,
                                sellValue: drop.sellValue,
                                quantity: quantity,
                                type: 'material'
                            });
                        }

                        addToBattleLog(`You found <span class="log-loot">${getEmoji(drop.name.toLowerCase())} ${drop.name} ×${quantity}</span>!`, 'loot');
                        updateInventoryDisplay();
                    }
                }
            });

            document.getElementById('currency-amount').textContent = gameState.currency;
            saveGameState();
        }

        // Start HP regeneration
        function startHPRegeneration() {
            if (gameState.regenTimer) {
                clearInterval(gameState.regenTimer);
            }

            gameState.regenTimer = setInterval(() => {
                if (gameState.character) {
                    const char = gameState.character;

                    if (char.hp < char.maxHp) {
                        char.hp = Math.min(char.maxHp, char.hp + Math.ceil(char.maxHp * 0.01));
                        updateCharacterDisplay();
                        saveGameState();
                    }

                    if (char.fp < char.maxFp) {
                        char.fp = Math.min(char.maxFp, char.fp + Math.ceil(char.maxFp * 0.01));
                        updateCharacterDisplay();
                        saveGameState();
                    }
                }
            }, 5000);
        }

        // Level up character
        function levelUp() {
            const char = gameState.character;

            while (char.exp >= char.maxExp && char.level < 40) {
                char.level += 1;
                char.exp -= char.maxExp;
                // EXP Required Formula: Moderate exponential progression (100 * 1.15^(level-1))
                char.maxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));

                const increases = statIncrease[char.class];
                char.maxHp += increases.hp;
                char.maxFp += increases.fp;
                char.attack += increases.attack;
                char.defense += increases.defense;

                char.hp = char.maxHp;
                char.fp = char.maxFp;

                addToBattleLog(`<span class="log-level">✨ You reached level ${char.level}!</span>`, 'level');

                // Show max level message only when first reaching it
                if (char.level === 40) {
                    addToBattleLog(`<span class="log-level">🎉 You have reached the maximum level of 40!</span>`, 'level');
                }
            }

            saveGameState();
        }

        // Update inventory display - SORTED WITH EQUIPPED ITEMS FIRST
        function updateInventoryDisplay() {
            inventoryItems.innerHTML = '';
            materialsItems.innerHTML = '';

            // Sort inventory: equipped items first, then unequipped
            const sortedInventory = [...gameState.inventory].sort((a, b) => {
                const aEquipped = (gameState.character.equipped.weapon === a || gameState.character.equipped.armor === a || gameState.character.equipped.accessory1 === a || gameState.character.equipped.accessory2 === a || gameState.character.equipped.wings === a);
                const bEquipped = (gameState.character.equipped.weapon === b || gameState.character.equipped.armor === b || gameState.character.equipped.accessory1 === b || gameState.character.equipped.accessory2 === b || gameState.character.equipped.wings === b);

                if (aEquipped && !bEquipped) return -1;
                if (!aEquipped && bEquipped) return 1;
                return 0;
            });

            // Count actual items (not quantities) for inventory limit
            const totalItems = gameState.inventory.length;
            inventoryLimit.textContent = `Inventory: ${totalItems}/20`;

            if (sortedInventory.length === 0) {
                emptyInventory.style.display = 'block';
            } else {
                emptyInventory.style.display = 'none';

                sortedInventory.forEach((item, originalIndex) => {
                    // Find the original index for event handlers
                    const index = gameState.inventory.indexOf(item);

                    const itemElement = document.createElement('div');
                    itemElement.className = 'item-compact';

                    const isWeaponEquipped = gameState.character.equipped.weapon === item;
                    const isArmorEquipped = gameState.character.equipped.armor === item;
                    const isAccessory1Equipped = gameState.character.equipped.accessory1 === item;
                    const isAccessory2Equipped = gameState.character.equipped.accessory2 === item;
                    const isWingsEquipped = gameState.character.equipped.wings === item;
                    const isEquipped = isWeaponEquipped || isArmorEquipped || isAccessory1Equipped || isAccessory2Equipped || isWingsEquipped;

                    if (isEquipped) {
                        itemElement.classList.add('equipped');
                    }

                    const itemLevel = item.upgradeLevel || 0;
                    const upgradeText = itemLevel > 0 ? `+${itemLevel}` : '';

                    // Handle Emoji
                    let emoji = getEmoji(item.name.toLowerCase());
                    if (item.isWings || item.name.toLowerCase().includes('wings')) {
                        emoji = '🪽';
                    }

                    const displayName = `${emoji} ${item.name} ${upgradeText}`.trim();

                    const isArmor = item.name.toLowerCase().includes('armor') ||
                        item.name.toLowerCase().includes('shirt') ||
                        item.name.toLowerCase().includes('tunic') ||
                        item.name.toLowerCase().includes('cloak') ||
                        item.name.toLowerCase().includes('core') ||
                        item.name.toLowerCase().includes('suit') ||
                        item.name.toLowerCase().includes('robe');

                    const isAccessory = item.name.toLowerCase().includes('wristlet') ||
                        item.name.toLowerCase().includes('ring') ||
                        item.name.toLowerCase().includes('novice') ||
                        item.name.toLowerCase().includes('mild') ||
                        item.name.toLowerCase().includes('normal') ||
                        item.name.toLowerCase().includes('power') ||
                        item.name.toLowerCase().includes('mighty') ||
                        item.name.toLowerCase().includes('cosmic') ||
                        item.isWings ||
                        item.name.toLowerCase().includes('wings');

                    let statDisplay = '';
                    if (isArmor) {
                        const statBonus = item.stats.defense + (upgradeSystem.bonuses[itemLevel]?.defense || 0);
                        statDisplay = `🛡️ +${statBonus} Defense`;
                        if (item.damageReduction) {
                            statDisplay += ` | DMG Red. ${Math.round(item.damageReduction * 100)}%`;
                        }
                    } else if (isAccessory) {
                        // Check if accessory has percentage bonuses
                        if (item.bonusPercent) {
                            const atkPercent = item.bonusPercent.attack || 0;
                            const defPercent = item.bonusPercent.defense || 0;

                            if (atkPercent > 0 && defPercent > 0) {
                                statDisplay = `⚔️ +${Math.round(atkPercent * 100)}%  🛡️ +${Math.round(defPercent * 100)}%`;
                            } else if (atkPercent > 0) {
                                statDisplay = `⚔️ +${Math.round(atkPercent * 100)}% ATK`;
                            } else if (defPercent > 0) {
                                statDisplay = `🛡️ +${Math.round(defPercent * 100)}% DEF`;
                            } else {
                                statDisplay = 'Accessory';
                            }
                        } else {
                            // Fallback for accessories with flat stats (like Parsal Wristlets)
                            const atk = item.stats?.attack || 0;
                            const def = item.stats?.defense || 0;
                            statDisplay = `⚔️ +${atk}  🛡️ +${def}`;
                        }

                        // Add Movement Speed display for Wings
                        if (item.movementSpeed) {
                            statDisplay += ` | Speed ${item.movementSpeed}`;
                        }
                    } else {
                        const statBonus = item.stats.attack + (upgradeSystem.bonuses[itemLevel]?.attack || 0);
                        statDisplay = `⚔️ +${statBonus} Attack`;

                        // Add Lifesteal display
                        if (item.lifesteal) {
                            statDisplay += ` | LS ${Math.round(item.lifesteal.chance * 100)}%`;
                        }
                    }


                    // Class Weapon Restrictions
                    const playerClass = gameState.character.class;
                    let canEquip = true;
                    let restrictionMsg = "";

                    if (!isArmor && !isAccessory) { // It's a weapon
                        const name = item.name.toLowerCase();
                        const isSword = name.includes('sword') || name.includes('blade') || name.includes('claymore') || name.includes('breaker') || name.includes('zweihander') || name.includes('man eater') || name.includes('eater') || name.includes('spadona');
                        const isStaff = name.includes('staff') || name.includes('wand') || name.includes('bead');
                        const isBow = name.includes('bow');
                        const isLauncher = name.includes('launcher') || name.includes('flame thrower') || name.includes('bazooka') || name === 'cerberus';

                        let requiredClass = null;
                        if (isSword) requiredClass = 'Warrior';
                        else if (isStaff) requiredClass = 'Mystic';
                        else if (isBow) requiredClass = 'Ranger';
                        else if (isLauncher) requiredClass = 'Launcher';

                        if (requiredClass && playerClass !== requiredClass) {
                            canEquip = false;
                            restrictionMsg = `${requiredClass} Only`;
                        }
                    }

                    itemElement.innerHTML = `
                <div class="item-compact-info">
                    <div class="item-compact-name ${item.rarity === 't1' ? 'item-rarity-t1' : (item.rarity === 'intense' ? 'item-rarity-intense' : (item.rarity === 'relic' ? 'item-rarity-relic' : ''))}" style="display: flex; justify-content: space-between;">
                        <span>${displayName}</span>
                        <span style="font-size: 0.8rem; color: var(--text-dim); font-weight: normal;">Price ${item.sellValue} 🍃</span>
                    </div>
                    <div class="item-compact-stats">${statDisplay}</div>
                    <div class="item-compact-actions">
                        <button class="btn-small btn-equip" data-index="${index}" 
                            ${(!canEquip && !isEquipped) ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                            ${isEquipped ? 'Unequip' : 'Equip'}
                        </button>
                        <button class="btn-small btn-sell" data-index="${index}" 
                            ${(isEquipped) ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                            Sell
                        </button>
                        ${itemLevel < 7 && !isEquipped && !isAccessory ?
                            `<button class="btn-small btn-upgrade" data-index="${index}">Upgrade</button>` :
                            '<button class="btn-small btn-upgrade" data-index="${index}" disabled style="opacity: 0.5; cursor: not-allowed;">Upgrade</button>'
                        }
                    </div>
                </div>
            `;
                    const upgradeBtn = itemElement.querySelector('.btn-upgrade');
                    const sellBtn = itemElement.querySelector('.btn-sell');
                    const equipBtn = itemElement.querySelector('.btn-equip');

                    if (upgradeBtn && !upgradeBtn.disabled) {
                        upgradeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showUpgradeModal(item, index);
                        });
                    }

                    sellBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!isEquipped) {
                            sellItem(item, index);
                        } else {
                            addToBattleLog('You cannot sell an equipped item.', 'warning');
                        }
                    });

                    equipBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleEquipItem(item, index);
                    });

                    inventoryItems.appendChild(itemElement);
                });
            }

            // Update materials display
            if (gameState.materials.length === 0) {
                emptyMaterials.style.display = 'block';
            } else {
                emptyMaterials.style.display = 'none';

                gameState.materials.forEach((material, index) => {
                    const materialElement = document.createElement('div');
                    materialElement.className = 'material-item-compact';

                    materialElement.innerHTML = `
                        <div class="material-info">
                            ${getEmoji(material.name.toLowerCase())} ${material.name} x${material.quantity}
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span class="material-price" style="margin-right: 8px; font-size: 0.8rem; color: var(--text-dim);">Price ${material.sellValue} 🍃</span>
                            <button class="btn-small btn-sell" data-index="${index}">Sell</button>
                        </div>
                    `;

                    const sellBtn = materialElement.querySelector('.btn-sell');
                    sellBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        sellMaterial(material, index);
                    });

                    materialsItems.appendChild(materialElement);
                });
            }

            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
        }

        // Show upgrade modal
        function showUpgradeModal(item, index) {
            currentUpgradeItem = { item, index };
            const itemLevel = parseInt(item.upgradeLevel) || 0;

            // FIX: Check max level
            if (itemLevel >= 7) {
                // Check if it's armor or weapon
                const isArmor = item.name.toLowerCase().includes('armor') ||
                    item.name.toLowerCase().includes('shirt') ||
                    item.name.toLowerCase().includes('tunic') ||
                    item.name.toLowerCase() === 'steel core' ||
                    item.name.toLowerCase().includes('robe');

                const statType = isArmor ? 'defense' : 'attack';
                const currentStat = item.stats[statType] + (upgradeSystem.bonuses[itemLevel]?.[statType] || 0);

                upgradeItemInfo.innerHTML = `
                    <div class="upgrade-info">
                        <div class="item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</div>
                        <div class="item-stats">Current: +${currentStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)} (MAX)</div>
                    </div>
                    <div class="upgrade-cost">
                        <span>Max Level Reached</span>
                    </div>
                `;
                document.getElementById('upgrade-confirm-btn').disabled = true;
                document.getElementById('upgrade-confirm-btn').textContent = "Max Level";
                upgradeResult.style.display = 'none';
                upgradeModal.style.display = 'flex';
                return;
            }

            document.getElementById('upgrade-confirm-btn').disabled = false;
            document.getElementById('upgrade-confirm-btn').textContent = "Upgrade";

            const nextLevel = itemLevel + 1;
            const cost = upgradeSystem.costs[nextLevel];
            const chance = upgradeSystem.chances[nextLevel];

            // Check if it's armor or weapon
            const lowerName = item.name.toLowerCase();
            const isArmor = lowerName.includes('armor') ||
                lowerName.includes('shirt') ||
                lowerName.includes('tunic') ||
                lowerName.includes('suit') ||
                lowerName === 'steel core' ||
                lowerName.includes('robe');

            const statType = isArmor ? 'defense' : 'attack';
            const currentStat = item.stats[statType] + (upgradeSystem.bonuses[itemLevel]?.[statType] || 0);
            const nextStat = item.stats[statType] + upgradeSystem.bonuses[nextLevel][statType];

            // Determine which gem to use based on item type
            const gemType = isArmor ? "Blue Gem" : "Red Gem";
            const gemEmoji = isArmor ? getEmoji('blue gem') : getEmoji('red gem');

            upgradeItemInfo.innerHTML = `
                <div class="upgrade-info">
                    <div class="item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</div>
                    <div class="item-stats">Current: +${currentStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)} → Next: +${nextStat} ${statType.charAt(0).toUpperCase() + statType.slice(1)}</div>
                </div>
                <div class="upgrade-cost">
                    <span>Cost: ${cost[gemType]} ${gemEmoji} ${gemType}s + ${cost['currency']} 🍃</span>
                </div>
                <div class="upgrade-chance">
                    Success Chance: ${Math.round(chance * 100)}%
                    ${nextLevel === 5 ? '<div style="color: var(--danger); margin-top: 0.5rem;">Warning: Failure will destroy the item!</div>' : ''}
                </div>
            `;

            upgradeResult.style.display = 'none';
            upgradeModal.style.display = 'flex';
        }

        // Confirm upgrade
        // Confirm upgrade
        function confirmUpgrade() {
            if (!currentUpgradeItem) return;

            const { item, index } = currentUpgradeItem;
            const itemLevel = parseInt(item.upgradeLevel) || 0;
            const nextLevel = itemLevel + 1;
            const cost = upgradeSystem.costs[nextLevel];
            const chance = upgradeSystem.chances[nextLevel];

            // Check if it's armor or weapon
            const lowerName = item.name.toLowerCase();
            const isArmor = lowerName.includes('armor') ||
                lowerName.includes('shirt') ||
                lowerName.includes('tunic') ||
                lowerName.includes('suit') ||
                lowerName === 'steel core' ||
                lowerName.includes('robe');

            const statType = isArmor ? 'defense' : 'attack';
            const gemType = isArmor ? "Blue Gem" : "Red Gem";
            const equippedSlot = isArmor ? 'armor' : 'weapon';

            const gems = gameState.materials.find(m => m.name === gemType);

            if (!gems || gems.quantity < cost[gemType]) {
                showUpgradeResult(`You need ${cost[gemType]} ${gemType}s to upgrade.`, false);
                return;
            }

            if (gameState.currency < cost['currency']) {
                showUpgradeResult(`You need ${cost['currency']} 🍃 to upgrade.`, false);
                return;
            }

            const success = Math.random() < chance;

            if (success) {
                gameState.inventory[index].upgradeLevel = nextLevel;

                if (gameState.character.equipped[equippedSlot] === item) {
                    const oldBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                    const newBonus = upgradeSystem.bonuses[nextLevel][statType];
                    gameState.character[statType] += (newBonus - oldBonus);
                }

                if (gems.quantity > cost[gemType]) {
                    gems.quantity -= cost[gemType];
                } else {
                    const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                    gameState.materials.splice(materialIndex, 1);
                }

                gameState.currency -= cost['currency'];

                // Refresh modal content to show new stats and next level success rate
                showUpgradeModal(item, index);

                showUpgradeResult(`Upgrade successful! ${item.name} is now +${nextLevel} (+${upgradeSystem.bonuses[nextLevel][statType]} ${statType.charAt(0).toUpperCase() + statType.slice(1)})`, true);
                addToBattleLog(`Upgraded ${getEmoji(item.name.toLowerCase())} ${item.name} to +${nextLevel}!`);
            } else {
                // Only consume materials on failure for +1 to +4
                if (nextLevel < 5) { // Levels 1-4 only consume materials on failure
                    if (gems.quantity > cost[gemType]) {
                        gems.quantity -= cost[gemType];
                    } else {
                        const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                        gameState.materials.splice(materialIndex, 1);
                    }

                    showUpgradeResult(`Upgrade failed! Materials were consumed.`, false);
                    addToBattleLog(`Upgrade failed for ${getEmoji(item.name.toLowerCase())} ${item.name}! Materials lost.`);
                } else {
                    // +5 failure - destroy weapon and consume materials
                    if (gems.quantity > cost[gemType]) {
                        gems.quantity -= cost[gemType];
                    } else {
                        const materialIndex = gameState.materials.findIndex(m => m.name === gemType);
                        gameState.materials.splice(materialIndex, 1);
                    }

                    showUpgradeResult(`Upgrade failed! The item was destroyed.`, false);
                    addToBattleLog(`Upgrade failed! ${getEmoji(item.name.toLowerCase())} ${item.name} was destroyed.`);

                    // Handle destruction in UI
                    currentUpgradeItem = null;
                    document.getElementById('upgrade-confirm-btn').disabled = true;
                    document.getElementById('upgrade-item-info').innerHTML = '<div style="color: var(--danger); text-align: center; padding: 2rem;">Item Destroyed</div>';

                    // Remove the item from inventory
                    gameState.inventory.splice(index, 1);

                    // Unequip if it was equipped
                    if (gameState.character.equipped[equippedSlot] === item) {
                        const oldBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
                        gameState.character[statType] -= (item.stats[statType] + oldBonus);
                        gameState.character.equipped[equippedSlot] = null;
                    }
                }
            }

            updateInventoryDisplay();
            updateCharacterDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;

            saveGameState();
        }

        // Show upgrade result
        function showUpgradeResult(message, success) {
            upgradeResult.textContent = message;
            upgradeResult.className = `upgrade-result ${success ? 'upgrade-success' : 'upgrade-failure'}`;
            upgradeResult.style.display = 'block';
        }

        // Sell an item
        function sellItem(item, index) {
            const equipped = gameState.character.equipped;
            if (equipped.weapon === item || equipped.armor === item ||
                equipped.accessory1 === item || equipped.accessory2 === item) {
                addToBattleLog(`You cannot sell an equipped item.`);
                return;
            }

            const sellValue = item.sellValue;
            gameState.currency += sellValue;

            gameState.inventory.splice(index, 1);

            addToBattleLog(`Sold ${getEmoji(item.name.toLowerCase())} ${item.name} for ${sellValue} 🍃.`);

            updateInventoryDisplay();
            updateInventoryDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
            saveGameState();
        }

        // Sell a material
        function sellMaterial(material, index) {
            const sellValue = material.sellValue;
            gameState.currency += sellValue;

            if (material.quantity > 1) {
                material.quantity -= 1;
            } else {
                gameState.materials.splice(index, 1);
            }

            addToBattleLog(`Sold ${getEmoji('redgem')} ${material.name} for ${sellValue} 🍃.`);

            updateInventoryDisplay();
            updateInventoryDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
            saveGameState();
        }

        // Sell all unequipped items
        function sellAllUnequippedItems() {
            const equipped = gameState.character.equipped;
            let totalSold = 0;
            let totalValue = 0;

            // Filter out equipped items
            const unequippedItems = gameState.inventory.filter(item => {
                return item !== equipped.weapon &&
                    item !== equipped.armor &&
                    item !== equipped.accessory1 &&
                    item !== equipped.accessory2 &&
                    item !== equipped.wings;
            });

            if (unequippedItems.length === 0) {
                addToBattleLog('No unequipped items to sell.', 'warning');
                return;
            }

            // Calculate total value and count
            unequippedItems.forEach(item => {
                totalValue += item.sellValue;
                totalSold++;
            });

            // Remove all unequipped items from inventory
            gameState.inventory = gameState.inventory.filter(item => {
                return item === equipped.weapon ||
                    item === equipped.armor ||
                    item === equipped.accessory1 ||
                    item === equipped.accessory2 ||
                    item === equipped.wings;
            });

            // Add currency
            gameState.currency += totalValue;

            // Log the sale
            addToBattleLog(`Sold ${totalSold} unequipped item${totalSold > 1 ? 's' : ''} for ${totalValue} 🍃.`);

            // Update displays
            updateInventoryDisplay();
            document.getElementById('currency-amount').textContent = gameState.currency;
            document.getElementById('coins-amount').textContent = gameState.coins;
            saveGameState();
        }


        // Toggle item equip/unequip
        function toggleEquipItem(item, index) {
            const char = gameState.character;
            const itemLevel = item.upgradeLevel || 0;
            const name = item.name.toLowerCase();

            // WINGS HANDLING - Check this FIRST before any other equipment type
            const isWings = item.isWings || name.includes('wings');
            if (isWings) {
                const isEquipped = char.equipped.wings === item;

                if (isEquipped) {
                    // Unequip wings
                    char.equipped.wings = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    // Equip wings (replace if already equipped)
                    if (char.equipped.wings) {
                        const oldWings = char.equipped.wings;
                        char.attack -= oldWings.stats.attack || 0;
                        char.defense -= oldWings.stats.defense || 0;
                        addToBattleLog(`You unequipped ${getEmoji(oldWings.name.toLowerCase())} ${oldWings.name}.`);
                    }
                    char.equipped.wings = item;
                    char.attack += item.stats.attack || 0;
                    char.defense += item.stats.defense || 0;
                    addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name}!`);
                }

                updateCharacterDisplay();
                updateInventoryDisplay(); // Re-render inventory to show equipped state
                saveGameState();
                return; // Exit early - Wings handled
            }

            // Robust Type Detection (for non-Wings items)
            let isArmor = name.includes('armor') ||
                name.includes('shirt') ||
                name.includes('tunic') ||
                name.includes('cloak') ||
                name.includes('core') ||
                name === 'steel core' ||
                name.includes('robe'); // Explicit check

            // Fallback: If it has defense but no attack, it's armor
            if (!isArmor && item.stats.defense && !item.stats.attack) {
                isArmor = true;
            }

            // Class Weapon Restrictions Check
            const playerClass = gameState.character.class;
            if (!isArmor && !name.includes('ring') && !item.isWings && !name.includes('wings')) { // It's a weapon
                const isSword = name.includes('sword') || name.includes('blade') || name.includes('claymore') || name.includes('breaker') || name.includes('zweihander') || name.includes('man eater') || name.includes('eater') || name.includes('spadona');
                const isStaff = name.includes('staff') || name.includes('wand') || name.includes('bead') || name.toLowerCase().includes('accelleon');
                const isBow = name.includes('bow') || name.toLowerCase().includes('valkyrie');
                const isLauncher = name.includes('launcher') || name.toLowerCase().includes('cerberus') || name.toLowerCase().includes('flame thrower') || name.toLowerCase().includes('bazooka');

                if (playerClass === 'Warrior' && !isSword) {
                    addToBattleLog(`Warriors can only equip Swords!`, 'warning');
                    return;
                } else if (playerClass === 'Mystic' && !isStaff) {
                    addToBattleLog(`Mystics can only equip Staffs!`, 'warning');
                    return;
                } else if (playerClass === 'Ranger' && !isBow) {
                    addToBattleLog(`Rangers can only equip Bows!`, 'warning');
                    return;
                } else if (playerClass === 'Launcher' && !isLauncher) {
                    addToBattleLog(`Launchers can only equip Launchers!`, 'warning');
                    return;
                }
            }

            const isAccessory = name.includes('ring') || item.isWings || name.includes('wings');

            let statType = 'attack';
            let equippedSlot = 'weapon';

            if (isArmor) {
                statType = 'defense';
                equippedSlot = 'armor';
            } else if (isAccessory) {
                // Accessories give both attack and defense usually, but let's handle the main stat or both
                // For Parsal Wristlets, they give both.
                // We need special handling for accessories
            }

            // Calculate bonuses
            const currentBonus = upgradeSystem.bonuses[itemLevel]?.[statType] || 0;
            // Note: For accessories, we might need to handle multiple stats. 
            // But current system assumes single stat type for upgrades. 
            // Let's assume accessories don't have upgrades for now or use default logic.

            // Accessory Logic
            if (isAccessory) {
                // Check if already equipped
                if (char.equipped.accessory1 === item) {
                    // Unequip from slot 1
                    char.equipped.accessory1 = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else if (char.equipped.accessory2 === item) {
                    // Unequip from slot 2
                    char.equipped.accessory2 = null;
                    char.attack -= item.stats.attack || 0;
                    char.defense -= item.stats.defense || 0;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    // Check Wings restriction before equipping
                    if (item.isWings) {
                        // Check if another Wings is already equipped
                        const hasWingsEquipped =
                            (char.equipped.accessory1?.isWings) ||
                            (char.equipped.accessory2?.isWings);

                        if (hasWingsEquipped) {
                            addToBattleLog('You can only equip one Wings item at a time!', 'warning');
                            return;
                        }
                    }

                    // Equip logic for accessories
                    // Try slot 1
                    if (!char.equipped.accessory1) {
                        char.equipped.accessory1 = item;
                        // Only add flat stats if the accessory doesn't have percentage bonuses
                        if (!item.bonusPercent) {
                            char.attack += item.stats?.attack || 0;
                            char.defense += item.stats?.defense || 0;
                        }
                        addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name} (Slot 1)!`);
                    }
                    // Try slot 2
                    else if (!char.equipped.accessory2) {
                        char.equipped.accessory2 = item;
                        // Only add flat stats if the accessory doesn't have percentage bonuses
                        if (!item.bonusPercent) {
                            char.attack += item.stats?.attack || 0;
                            char.defense += item.stats?.defense || 0;
                        }
                        addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name} (Slot 2)!`);
                    }
                    // Replace slot 1 if both full
                    else {
                        const oldItem = char.equipped.accessory1;
                        // Only remove flat stats if the old accessory doesn't have percentage bonuses
                        if (!oldItem.bonusPercent) {
                            char.attack -= oldItem.stats?.attack || 0;
                            char.defense -= oldItem.stats?.defense || 0;
                        }

                        char.equipped.accessory1 = item;
                        // Only add flat stats if the new accessory doesn't have percentage bonuses
                        if (!item.bonusPercent) {
                            char.attack += item.stats?.attack || 0;
                            char.defense += item.stats?.defense || 0;
                        }
                        addToBattleLog(`You replaced ${oldItem.name} with ${item.name} (Slot 1)!`);
                    }
                }
            } else {
                // Weapon/Armor Logic (Existing)
                const statValue = item.stats[statType] || 0;
                const totalStatBonus = statValue + currentBonus;
                const isEquipped = char.equipped[equippedSlot] === item;

                if (isEquipped) {
                    char.equipped[equippedSlot] = null;
                    char[statType] -= totalStatBonus;
                    addToBattleLog(`You unequipped ${getEmoji(item.name.toLowerCase())} ${item.name}.`);
                } else {
                    if (char.equipped[equippedSlot]) {
                        const currentItem = char.equipped[equippedSlot];
                        const currentLevel = currentItem.upgradeLevel || 0;
                        const currentItemBonus = upgradeSystem.bonuses[currentLevel]?.[statType] || 0;
                        const currentTotalStatBonus = currentItem.stats[statType] + currentItemBonus;
                        char[statType] -= currentTotalStatBonus;
                        char.equipped[equippedSlot] = null;
                    }

                    char.equipped[equippedSlot] = item;
                    char[statType] += totalStatBonus;
                    addToBattleLog(`You equipped ${getEmoji(item.name.toLowerCase())} ${item.name}!`);
                }
            }

            updateCharacterDisplay();
            updateInventoryDisplay();
            saveGameState();
        }

        // Show players modal
        function showPlayers() {
            const playersList = document.getElementById('players-list');
            playersList.innerHTML = '';

            const sortedPlayers = [...gameState.players].sort((a, b) => b.level - a.level);

            sortedPlayers.forEach((player, index) => {
                const playerRow = document.createElement('div');
                playerRow.className = 'player-row';

                playerRow.innerHTML = `
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-level">Lv. ${player.level}</div>
                `;

                playersList.appendChild(playerRow);
            });

            playersModal.style.display = 'flex';
        }

        // Global Market System
        let selectedItemForSale = null;

        // Show market modal
        // Show market modal
        function showMarket() {
            const marketModal = document.getElementById('market-modal');
            marketModal.style.display = 'flex';

            // Show browse mode by default
            document.getElementById('market-browse').classList.add('active');
            document.getElementById('market-sell').classList.remove('active');

            // Set up price input validation
            setupPriceValidation();

            // Load market data
            loadMarketItems();
        }

        // Toggle between browse and sell modes
        function toggleSellMode() {
            const browseMode = document.getElementById('market-browse');
            const sellMode = document.getElementById('market-sell');

            if (browseMode.classList.contains('active')) {
                // Switch to sell mode
                browseMode.classList.remove('active');
                sellMode.classList.add('active');
                loadSellInventory();
            } else {
                // Switch back to browse mode
                sellMode.classList.remove('active');
                browseMode.classList.add('active');
                cancelSell();
            }
        }

        // Set up price input validation to only allow numbers
        function setupPriceValidation() {
            const priceInput = document.getElementById('sell-price');
            if (priceInput) {
                // Prevent non-numeric keys
                priceInput.addEventListener('keypress', function (e) {
                    // Allow backspace, delete, tab, escape, enter, and numbers
                    if ([8, 9, 27, 13, 46].includes(e.keyCode) ||
                        (e.keyCode >= 48 && e.keyCode <= 57) || // Numbers 0-9
                        (e.keyCode >= 96 && e.keyCode <= 105)) { // Numpad 0-9
                        return;
                    }
                    e.preventDefault();
                });

                // Clean input on change
                priceInput.addEventListener('input', function (e) {
                    // Remove any non-numeric characters
                    let value = e.target.value.replace(/[^0-9]/g, '');

                    // Remove leading zeros (except for single 0)
                    if (value.length > 1 && value.startsWith('0')) {
                        value = value.replace(/^0+/, '');
                    }

                    // Limit to reasonable price range (1-999999)
                    const numValue = parseInt(value) || 0;
                    if (numValue > 999999) {
                        value = '999999';
                    }

                    e.target.value = value;
                });

                // Prevent paste of invalid characters
                priceInput.addEventListener('paste', function (e) {
                    e.preventDefault();
                    setTimeout(() => {
                        const value = e.target.value.replace(/[^0-9]/g, '');
                        e.target.value = value;
                    }, 0);
                });
            }
        }

        // ========================================
        // ARENA PVP SYSTEM
        // ========================================

        // Bot name generator
        const botNames = [
            "Iron Destroyer", "Shadow Blade", "Crimson Warrior", "Thunder Fist",
            "Steel Guardian", "Dark Avenger", "Lightning Strike", "Frost Reaper",
            "Flame Bringer", "Storm Breaker", "Void Hunter", "Chaos Knight",
            "Blood Raven", "Death Stalker", "War Machine", "Battle Titan",
            "Savage Berserker", "Silent Assassin", "Mystic Phantom", "Eternal Champion",
            "Void Walker", "Solar Flare", "Lunar Knight", "Terra Guard", "Wind Dancer",
            "Ocean Fury", "Mountain King", "Forest Ranger", "Desert Scorpion", "Jungle Beast",
            "Arctic Wolf", "Volcanic Dragon", "Storm Caller", "Shadow Hunter", "Light Bringer",
            "Dark Soul", "Blood Thirster", "Bone Breaker", "Soul Eater", "Mind Flayer",
            "Spirit Guide", "Ghost Walker", "Phantom Lancer", "Crystal Maiden", "Iron Golem",
            "Steel Titan", "Golden Knight", "Silver Samurai", "Bronze Bomber", "Copper Crusader"
        ];

        // Generate random bot with level 40 and random stats
        function generateArenaBot(rank) {
            const name = botNames[rank - 1] || `Bot ${rank}`;

            // Scaled stats based on rank (Rank 1 = Strongest, Rank 50 = Weakest)
            // Base stat range: 20 (Rank 50) to ~120 (Rank 1)
            const rankMultiplier = (50 - rank) * 2; // 0 to 98
            const baseStat = 20 + rankMultiplier;

            // Add some randomness (+/- 5)
            const variance = () => Math.floor(Math.random() * 11) - 5;

            const str = Math.max(20, baseStat + variance());
            const agi = Math.max(20, baseStat + variance());
            const vit = Math.max(20, baseStat + variance());
            const int = Math.max(20, baseStat + variance());
            const luk = Math.max(20, baseStat + variance());

            // Calculate HP, ATK, DEF based on stats (similar to player calculation)
            const hp = Math.floor(vit * 10 + 100);
            const attack = Math.floor(str * 1.0 + agi * 0.5 + 10);
            const defense = Math.floor(vit * 1.0 + 10);

            return {
                type: "bot",
                id: `bot_${rank}`,
                name: name,
                level: 40,
                stats: { str, agi, vit, int, luk },
                hp: hp,
                maxHp: hp,
                attack: attack,
                defense: defense
            };
        }

        // Initialize Arena in Firebase
        async function initializeArena() {
            try {
                const { ref, get, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const arenaRef = ref(db, 'arena');
                const snapshot = await get(arenaRef);

                // Check if we need to migrate to 50 bots
                const currentData = snapshot.val();
                const currentBotCount = currentData && currentData.rankings ? Object.keys(currentData.rankings).length : 0;

                // Check if daily reset is needed
                const needsReset = await checkAndPerformDailyReset(currentData, arenaRef, set);

                if (!snapshot.exists() || !currentData.initialized || currentBotCount < 50) {
                    console.log('Initializing or updating arena to 50 bots...');

                    // Generate 50 bots
                    const rankings = {};
                    for (let i = 1; i <= 50; i++) {
                        rankings[i] = generateArenaBot(i);
                    }

                    // Set next reset time to tomorrow at 12 PM GMT+8
                    const nextReset = getNextResetTime();

                    await set(arenaRef, {
                        initialized: true,
                        rankings: rankings,
                        playerStats: (currentData && currentData.playerStats) ? currentData.playerStats : {},
                        lastResetTime: Date.now(),
                        nextResetTime: nextReset
                    });

                    console.log('Arena initialized with 50 bots');
                } else if (!currentData.nextResetTime) {
                    // If arena is initialized but missing reset time (e.g. from update), set it
                    const nextReset = getNextResetTime();
                    await set(ref(db, 'arena/nextResetTime'), nextReset);
                    await set(ref(db, 'arena/lastResetTime'), Date.now());
                    console.log('Arena reset time initialized');
                }
            } catch (error) {
                console.error('Error initializing arena:', error);
            }
        }

        // Initialize player arena stats
        async function initializePlayerArenaStats(uid) {
            try {
                const { ref, get, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const playerStatsRef = ref(db, `arena/playerStats/${uid}`);
                const snapshot = await get(playerStatsRef);

                if (!snapshot.exists()) {
                    await set(playerStatsRef, {
                        pvpPoints: 100,
                        currentRank: null,
                        totalWins: 0,
                        totalLosses: 0,
                        highestRank: null
                    });
                }
            } catch (error) {
                console.error('Error initializing player arena stats:', error);
            }
        }

        // Get next reset time (tomorrow at 12 PM GMT+8)
        function getNextResetTime() {
            const now = new Date();
            const gmt8Offset = 8 * 60; // GMT+8 in minutes
            const localOffset = now.getTimezoneOffset(); // Local offset in minutes
            const offsetDiff = gmt8Offset + localOffset; // Difference to GMT+8

            // Create date in GMT+8
            const gmt8Now = new Date(now.getTime() + offsetDiff * 60000);

            // Set to 12 PM today
            const resetToday = new Date(gmt8Now);
            resetToday.setHours(12, 0, 0, 0);

            // If it's already past 12 PM, set to tomorrow
            if (gmt8Now >= resetToday) {
                resetToday.setDate(resetToday.getDate() + 1);
            }

            // Convert back to UTC timestamp
            return resetToday.getTime() - (offsetDiff * 60000);
        }

        // Update reset countdown timer
        function updateResetTimer(nextResetTime) {
            const timerElement = document.getElementById('arena-reset-timer');
            if (!timerElement) return;

            function update() {
                const now = Date.now();
                const diff = nextResetTime - now;

                if (diff <= 0) {
                    timerElement.textContent = 'Resetting...';
                    return;
                }

                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                timerElement.textContent = `${hours}h ${minutes}m ${seconds}s`;
            }

            // Update immediately
            update();

            // Update every second
            if (window.arenaTimerInterval) {
                clearInterval(window.arenaTimerInterval);
            }
            window.arenaTimerInterval = setInterval(update, 1000);
        }

        // Check if daily reset is needed and perform it
        async function checkAndPerformDailyReset(currentData, arenaRef, set) {
            if (!currentData || !currentData.nextResetTime) {
                return false;
            }

            const now = Date.now();
            if (now >= currentData.nextResetTime) {
                console.log('Performing daily Arena reset...');

                // Capture top 5 players BEFORE resetting to assign titles
                const oldRankings = currentData.rankings || {};
                const topPlayers = [];
                for (let rank = 1; rank <= 5; rank++) {
                    const holder = oldRankings[rank];
                    if (holder && holder.type === 'player' && holder.uid) {
                        topPlayers.push({ rank, uid: holder.uid });
                    }
                }

                // Generate new 50 bots
                const rankings = {};
                for (let i = 1; i <= 50; i++) {
                    rankings[i] = generateArenaBot(i);
                }

                // Reset all player ranks and win/loss records, but keep PVP points
                const playerStats = currentData.playerStats || {};

                // Clear all titles first
                Object.keys(playerStats).forEach(uid => {
                    playerStats[uid].currentRank = null;
                    playerStats[uid].totalWins = 0;
                    playerStats[uid].totalLosses = 0;
                    playerStats[uid].title = null; // Clear title
                    // Keep pvpPoints and highestRank
                });

                // Assign titles to top 5 players
                const titleMap = {
                    1: { name: 'Warlord', color: 'red' },
                    2: { name: 'Conqueror', color: 'orange' },
                    3: { name: 'Slayer', color: 'purple' },
                    4: { name: 'Fighter', color: 'blue' },
                    5: { name: 'Aspirant', color: 'green' }
                };

                topPlayers.forEach(({ rank, uid }) => {
                    if (playerStats[uid]) {
                        playerStats[uid].title = titleMap[rank].name;
                        console.log(`Assigned title "${titleMap[rank].name}" to player at rank ${rank}`);
                    } else {
                        // Initialize player stats if they don't exist
                        playerStats[uid] = {
                            pvpPoints: 100,
                            currentRank: null,
                            totalWins: 0,
                            totalLosses: 0,
                            title: titleMap[rank].name
                        };
                        console.log(`Initialized and assigned title "${titleMap[rank].name}" to new player at rank ${rank}`);
                    }
                });

                // Calculate next reset time
                const nextReset = getNextResetTime();

                await set(arenaRef, {
                    initialized: true,
                    rankings: rankings,
                    playerStats: playerStats,
                    lastResetTime: now,
                    nextResetTime: nextReset
                });

                console.log('Arena reset complete. Next reset:', new Date(nextReset));
                return true;
            }

            return false;
        }

        // Force regenerate arena with 50 bots
        async function forceRegenerateArena() {
            if (!confirm('This will reset the entire Arena ladder with 50 new bots. Continue?')) {
                return;
            }

            try {
                const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const arenaRef = ref(db, 'arena');
                const rankings = {};

                // Generate 50 bots
                for (let i = 1; i <= 50; i++) {
                    rankings[i] = generateArenaBot(i);
                }

                await set(arenaRef, {
                    initialized: true,
                    rankings: rankings,
                    playerStats: {}
                });

                alert('Arena regenerated with 50 bots! Reloading...');
                await loadArenaData();
            } catch (error) {
                console.error('Error regenerating arena:', error);
                alert('Failed to regenerate arena. Check console for details.');
            }
        }

        // ========================================
        // UNIVERSAL SHOP SYSTEM
        // ========================================

        // Shop items data
        const shopItems = {
            leaves: [
                {
                    id: 'intense_spadona',
                    name: 'Int Spadona',
                    icon: '🗡️',
                    type: 'weapon',
                    stats: '+50 Attack',
                    price: 15000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Int Spadona',
                        type: 'weapon',
                        stats: { attack: 50, defense: 0 },
                        rarity: 'intense',
                        sellValue: 25
                    }
                },
                {
                    id: 'intense_sickle_staff',
                    name: 'Int Sickle Staff',
                    icon: '🪄',
                    type: 'weapon',
                    stats: '+50 Attack',
                    price: 15000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Int Sickle Staff',
                        type: 'weapon',
                        stats: { attack: 50, defense: 0 },
                        rarity: 'intense',
                        sellValue: 25
                    }
                },
                {
                    id: 'intense_sickle_bow',
                    name: 'Int Sickle Bow',
                    icon: '🏹',
                    type: 'weapon',
                    stats: '+50 Attack',
                    price: 15000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Int Sickle Bow',
                        type: 'weapon',
                        stats: { attack: 50, defense: 0 },
                        rarity: 'intense',
                        sellValue: 25
                    }
                },
                {
                    id: 'intense_flame_thrower',
                    name: 'Int Flame Thrower',
                    icon: '🏹',
                    type: 'weapon',
                    stats: '+50 Attack',
                    price: 15000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Intense Flame Thrower',
                        type: 'weapon',
                        stats: { attack: 50, defense: 0 },
                        rarity: 'intense',
                        sellValue: 25
                    }
                },
                {
                    id: 'intense_elixir_robe',
                    name: 'Int Elixir Robe',
                    icon: '🥋',
                    type: 'armor',
                    stats: '+50 Attack',
                    price: 15000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Int Elixir Robe',
                        type: 'armor',
                        stats: { attack: 0, defense: 50 },
                        rarity: 'intense',
                        sellValue: 25
                    }
                },
                {
                    id: 'arghol_sword_1',
                    name: 'Arghol Blade',
                    icon: '🗡️',
                    type: 'weapon',
                    stats: '+15 Attack',
                    price: 10000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Arghol Blade',
                        type: 'weapon',
                        stats: { attack: 15, defense: 0 },
                        sellValue: 10
                    }
                },
                {
                    id: 'arghol_staff_1',
                    name: 'Arghol Staff',
                    icon: '🪄',
                    type: 'weapon',
                    stats: '+15 Attack',
                    price: 10000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Arghol Staff',
                        type: 'weapon',
                        stats: { attack: 15, defense: 0 },
                        sellValue: 10
                    }
                },
                {
                    id: 'arghol_bow_1',
                    name: 'Arghol Bow',
                    icon: '🏹',
                    type: 'weapon',
                    stats: '+15 Attack',
                    price: 10000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Arghol Bow',
                        type: 'weapon',
                        stats: { attack: 15, defense: 0 },
                        sellValue: 10
                    }
                },
                {
                    id: 'arghol_armor_1',
                    name: 'Arghol Armor',
                    icon: '🥋',
                    type: 'armor',
                    stats: '+15 Defense',
                    price: 10000,
                    currency: 'leaves',
                    itemData: {
                        name: 'Arghol Armor',
                        type: 'armor',
                        stats: { attack: 0, defense: 15 },
                        sellValue: 10
                    }
                }
            ],
            accessories: [
                {
                    id: 'tempest_ring',
                    name: 'Tempest Ring',
                    icon: '💍',
                    type: 'accessory',
                    rarity: 'legendary',
                    stats: '+30% ATK/DEF',
                    price: 5000,
                    currency: 'pvp',
                    itemData: {
                        name: 'Tempest Ring',
                        type: 'accessory',
                        slot: 'ring',
                        bonusPercent: { attack: 0.3, defense: 0.3 },
                        sellValue: 6
                    }
                },

            ],
            pvp: [
                {
                    id: 'relic_man_eater',
                    name: 'Man Eater',
                    icon: '🗡️',
                    type: 'weapon',
                    stats: '+150 Attack',
                    price: 5000,
                    currency: 'pvp',
                    itemData: {
                        name: 'Man Eater',
                        type: 'weapon',
                        stats: { attack: 150, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'relic_accelleon',
                    name: 'Accelleon',
                    icon: '🪄',
                    type: 'weapon',
                    stats: '+140 Attack',
                    price: 5000,
                    currency: 'pvp',
                    itemData: {
                        name: 'Accelleon',
                        type: 'weapon',
                        stats: { attack: 140, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'relic_valkyrie',
                    name: 'Valkyrie',
                    icon: '🏹',
                    type: 'weapon',
                    stats: '+145 Attack',
                    price: 5000,
                    currency: 'pvp',
                    itemData: {
                        name: 'Valkyrie',
                        type: 'weapon',
                        stats: { attack: 145, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'relic_cerberus',
                    name: 'Cerberus',
                    icon: '🚀',
                    type: 'weapon',
                    stats: '+148 Attack',
                    price: 5000,
                    currency: 'pvp',
                    itemData: {
                        name: 'Cerberus',
                        type: 'weapon',
                        stats: { attack: 148, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                }
            ],
            coins: [
                {
                    id: 'coin_relic_man_eater',
                    name: 'Man Eater',
                    icon: '🗡️',
                    type: 'weapon',
                    stats: '+150 Attack',
                    price: 100,
                    currency: 'coins',
                    originalTab: 'pvp',
                    itemData: {
                        name: 'Man Eater',
                        type: 'weapon',
                        stats: { attack: 150, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'coin_relic_accelleon',
                    name: 'Accelleon',
                    icon: '🪄',
                    type: 'weapon',
                    stats: '+140 Attack',
                    price: 100,
                    currency: 'coins',
                    originalTab: 'pvp',
                    itemData: {
                        name: 'Accelleon',
                        type: 'weapon',
                        stats: { attack: 140, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'coin_relic_valkyrie',
                    name: 'Valkyrie',
                    icon: '🏹',
                    type: 'weapon',
                    stats: '+145 Attack',
                    price: 100,
                    currency: 'coins',
                    originalTab: 'pvp',
                    itemData: {
                        name: 'Valkyrie',
                        type: 'weapon',
                        stats: { attack: 145, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                },
                {
                    id: 'coin_relic_cerberus',
                    name: 'Cerberus',
                    icon: '🚀',
                    type: 'weapon',
                    stats: '+148 Attack',
                    price: 100,
                    currency: 'coins',
                    originalTab: 'pvp',
                    itemData: {
                        name: 'Cerberus',
                        type: 'weapon',
                        stats: { attack: 148, defense: 0 },
                        rarity: 'relic',
                        sellValue: 35
                    }
                }
            ]
        };


        // Current shop tab state
        let currentShopTab = 'leaves';

        // Show Shop modal
        async function showShop() {
            const shopModal = document.getElementById('shop-modal');
            shopModal.style.display = 'flex';

            // Load player currencies
            await loadPlayerCurrencies();

            // Reset to leaves tab and load items
            currentShopTab = 'leaves';
            updateShopTabUI();
            loadShopItemsByTab('leaves');
        }

        // Switch shop tab
        function switchShopTab(tab) {
            currentShopTab = tab;
            updateShopTabUI();
            loadShopItemsByTab(tab);
        }

        // Update shop tab UI
        function updateShopTabUI() {
            const tabs = document.querySelectorAll('.shop-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
                const onclick = tab.getAttribute('onclick');
                if (onclick && onclick.includes(`'${currentShopTab}'`)) {
                    tab.classList.add('active');
                }
            });
        }

        // Load shop items by tab
        function loadShopItemsByTab(tab) {
            const container = document.getElementById('shop-items-container');
            if (!container) return;

            container.innerHTML = '';

            let itemsToLoad = [];

            switch (tab) {
                case 'leaves':
                    // Leaves shop includes leaves items and accessories that cost leaves
                    itemsToLoad = [
                        ...shopItems.leaves.map(item => ({ ...item, tabType: 'leaves' })),
                        ...shopItems.accessories.filter(item => item.currency === 'leaves').map(item => ({ ...item, tabType: 'leaves' }))
                    ];
                    break;
                case 'pvp':
                    // PVP shop includes pvp items and accessories that cost pvp points
                    itemsToLoad = [
                        ...shopItems.pvp.map(item => ({ ...item, tabType: 'pvp' })),
                        ...shopItems.accessories.filter(item => item.currency === 'pvp').map(item => ({ ...item, tabType: 'pvp' }))
                    ];
                    break;
                case 'coins':
                    // Coins shop includes coins items and accessories that cost coins
                    itemsToLoad = [
                        ...shopItems.coins.map(item => ({ ...item, tabType: 'coins' })),
                        ...shopItems.accessories.filter(item => item.currency === 'coins').map(item => ({ ...item, tabType: 'coins' }))
                    ];
                    break;
                default:
                    itemsToLoad = [];
            }

            if (itemsToLoad.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim);">No items available in this shop.</div>';
                return;
            }

            itemsToLoad.forEach(item => {
                const itemElement = createShopItemElement(item);
                container.appendChild(itemElement);
            });
        }

        // Load all shop items (legacy - kept for compatibility)
        function loadAllShopItems() {
            loadShopItemsByTab(currentShopTab);
        }

        // Load player currencies
        async function loadPlayerCurrencies() {
            try {
                // Load leaves (from gameState.currency)
                const leaves = gameState.currency || 0;
                document.getElementById('shop-leaves').textContent = leaves.toLocaleString();

                // Load PVP points
                if (window.currentUser) {
                    const { ref, get, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                    const playerStatsRef = ref(db, `arena/playerStats/${window.currentUser.uid}`);
                    let snapshot = await get(playerStatsRef);

                    // Initialize player stats if they don't exist
                    if (!snapshot.exists()) {
                        await set(playerStatsRef, {
                            pvpPoints: 100,
                            currentRank: null,
                            totalWins: 0,
                            totalLosses: 0,
                            highestRank: null
                        });
                        // Get the snapshot again after initialization
                        snapshot = await get(playerStatsRef);
                    }

                    if (snapshot.exists()) {
                        const playerStats = snapshot.val();
                        const pvpPoints = playerStats.pvpPoints || 100;
                        document.getElementById('shop-pvp-points').textContent = pvpPoints;
                    } else {
                        document.getElementById('shop-pvp-points').textContent = '100';
                    }
                }

                // Load coins (from gameState.coins)
                const coins = gameState.coins || 0;
                document.getElementById('shop-coins').textContent = coins.toLocaleString();

            } catch (error) {
                console.error('Error loading currencies:', error);
                document.getElementById('shop-leaves').textContent = '0';
                document.getElementById('shop-pvp-points').textContent = '100';
                document.getElementById('shop-coins').textContent = '0';
            }
        }


        // Create shop item element
        function createShopItemElement(item) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shop-item';

            // Check if player can afford the item
            let canAfford = false;
            let currencyElement;

            switch (item.currency) {
                case 'leaves':
                    currencyElement = document.getElementById('shop-leaves');
                    const leaves = parseInt(currencyElement.textContent.replace(/,/g, '')) || 0;
                    canAfford = leaves >= item.price;
                    break;
                case 'pvp':
                    currencyElement = document.getElementById('shop-pvp-points');
                    const pvpPoints = parseInt(currencyElement.textContent) || 0;
                    canAfford = pvpPoints >= item.price;
                    break;
                case 'coins':
                    currencyElement = document.getElementById('shop-coins');
                    const coins = parseInt(currencyElement.textContent.replace(/,/g, '')) || 0;
                    canAfford = coins >= item.price;
                    break;
            }

            let rarityClass = '';
            if (item.itemData) {
                if (item.itemData.rarity === 'intense') rarityClass = 'item-rarity-intense';
                else if (item.itemData.rarity === 't1') rarityClass = 'item-rarity-t1';
                else if (item.itemData.rarity === 'relic') rarityClass = 'item-rarity-relic';
            }

            itemDiv.innerHTML = `
                <div class="shop-item-header">
                    <div class="shop-item-left">
                        <div class="shop-item-icon">${item.icon}</div>
                        <div class="shop-item-name ${rarityClass}">${item.name}</div>
                    </div>
                    <div class="shop-item-price">${item.price.toLocaleString()} ${getCurrencyIcon(item.currency)}</div>
                </div>
                <div class="shop-item-stats">${item.stats}</div>
                <button class="shop-buy-btn ${item.currency}" onclick="buyShopItem('${item.id}')" ${canAfford ? '' : 'disabled'}>
                    ${canAfford ? 'Purchase' : 'Cannot Afford'}
                </button>
            `;

            return itemDiv;
        }

        // Get currency icon
        function getCurrencyIcon(currency) {
            switch (currency) {
                case 'leaves': return '🍃';
                case 'pvp': return '⚔️';
                case 'coins': return '🪙';
                default: return '';
            }
        }

        // Buy shop item
        async function buyShopItem(itemId) {
            try {
                // Find the item across all tabs
                let item = null;

                for (const [tab, items] of Object.entries(shopItems)) {
                    const foundItem = items.find(i => i.id === itemId);
                    if (foundItem) {
                        item = foundItem;
                        break;
                    }
                }

                if (!item) {
                    alert('Item not found!');
                    return;
                }

                if (!window.currentUser) {
                    alert('You must be logged in to purchase items.');
                    return;
                }

                // Process purchase based on currency
                let success = false;

                switch (item.currency) {
                    case 'leaves':
                        success = await processLeavesPurchase(item.price);
                        break;
                    case 'pvp':
                        success = await processPVPPurchase(item.price);
                        break;
                    case 'coins':
                        success = await processCoinsPurchase(item.price);
                        break;
                }

                if (success) {
                    try {
                        // Add item to player's inventory
                        await addItemToInventory(item.itemData);

                        // Show success message
                        addToBattleLog(`🏪 Purchased ${item.name} for ${item.price.toLocaleString()} ${getCurrencyIcon(item.currency)}!`, 'success');

                        // Update currency displays and reload all items
                        await loadPlayerCurrencies();
                        loadAllShopItems();

                        // Refresh inventory display
                        updateInventoryDisplay();
                    } catch (inventoryError) {
                        console.error('Error adding item to inventory:', inventoryError);
                        alert('Purchase successful but failed to add item to inventory. Please contact support.');
                        // Note: Currency was already deducted, so we don't refund it here
                    }
                }

            } catch (error) {
                console.error('Error buying shop item:', error);
                alert('Failed to purchase item. Please try again.');
            }
        }

        // Process leaves purchase
        async function processLeavesPurchase(price) {
            try {
                const currentLeaves = gameState.currency || 0;

                if (currentLeaves < price) {
                    alert('Not enough leaves!');
                    return false;
                }

                // Deduct leaves
                gameState.currency = currentLeaves - price;

                // Update the main UI display
                document.getElementById('currency-amount').textContent = gameState.currency;

                // Save game state
                await saveGameState();

                return true;
            } catch (error) {
                console.error('Error processing leaves purchase:', error);
                return false;
            }
        }

        // Process PVP purchase
        async function processPVPPurchase(price) {
            try {
                const { ref, runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const playerStatsRef = ref(db, `arena/playerStats/${window.currentUser.uid}`);

                let success = false;

                await runTransaction(playerStatsRef, (playerStats) => {
                    if (!playerStats) {
                        playerStats = {
                            pvpPoints: 100,
                            currentRank: null,
                            totalWins: 0,
                            totalLosses: 0,
                            highestRank: null
                        };
                    }

                    if ((playerStats.pvpPoints || 100) < price) {
                        alert('Not enough PVP points!');
                        return; // Cancel transaction
                    }

                    // Deduct points
                    playerStats.pvpPoints = (playerStats.pvpPoints || 100) - price;
                    success = true;

                    return playerStats;
                });

                return success;
            } catch (error) {
                console.error('Error processing PVP purchase:', error);
                return false;
            }
        }

        // Process coins purchase
        async function processCoinsPurchase(price) {
            try {
                const currentCoins = gameState.coins || 0;

                if (currentCoins < price) {
                    alert('Not enough coins!');
                    return false;
                }

                // Deduct coins
                gameState.coins = currentCoins - price;

                // Update the main UI display
                document.getElementById('coins-amount').textContent = gameState.coins;

                // Save game state
                await saveGameState();

                return true;
            } catch (error) {
                console.error('Error processing coins purchase:', error);
                return false;
            }
        }

        // Add item to player's inventory
        async function addItemToInventory(itemData) {
            try {
                if (!gameState.character) {
                    alert('No character found!');
                    return;
                }

                // Add to inventory (create a deep copy to prevent reference sharing)
                gameState.inventory = gameState.inventory || [];
                gameState.inventory.push(JSON.parse(JSON.stringify(itemData)));

                // Save game state
                await saveGameState();

            } catch (error) {
                console.error('Error adding item to inventory:', error);
                throw error;
            }
        }

        // Make shop functions globally accessible
        window.showShop = showShop;
        window.buyShopItem = buyShopItem;
        window.switchShopTab = switchShopTab;

        // ========================================
        // ACCESSORY BONUS SYSTEM
        // ========================================

        // Calculate effective stats including accessory percentage bonuses
        function calculateEffectiveStats() {
            const char = gameState.character;
            if (!char) return { attack: 0, defense: 0 };

            // Base stats
            let effectiveAttack = char.attack || 0;
            let effectiveDefense = char.defense || 0;

            // Calculate percentage bonuses from accessories
            let attackMultiplier = 1.0;
            let defenseMultiplier = 1.0;

            // Check all equipped accessories for percentage bonuses
            const accessorySlots = ['accessory1', 'accessory2', 'ring', 'necklace', 'wrist'];
            accessorySlots.forEach(slot => {
                const accessory = char.equipped?.[slot];
                if (accessory && accessory.bonusPercent) {
                    if (accessory.bonusPercent.attack) {
                        attackMultiplier += accessory.bonusPercent.attack;
                    }
                    if (accessory.bonusPercent.defense) {
                        defenseMultiplier += accessory.bonusPercent.defense;
                    }
                }
            });

            // Apply multipliers
            effectiveAttack = Math.floor(effectiveAttack * attackMultiplier);
            effectiveDefense = Math.floor(effectiveDefense * defenseMultiplier);

            return {
                attack: effectiveAttack,
                defense: effectiveDefense,
                attackMultiplier: attackMultiplier,
                defenseMultiplier: defenseMultiplier
            };
        }

        // ========================================
        // END ACCESSORY BONUS SYSTEM
        // ========================================

        // ========================================
        // END UNIVERSAL SHOP SYSTEM
        // ========================================

        // Show Arena modal
        async function showArena() {
            // Check if a battle is already in progress
            if (gameState.arenaBattleInProgress) {
                addToBattleLog('⚔️ You have an ongoing Arena battle! Please wait for it to finish.', 'warning');
                return;
            }

            // Switch to Battle Log tab on mobile
            if (window.switchTab) switchTab('battle');

            const arenaModal = document.getElementById('arena-modal');
            arenaModal.style.display = 'flex';

            // Initialize arena if needed
            await initializeArena();

            // Initialize player stats if needed
            if (window.currentUser) {
                await initializePlayerArenaStats(window.currentUser.uid);
            }

            // Load arena data
            await loadArenaData();
        }

        // Load arena data and display
        async function loadArenaData() {
            try {
                const { ref, get, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const arenaRef = ref(db, 'arena');

                // Use onValue for real-time updates
                onValue(arenaRef, async (snapshot) => {
                    const arenaData = snapshot.val();
                    if (!arenaData) return;

                    // Load player stats
                    let playerStats = null;
                    if (window.currentUser) {
                        playerStats = arenaData.playerStats[window.currentUser.uid] || {
                            pvpPoints: 100,
                            currentRank: null,
                            totalWins: 0,
                            totalLosses: 0
                        };
                    }

                    // Update player stats display
                    if (playerStats) {
                        document.getElementById('player-arena-rank').textContent =
                            playerStats.currentRank || 'Unranked';
                        document.getElementById('player-pvp-points').textContent =
                            playerStats.pvpPoints || 100;
                        document.getElementById('player-arena-record').textContent =
                            `${playerStats.totalWins || 0}W - ${playerStats.totalLosses || 0}L`;
                    }

                    // Update countdown timer
                    if (arenaData.nextResetTime) {
                        updateResetTimer(arenaData.nextResetTime);
                    }

                    // Display ladder
                    const ladderContent = document.getElementById('arena-ladder-content');
                    ladderContent.innerHTML = '';

                    const rankings = arenaData.rankings;
                    for (let rank = 1; rank <= 50; rank++) {
                        const holder = rankings[rank];
                        if (!holder) continue;

                        const row = document.createElement('div');
                        row.className = 'arena-ladder-row';

                        // Highlight player's row
                        if (holder.type === 'player' && window.currentUser && holder.uid === window.currentUser.uid) {
                            row.classList.add('player-row');
                        }

                        const isBot = holder.type === 'bot';

                        // Challenge Logic
                        let canChallenge = false;

                        if (playerStats && playerStats.currentRank) {
                            // Ranked player: Can challenge up to 3 ranks ahead (numerically lower)
                            // e.g. Rank 20 can challenge 19, 18, 17
                            const diff = playerStats.currentRank - rank;
                            canChallenge = (diff > 0 && diff <= 3);
                        } else {
                            // Unranked player: Can challenge bottom 4 ranks (47-50) to enter ladder
                            canChallenge = (rank >= 47);
                        }

                        row.innerHTML = `
                            <div class="arena-rank">#${rank}</div>
                            <div class="arena-name ${!isBot ? 'arena-name-clickable' : ''}" 
                                 ${!isBot ? `onclick="inspectPlayer(${rank})"` : ''} 
                                 title="${!isBot ? 'Click to inspect' : ''}">
                                <span class="arena-rank-inline">#${rank}</span>
                                ${isBot ? '🔹' : '🔸'} ${holder.name}
                            </div>
                            <div class="arena-level">Lv ${holder.level}</div>
                            <div class="arena-stats-preview">
                                <span class="mobile-level">• Lv ${holder.level}</span>
                                ATK: ${holder.attack} | DEF: ${holder.defense}
                            </div>
                            <div class="arena-action">
                                ${canChallenge ?
                                `<button class="btn-challenge" onclick="challengeArenaOpponent(${rank})">Fight</button>` :
                                `<button class="btn-challenge" disabled style="opacity: 0.5; cursor: not-allowed;">—</button>`
                            }
                            </div>
                        `;

                        ladderContent.appendChild(row);
                    }

                    // Auto-scroll to player's rank
                    setTimeout(() => {
                        const playerRow = ladderContent.querySelector('.player-row');
                        if (playerRow) {
                            playerRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        } else {
                            // If unranked, scroll to bottom
                            ladderContent.scrollTop = ladderContent.scrollHeight;
                        }
                    }, 100);
                });

            } catch (error) {
                console.error('Error loading arena data:', error);
                document.getElementById('arena-ladder-content').innerHTML =
                    '<div class="arena-loading">Error loading arena. Please try again.</div>';
            }
        }

        // Challenge opponent in arena
        async function challengeArenaOpponent(targetRank) {
            if (!window.currentUser) {
                alert('You must be logged in to challenge opponents!');
                return;
            }

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Get current arena state
                const arenaRef = ref(db, 'arena');
                const snapshot = await get(arenaRef);
                const arenaData = snapshot.val();

                const opponent = arenaData.rankings[targetRank];
                if (!opponent) {
                    alert('Opponent not found!');
                    return;
                }

                // Close arena modal and set battle in progress
                // Close arena modal and set battle in progress
                document.getElementById('arena-modal').style.display = 'none';
                gameState.arenaBattleInProgress = true;

                // Switch to battle log on mobile
                if (window.switchTab && window.innerWidth <= 768) {
                    switchTab('battle');
                }

                // Create player snapshot for battle
                const char = gameState.character;
                const effectiveStats = calculateEffectiveStats();
                const playerSnapshot = {
                    name: char.name,
                    level: char.level,
                    class: char.class,
                    hp: char.maxHp,
                    maxHp: char.maxHp,
                    fp: char.fp,
                    maxFp: char.maxFp,
                    attack: effectiveStats.attack,
                    defense: effectiveStats.defense,
                    criticalChance: char.criticalChance || 0.05,
                    lifesteal: char.equipped?.weapon?.lifesteal || null,
                    damageReduction: char.equipped?.armor?.damageReduction || 0
                };

                // Create opponent snapshot
                const opponentSnapshot = {
                    name: opponent.name,
                    level: opponent.level,
                    hp: opponent.maxHp || opponent.hp,
                    maxHp: opponent.maxHp || opponent.hp,
                    attack: opponent.attack,
                    defense: opponent.defense,
                    criticalChance: 0.05
                };

                // Run battle - styled announcement
                addArenaLog(`<span style="color: #ffa500;">⚔️ <b>ARENA BATTLE:</b> ${playerSnapshot.name} vs ${opponentSnapshot.name}!</span>`);

                const battleResult = await simulateArenaBattle(playerSnapshot, opponentSnapshot);

                // Process battle result and save fight log
                if (battleResult.winner === 'player') {
                    addToBattleLog(`🏆 Victory! You defeated ${opponentSnapshot.name}!`, 'success');
                    await processArenaVictory(targetRank, opponent);
                    await saveFightLog(playerSnapshot.name, opponentSnapshot.name, 'win', opponent.uid);
                } else {
                    addToBattleLog(`💀 Defeat! You were defeated by ${opponentSnapshot.name}!`, 'damage');
                    await processArenaDefeat();
                    await saveFightLog(playerSnapshot.name, opponentSnapshot.name, 'loss', opponent.uid);
                }

                // Battle is complete, allow Arena access again
                gameState.arenaBattleInProgress = false;

            } catch (error) {
                console.error('Error in arena challenge:', error);
                alert('Failed to start arena battle. Please try again.');
                gameState.arenaBattleInProgress = false;
            }
        }

        // Helper to add HTML logs for Arena
        function addArenaLog(htmlContent, className = '') {
            const battleLog = document.getElementById('battle-log');
            if (!battleLog) return;

            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            const timeSpan = `<span class="log-time">[${time}]</span> `;

            entry.innerHTML = timeSpan + htmlContent;

            if (className) {
                entry.classList.add(className);
            }

            // Insert before the exploring animation to keep it at the bottom, same as addToBattleLog
            const exploringAnimation = document.getElementById('exploring-animation');
            if (exploringAnimation) {
                battleLog.insertBefore(entry, exploringAnimation);
            } else {
                battleLog.appendChild(entry);
            }
            requestAnimationFrame(() => {
                const target = exploringAnimation && exploringAnimation.style.display !== 'none'
                    ? exploringAnimation
                    : entry;
                target.scrollIntoView({ block: 'end' });
                battleLog.scrollTop = battleLog.scrollHeight;
            });

            // Limit logs
            while (battleLog.children.length > 50) {
                battleLog.removeChild(battleLog.firstChild);
            }
        }

        // Simulate arena battle with skills, lifesteal, damage reduction and dramatic pacing
        async function simulateArenaBattle(player, opponent) {
            let playerHp = player.hp;
            let opponentHp = opponent.hp;
            let playerFp = player.fp || 100;
            let turn = 0;
            const maxTurns = 100;

            // Preparation phase - 2 second delay
            addArenaLog(`⏳ Preparing for battle...`);
            await new Promise(resolve => setTimeout(resolve, 2000));

            while (playerHp > 0 && opponentHp > 0 && turn < maxTurns) {
                turn++;

                // ========== OPPONENT'S TURN (DEFENDER ATTACKS FIRST) ==========
                // Base damage calculation
                let opponentDamage = Math.max(1, opponent.attack - Math.floor(player.defense / 2));

                // Apply player's damage reduction from armor
                if (player.damageReduction > 0) {
                    const reducedAmount = Math.floor(opponentDamage * player.damageReduction);
                    opponentDamage = Math.max(1, opponentDamage - reducedAmount);
                }

                const opponentCrit = Math.random() < opponent.criticalChance;
                if (opponentCrit) {
                    opponentDamage = Math.floor(opponentDamage * 1.5);
                }

                // Opponent skill usage (20% chance for bots)
                let opponentSkillUsed = false;
                if (Math.random() < 0.2 && opponent.level >= 10) {
                    opponentDamage = Math.floor(opponentDamage * 1.5);
                    opponentSkillUsed = true;
                }

                playerHp -= opponentDamage;

                // Log opponent's attack with 3 second delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                if (opponentSkillUsed) {
                    const skillName = opponent.level >= 30 ? 'Elite Strike' :
                        opponent.level >= 20 ? 'Expert Slash' : 'Power Attack';
                    addArenaLog(`${opponent.name} uses <span class="log-level">${skillName}</span>! Deals <span class="log-damage">${opponentDamage} damage</span>.`);
                } else if (opponentCrit) {
                    addArenaLog(`⚡ ${opponent.name} lands a <span class="log-level">CRITICAL HIT</span>! Deals <span class="log-damage">${opponentDamage} damage</span>.`);
                } else {
                    addArenaLog(`${opponent.name} attacks for <span class="log-damage">${opponentDamage} damage</span>.`);
                }

                if (playerHp <= 0) {
                    return { winner: 'opponent', turns: turn };
                }

                // ========== PLAYER'S TURN (CHALLENGER ATTACKS SECOND) ==========
                // Base damage calculation (matching monster combat)
                const basePlayerDamage = Math.max(1, player.attack - Math.floor(opponent.defense / 3));
                const playerCrit = Math.random() < player.criticalChance;
                const critMultiplier = playerCrit ? 1.5 : 1;
                let playerDamage = Math.floor(basePlayerDamage * critMultiplier);

                // Skill usage (30% chance, matching monster combat)
                let skillUsed = null;
                const mySkills = classSkills[player.class] || [];
                const availableSkills = mySkills.filter(skill => player.level >= skill.level && playerFp >= skill.fpCost);

                if (availableSkills.length > 0 && Math.random() < 0.3) {
                    const randomSkillIndex = Math.floor(Math.random() * availableSkills.length);
                    skillUsed = availableSkills[randomSkillIndex];
                    playerDamage = Math.floor(playerDamage * skillUsed.damageMult);
                    playerFp -= skillUsed.fpCost;
                }

                opponentHp -= playerDamage;

                // Log player's attack with 3 second delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                if (skillUsed) {
                    addArenaLog(`${player.name} uses <span style="color: #00ffff;">${skillUsed.name}</span>! Deals <span class="log-player-damage">${playerDamage} damage</span>.`);
                } else if (playerCrit) {
                    addArenaLog(`⚡ ${player.name} lands a <span class="log-level">CRITICAL HIT</span>! Deals <span class="log-player-damage">${playerDamage} damage</span>.`);
                } else {
                    addArenaLog(`${player.name} attacks for <span class="log-player-damage">${playerDamage} damage</span>.`);
                }

                // Lifesteal (from equipped weapon)
                if (player.lifesteal && Math.random() < player.lifesteal.chance) {
                    const healAmount = Math.floor(playerDamage * player.lifesteal.multiplier);
                    if (healAmount > 0) {
                        playerHp = Math.min(player.maxHp, playerHp + healAmount);
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        addArenaLog(`💚 Lifesteal! ${player.name} recovers <span style="color: #00ff00;">${healAmount} HP</span>.`);
                    }
                }

                if (opponentHp <= 0) {
                    return { winner: 'player', turns: turn };
                }
            }

            // Timeout - whoever has more HP wins
            return { winner: playerHp > opponentHp ? 'player' : 'opponent', turns: turn };
        }

        // Process arena victory
        async function processArenaVictory(targetRank, defeatedOpponent) {
            try {
                const { ref, runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const arenaRef = ref(db, 'arena');
                const uid = window.currentUser.uid;

                await runTransaction(arenaRef, (arenaData) => {
                    if (!arenaData) return arenaData;

                    // Get player's current rank
                    const playerStats = arenaData.playerStats[uid] || {
                        pvpPoints: 100,
                        currentRank: null,
                        totalWins: 0,
                        totalLosses: 0,
                        highestRank: null
                    };

                    const playerCurrentRank = playerStats.currentRank;

                    // Create player data for rankings
                    const char = gameState.character;
                    const playerData = {
                        type: "player",
                        uid: uid,
                        name: char.name,
                        level: char.level,
                        hp: char.maxHp,
                        maxHp: char.maxHp,
                        attack: char.attack,
                        defense: char.defense
                    };

                    // Swap ranks
                    if (playerCurrentRank) {
                        // Player has a rank, swap positions
                        arenaData.rankings[playerCurrentRank] = defeatedOpponent;
                        arenaData.rankings[targetRank] = playerData;

                        // Update defeated player's rank if they're a player
                        if (defeatedOpponent.type === 'player') {
                            arenaData.playerStats[defeatedOpponent.uid].currentRank = playerCurrentRank;
                        }
                    } else {
                        // Player is unranked, take target's spot
                        arenaData.rankings[targetRank] = playerData;

                        // Defeated opponent becomes unranked
                        if (defeatedOpponent.type === 'player') {
                            arenaData.playerStats[defeatedOpponent.uid].currentRank = null;
                        }
                    }

                    // Update player stats
                    playerStats.currentRank = targetRank;
                    playerStats.pvpPoints += 10;
                    playerStats.totalWins += 1;
                    playerStats.highestRank = playerStats.highestRank ?
                        Math.min(playerStats.highestRank, targetRank) : targetRank;

                    arenaData.playerStats[uid] = playerStats;
                    return arenaData;
                });

                addToBattleLog(`📈 +10 PVP Points! You are now Rank #${targetRank} !`, 'success');

            } catch (error) {
                console.error('Error processing arena victory:', error);
                addToBattleLog('⚠️ Error updating arena rankings. Please try again.', 'warning');
            }
        }

        // Inspect Player
        async function inspectPlayer(rank) {
            const modal = document.getElementById('inspect-modal');
            const loading = document.getElementById('inspect-loading');
            const content = document.getElementById('inspect-data');

            modal.style.display = 'flex';
            loading.style.display = 'block';
            content.style.display = 'none';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Get arena data for basic info
                const arenaRef = ref(db, 'arena/rankings/' + rank);
                const snapshot = await get(arenaRef);
                const playerData = snapshot.val();

                if (!playerData) {
                    throw new Error('Player not found');
                }

                // If it's a bot, we can't inspect (UI shouldn't allow this anyway)
                if (playerData.type === 'bot') {
                    alert('Cannot inspect bots.');
                    modal.style.display = 'none';
                    return;
                }

                // Fetch detailed profile and equipment from user node
                // This ensures we get the latest live data
                const userProfileRef = ref(db, `users/${playerData.uid}/profile`);
                const userStatsRef = ref(db, `users/${playerData.uid}/stats`);
                const userEquipRef = ref(db, `users/${playerData.uid}/equipment`);
                const userGuildRef = ref(db, `users/${playerData.uid}/guild`);

                const [profileSnap, statsSnap, equipSnap, guildSnap] = await Promise.all([
                    get(userProfileRef),
                    get(userStatsRef),
                    get(userEquipRef),
                    get(userGuildRef)
                ]);

                const profile = profileSnap.val() || {};
                const stats = statsSnap.val() || {};
                const equipment = equipSnap.val() || {};
                const guildData = guildSnap.val();

                // Populate Modal
                document.getElementById('inspect-name').textContent = playerData.name;
                document.getElementById('inspect-details').textContent =
                    `Level ${playerData.level} • ${profile.race || 'Unknown'} • ${profile.class || 'Unknown'}`;

                // Display guild
                const inspectGuild = document.getElementById('inspect-guild');
                if (guildData && guildData.guildName) {
                    inspectGuild.textContent = `Guild: ${guildData.guildName}`;
                    inspectGuild.style.display = 'block';
                } else {
                    inspectGuild.textContent = 'Guild: None';
                    inspectGuild.style.display = 'block';
                }

                document.getElementById('inspect-hp').textContent = stats.maxHp || playerData.maxHp;
                document.getElementById('inspect-atk').textContent = stats.attack || playerData.attack;
                document.getElementById('inspect-def').textContent = stats.defense || playerData.defense;

                // Populate Gear
                const gearList = document.getElementById('inspect-gear-list');
                gearList.innerHTML = '';

                const gearSlots = [
                    { key: 'weapon', icon: '⚔️', label: 'Weapon' },
                    { key: 'armor', icon: '🛡️', label: 'Armor' },
                    { key: 'accessory1', icon: '💍', label: 'Accessory 1' },
                    { key: 'accessory2', icon: '💍', label: 'Accessory 2' },
                    { key: 'wings', icon: '🪽', label: 'Wings' }
                ];

                let hasGear = false;
                gearSlots.forEach(slot => {
                    const item = equipment[slot.key];
                    if (item) {
                        hasGear = true;
                        let statsText = '';
                        if (item.stats) {
                            statsText = Object.entries(item.stats)
                                .filter(([key, val]) => {
                                    // Filter out defense: 0 for weapons, but keep it for armor
                                    if (key === 'defense' && val === 0 && slot.key !== 'armor') {
                                        return false;
                                    }
                                    return val > 0;
                                })
                                .map(([key, val]) => {
                                    if (key === 'defense') {
                                        return `DEFENSE: +${val}`;
                                    }
                                    return `${key.toUpperCase()}: +${val}`;
                                })
                                .join(' | ');
                        }

                        // Add damage reduction for armor items
                        if (slot.key === 'armor' && item.damageReduction && item.damageReduction > 0) {
                            const dmgRedText = `DMG Red. ${item.damageReduction * 100}%`;
                            statsText = statsText ? `${statsText} | ${dmgRedText}` : dmgRedText;
                        }

                        if (item.isWings && item.movementSpeed) {
                            statsText += ` | SPD: ${item.movementSpeed}`;
                        }

                        const gearHtml = `
                            <div class="inspect-gear-item">
                                <div class="inspect-gear-icon">${slot.icon}</div>
                                <div class="inspect-gear-info">
                                    <div class="inspect-gear-name">${item.name} <span style="color: var(--accent-color); font-size: 0.8rem;">+${item.upgradeLevel || 0}</span></div>
                                    <div class="inspect-gear-stats">${statsText}</div>
                                </div>
                            </div>
                        `;
                        gearList.innerHTML += gearHtml;
                    }
                });

                if (!hasGear) {
                    gearList.innerHTML = '<div class="inspect-empty">No equipment found.</div>';
                }

                // Show Content
                loading.style.display = 'none';
                content.style.display = 'block';

            } catch (error) {
                console.error('Error inspecting player:', error);
                alert('Failed to load player details.');
                modal.style.display = 'none';
            }
        }

        // Process arena defeat
        async function processArenaDefeat() {
            try {
                const { ref, runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const playerStatsRef = ref(db, `arena/playerStats/${window.currentUser.uid}`);

                await runTransaction(playerStatsRef, (playerStats) => {
                    if (!playerStats) {
                        playerStats = {
                            pvpPoints: 100,
                            currentRank: null,
                            totalWins: 0,
                            totalLosses: 0,
                            highestRank: null
                        };
                    }

                    // Deduct points (minimum 0)
                    playerStats.pvpPoints = Math.max(0, (playerStats.pvpPoints || 100) - 5);
                    playerStats.totalLosses = (playerStats.totalLosses || 0) + 1;

                    return playerStats;
                });

                addToBattleLog(`📉 -5 PVP Points. Keep training and try again!`, 'warning');

            } catch (error) {
                console.error('Error processing arena defeat:', error);
            }
        }

        // Show Challenge Logs modal
        async function showChallengeLogs() {
            const modal = document.getElementById('challenge-logs-modal');
            const content = document.getElementById('challenge-logs-content');

            modal.style.display = 'flex';
            content.innerHTML = '<div style="color: var(--text-dim); text-align: center; padding: 2rem;">Loading...</div>';

            if (!window.currentUser) {
                content.innerHTML = '<div style="color: var(--text-dim); text-align: center; padding: 2rem;">Please log in to view logs.</div>';
                return;
            }

            try {
                const { ref, get, query, orderByChild, limitToLast } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const logsRef = ref(db, `arena/fightLogs/${window.currentUser.uid}`);
                const logsQuery = query(logsRef, orderByChild('timestamp'), limitToLast(20));
                const snapshot = await get(logsQuery);

                if (!snapshot.exists()) {
                    content.innerHTML = '<div style="color: var(--text-dim); text-align: center; padding: 2rem;">No challenge logs yet. Start fighting in the Arena!</div>';
                    return;
                }

                // Convert to array and sort by timestamp (newest first)
                const logs = [];
                snapshot.forEach(child => {
                    logs.push({ id: child.key, ...child.val() });
                });
                logs.sort((a, b) => b.timestamp - a.timestamp);

                // Build HTML
                content.innerHTML = logs.map(log => {
                    const isWin = log.result === 'win';
                    const icon = isWin ? '🏆' : '💀';
                    const bgColor = isWin ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
                    const resultText = isWin ? '<span style="color: var(--success);">WON</span>' : '<span style="color: var(--danger);">LOST</span>';
                    const isChallenged = log.type === 'challenged';
                    const actionText = isChallenged ? '<span style="color: #f39c12;">You challenged</span>' : '<span style="color: #3498db;">You were challenged by</span>';
                    const timeAgo = getTimeAgo(log.timestamp);

                    return `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: ${bgColor}; border-radius: 6px; border-left: 3px solid ${isWin ? 'var(--success)' : 'var(--danger)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">${icon} ${actionText} <b>${log.opponent}</b></div>
                            <div style="text-align: right; white-space: nowrap;">
                                ${resultText}
                                <span style="color: var(--text-dim); font-size: 0.8rem; margin-left: 0.8rem;">${timeAgo}</span>
                            </div>
                        </div>
                    </div>`;
                }).join('');

            } catch (error) {
                console.error('Error loading challenge logs:', error);
                content.innerHTML = '<div style="color: var(--danger); text-align: center; padding: 2rem;">Error loading logs.</div>';
            }
        }

        // Save fight log to Firebase for both players
        async function saveFightLog(challengerName, opponentName, result, opponentUid) {
            try {
                const { ref, push } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const timestamp = Date.now();
                const myUid = window.currentUser.uid;

                // Save log for challenger (current player)
                const myLogRef = ref(db, `arena/fightLogs/${myUid}`);
                await push(myLogRef, {
                    type: 'challenged',
                    opponent: opponentName,
                    result: result,
                    timestamp: timestamp
                });

                // Save log for opponent (if they're a real player)
                if (opponentUid && opponentUid !== 'bot') {
                    const theirLogRef = ref(db, `arena/fightLogs/${opponentUid}`);
                    await push(theirLogRef, {
                        type: 'challenged_by',
                        opponent: challengerName,
                        result: result === 'win' ? 'loss' : 'win',
                        timestamp: timestamp
                    });
                }

            } catch (error) {
                console.error('Error saving fight log:', error);
            }
        }

        // Helper function to get time ago string
        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        // Make arena functions globally accessible
        window.showArena = showArena;
        window.challengeArenaOpponent = challengeArenaOpponent;
        window.showChallengeLogs = showChallengeLogs;

        // ========================================
        // END ARENA PVP SYSTEM
        // ========================================

        // Market view switching
        function showBrowseMarket() {
            switchMarketView('browse');
        }

        function showSellInterface() {
            switchMarketView('sell');
            loadSellInventory();
        }

        function showMyListings() {
            switchMarketView('listings');
            loadMyListings();
        }

        function switchMarketView(viewName) {
            // Hide all views
            document.querySelectorAll('.market-view').forEach(view => {
                view.classList.remove('active');
            });

            // Show selected view
            document.getElementById(`market-${viewName}`).classList.add('active');
        }

        // Load market items for browsing
        function loadMarketItems() {
            const marketItems = document.getElementById('market-items');
            marketItems.innerHTML = '<div class="loading">Loading market items...</div>';

            // Wait for Firebase
            if (!window.db) {
                setTimeout(loadMarketItems, 500);
                return;
            }

            try {
                // Use Firebase for market listings
                import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js')
                    .then(({ ref, onValue }) => {
                        const marketRef = ref(window.db, 'market');

                        // Set up listener
                        onValue(marketRef, (snapshot) => {
                            const listings = snapshot.val() || {};

                            // Filter active listings
                            const activeListings = Object.entries(listings).filter(([id, listing]) =>
                                listing && listing.status === 'active'
                            );

                            if (activeListings.length === 0) {
                                marketItems.innerHTML = `
                                    <div class="empty-state">
                                        <div class="empty-icon">🛒</div>
                                        <h3>No Items for Sale</h3>
                                        <p>Be the first to list an item! Start selling your gear to other players.</p>
                                        <button class="sell-btn" onclick="toggleSellMode()">
                                            <span class="btn-icon">💰</span> Start Selling
                                        </button>
                                    </div>
                                `;
                                return;
                            }

                            // Convert to array and sort by newest first
                            const itemsArray = activeListings.map(([id, listing]) => ({
                                id,
                                ...listing
                            })).sort((a, b) => b.timestamp - a.timestamp);

                            marketItems.innerHTML = '';

                            itemsArray.forEach(listing => {
                                const itemElement = document.createElement('div');
                                itemElement.className = 'market-item';

                                // Format stats nicely
                                let statsText = '';
                                if (listing.item.stats) {
                                    const stats = Object.entries(listing.item.stats);
                                    if (stats.length > 0) {
                                        statsText = stats.map(([stat, value]) => {
                                            const icon = stat === 'attack' ? '⚔️' :
                                                stat === 'defense' ? '🛡️' :
                                                    stat === 'criticalChance' ? '💥' : '✨';
                                            return `${icon} ${stat}: +${value}`;
                                        }).join(' • ');
                                    }
                                }

                                const itemName = listing.item.upgradeLevel > 0 ? `${listing.item.name} +${listing.item.upgradeLevel}` : listing.item.name;
                                const isMyItem = window.currentUser && listing.sellerId === window.currentUser.uid;
                                const isSold = listing.status === 'sold';

                                itemElement.innerHTML = `
                                    <div class="market-item-header">
                                        <div class="market-item-name">${itemName}</div>
                                        <div class="market-item-price">${listing.price} <span class="currency-icon">🍃</span></div>
                                    </div>
                                    <div class="market-item-stats">
                                        ${statsText || 'No special stats'}
                                    </div>
                                    <div class="market-item-footer">
                                        <div class="market-item-seller">Seller: ${listing.sellerName || 'Anonymous'}</div>
                                        ${isMyItem ?
                                        `<button class="btn btn-secondary" disabled>Your Listing</button>` :
                                        `<button class="btn btn-success" onclick="buyMarketItem('${listing.id}')">
                                                <span class="btn-icon">🛒</span> Buy Now
                                            </button>`
                                    }
                                    </div>
                                `;

                                marketItems.appendChild(itemElement);
                            });
                        }, (error) => {
                            console.error('Error reading market data:', error);
                            marketItems.innerHTML = '<div class="loading">Error loading market data.</div>';
                        });
                    })
                    .catch(error => {
                        console.error('Error importing Firebase:', error);
                        marketItems.innerHTML = '<div class="loading">Connection error.</div>';
                    });

            } catch (error) {
                console.error('Error loading market items:', error);
                marketItems.innerHTML = '<div class="loading">Error loading market. Please try again.</div>';
            }
        }

        // Load player's inventory for selling
        function loadSellInventory() {
            const sellInventory = document.getElementById('sell-inventory');
            sellInventory.innerHTML = '';

            gameState.inventory.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.className = 'inventory-item';
                itemElement.onclick = () => selectItemForSale(index);

                const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;

                itemElement.innerHTML = `
                    <div class="inventory-item-name">${itemName}</div>
                    <div class="inventory-item-stats">
                        ${item.stats ? Object.entries(item.stats).map(([stat, value]) =>
                    `${stat}: +${value}`).join('<br>') : ''}
                    </div>
                `;

                sellInventory.appendChild(itemElement);
            });

            if (gameState.inventory.length === 0) {
                sellInventory.innerHTML = '<div class="loading">No items to sell!</div>';
            }
        }

        // Select item for sale
        function selectItemForSale(index) {
            selectedItemForSale = index;

            // Update UI
            document.querySelectorAll('.inventory-item').forEach((item, i) => {
                item.classList.toggle('selected', i === index);
            });

            // Show sell form
            const sellForm = document.getElementById('sell-form');
            const sellItemInfo = document.getElementById('sell-item-info');
            const item = gameState.inventory[index];

            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;

            sellItemInfo.innerHTML = `
                <div class="sell-item-name">${itemName}</div>
                <div class="sell-item-stats">
                    ${item.stats ? Object.entries(item.stats).map(([stat, value]) =>
                `${stat}: +${value}`).join(', ') : 'No special stats'}
                </div>
                <div class="sell-item-value">Sell Value: ${item.sellValue || 0} Leaves</div>
            `;

            sellForm.style.display = 'block';
        }

        // Cancel selling
        function cancelSell() {
            selectedItemForSale = null;
            document.querySelectorAll('.inventory-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.getElementById('sell-form').style.display = 'none';
            document.getElementById('sell-price').value = '';
        }

        // Confirm sale and list item
        async function confirmSell() {
            if (selectedItemForSale === null) return;

            if (!window.currentUser) {
                alert('You must be logged in to sell items.');
                return;
            }

            const priceInput = document.getElementById('sell-price').value.trim();
            const price = parseInt(priceInput);

            if (!priceInput || isNaN(price) || price < 1) {
                alert('Please enter a valid price (minimum 1 Leaf)!');
                return;
            }

            if (price > 999999) {
                alert('Maximum price is 999,999 Leaves!');
                return;
            }

            try {
                const { ref, get, push, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Check if user already has active listings (limit to 1 for now)
                const marketRef = ref(window.db, 'market');
                // Note: For better performance we would use a query here, but traversing client side for 1 listing limit is acceptable for small scale
                // or we rely on the backend rules or just check local state optimistically.
                // Let's check via a quick query
                const { query, orderByChild, equalTo } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const userListingsQuery = query(marketRef, orderByChild('sellerId'), equalTo(window.currentUser.uid));

                const snapshot = await get(userListingsQuery);
                let hasActive = false;
                snapshot.forEach(child => {
                    if (child.val().status === 'active') hasActive = true;
                });

                if (hasActive) {
                    alert('You can only have 1 active listing at a time.');
                    return;
                }

                const item = gameState.inventory[selectedItemForSale];

                // Create listing object
                const listing = {
                    item: item,
                    price: price,
                    sellerId: window.currentUser.uid,
                    sellerName: gameState.character?.name || 'Unknown Player',
                    timestamp: serverTimestamp(),
                    status: 'active'
                };

                // Push to Firebase
                await push(marketRef, listing);

                // Remove item from inventory
                gameState.inventory.splice(selectedItemForSale, 1);

                // Save game state
                saveGameState();
                updateInventoryDisplay();

                // Reset form and UI
                cancelSell();
                toggleSellMode();

                // Go to My Listings to show specific confirmation
                switchMarketView('listings');
                loadMyListings();

                alert('Item listed for sale successfully!');

            } catch (error) {
                console.error('Error creating listing:', error);
                alert('Failed to list item. ' + error.message);
            }
        }

        // Buy market item
        async function buyMarketItem(listingId) {
            if (!window.currentUser) {
                alert('You must be logged in to buy items!');
                return;
            }

            // Prevent multiple purchases of the same item
            if (window.processingPurchase === listingId) {
                console.log('⚠️ Purchase already in progress for:', listingId);
                return;
            }
            window.processingPurchase = listingId;

            try {
                const { ref, get, runTransaction, update, push, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const db = window.db; // Use consistent db reference
                const listingRef = ref(db, `marketListings/${listingId}`);

                // First, get the listing to check price before transaction
                const listingSnapshot = await get(listingRef);
                if (!listingSnapshot.exists()) {
                    alert('This item is no longer available.');
                    return;
                }

                const listingData = listingSnapshot.val();

                // Check if buyer has enough currency BEFORE attempting purchase
                if (gameState.currency < listingData.price) {
                    alert(`You don't have enough Leaves! You need ${listingData.price} but only have ${gameState.currency}.`);
                    return;
                }

                if (listingData.status !== 'active') {
                    alert('This item has already been sold.');
                    return;
                }

                if (listingData.sellerId === window.currentUser.uid) {
                    alert('You cannot buy your own item!');
                    return;
                }

                // Mark listing as sold
                try {
                    await update(listingRef, {
                        status: 'sold',
                        buyerId: window.currentUser.uid,
                        buyerName: gameState.character?.name || 'Unknown',
                        soldAt: Date.now()
                    });
                } catch (updateError) {
                    console.error('❌ Failed to update listing:', updateError);
                    alert('Failed to purchase. Please try again.');
                    return;
                }

                // Deduct currency from buyer
                gameState.currency -= listingData.price;

                // Add item to inventory
                gameState.inventory.push(listingData.item);

                // Calculate seller's payment (80% after 20% market tax)
                const marketTax = 0.20;
                const sellerPayment = Math.floor(listingData.price * (1 - marketTax));

                // Create pending payment for seller
                try {
                    const pendingPaymentsRef = ref(window.db, `pendingPayments/${listingData.sellerId}`);
                    const pendingPayment = {
                        listingId: listingId,
                        amount: sellerPayment,
                        buyerId: window.currentUser.uid,
                        buyerName: gameState.character?.name || 'Unknown',
                        itemName: listingData.item.name,
                        createdAt: serverTimestamp(),
                        status: 'pending'
                    };

                    console.log('💰 Creating pending payment:', {
                        sellerId: listingData.sellerId,
                        amount: sellerPayment,
                        itemName: listingData.item.name,
                        listingId: listingId
                    });
                    await push(pendingPaymentsRef, pendingPayment);
                    console.log(`✅ Created pending payment of ${sellerPayment} Leaves for seller ${listingData.sellerName}`);

                    // Update listing with payment info
                    await update(listingRef, {
                        sellerPaid: sellerPayment,
                        paidAt: serverTimestamp(),
                        paymentStatus: 'pending'
                    });

                } catch (paymentError) {
                    console.error('Error creating pending payment:', paymentError);
                    // Payment creation failed, but purchase already completed
                    // In production, this would need a fallback mechanism
                }

                // Save and update UI
                saveGameState();
                updateInventoryDisplay();
                document.getElementById('currency-amount').textContent = gameState.currency;

                addToBattleLog(`🛒 Purchased ${listingData.item.name} for ${listingData.price} Leaves!`, 'success');
                alert(`Successfully purchased ${listingData.item.name} for ${listingData.price} Leaves!`);

                // Reload market to remove the sold item
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error processing purchase:', error);
                if (error.message && error.message.includes('permission_denied')) {
                    alert('Permission denied. Make sure you are logged in.');
                } else {
                    alert('Failed to purchase item. ' + (error.message || 'Please try again.'));
                }
            } finally {
                // Clear the processing flag
                if (window.processingPurchase === listingId) {
                    window.processingPurchase = null;
                }
            }
        }

        // Process pending market payments (called when seller logs in)
        async function processPendingMarketPayments() {
            console.log('🔄 processPendingMarketPayments called at:', new Date().toLocaleTimeString());

            // Prevent multiple simultaneous processing
            if (window.processingPayments) {
                console.log('⚠️ Payment processing already in progress, skipping');
                return;
            }
            window.processingPayments = true;

            if (!window.currentUser || !window.db) {
                console.log('Cannot process pending payments: no user or database');
                window.processingPayments = false;
                return;
            }

            try {
                const { ref, get, remove, update, runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const pendingPaymentsRef = ref(window.db, `pendingPayments/${window.currentUser.uid}`);
                console.log('🔍 Checking pending payments for user:', window.currentUser.uid);
                const snapshot = await get(pendingPaymentsRef);

                if (!snapshot.exists()) {
                    console.log('No pending market payments found');
                    return;
                }

                const pendingPayments = snapshot.val();
                console.log('📊 Found pending payments:', Object.keys(pendingPayments).length, 'payments');
                let totalPayment = 0;
                let processedCount = 0;
                const itemsSold = [];

                // Process each pending payment
                for (const [paymentId, payment] of Object.entries(pendingPayments)) {
                    if (payment.status === 'pending') {
                        totalPayment += payment.amount;
                        processedCount++;
                        itemsSold.push(payment.itemName);

                        // Mark payment as processed and remove it
                        const paymentRef = ref(window.db, `pendingPayments/${window.currentUser.uid}/${paymentId}`);
                        await remove(paymentRef);
                    }
                }

                if (totalPayment > 0) {
                    // Update user's currency in Firebase using transaction
                    const currencyRef = ref(window.db, `users/${window.currentUser.uid}/currency`);

                    await runTransaction(currencyRef, (currentCurrency) => {
                        if (currentCurrency === null) {
                            return { leaves: totalPayment, coins: 0 };
                        }

                        // Handle both object and legacy number format
                        if (typeof currentCurrency === 'object') {
                            currentCurrency.leaves = (currentCurrency.leaves || 0) + totalPayment;
                        } else {
                            currentCurrency = { leaves: currentCurrency + totalPayment, coins: 0 };
                        }

                        return currentCurrency;
                    });

                    // Note: Local currency/UI updates are handled automatically by Firebase real-time listener
                    // The listener will update gameState.currency, UI, and show notifications

                    console.log(`Processed ${processedCount} pending payments totaling ${totalPayment} Leaves - Firebase listener will update UI`);
                }
            } catch (error) {
                console.error('Error processing pending market payments:', error);
            } finally {
                // Clear the processing flag
                window.processingPayments = false;
            }
        }

        // Load player's listings
        function loadMyListings() {
            const myListings = document.getElementById('my-listings');

            if (!window.firebaseReady || !window.currentUser) {
                myListings.innerHTML = '<div class="loading">Please log in to view your listings.</div>';
                return;
            }

            myListings.innerHTML = '<div class="loading">Loading your listings...</div>';

            try {
                const marketRef = ref(db, 'market');
                onValue(marketRef, (snapshot) => {
                    const listings = snapshot.val() || {};
                    const myItems = Object.entries(listings).filter(([id, listing]) =>
                        listing.sellerId === window.currentUser.uid && listing.status === 'active'
                    );

                    if (myItems.length === 0) {
                        myListings.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-icon">📦</div>
                                <h3>No Active Listings</h3>
                                <p>You haven't listed any items for sale yet. Go to the "Sell Items" tab to list your first item!</p>
                            </div>
                        `;
                        return;
                    }

                    myListings.innerHTML = '';

                    myItems.forEach(([id, listing]) => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'listing-item';

                        // Format stats nicely
                        let statsText = '';
                        if (listing.item.stats) {
                            const stats = Object.entries(listing.item.stats);
                            if (stats.length > 0) {
                                statsText = stats.map(([stat, value]) => {
                                    const icon = stat === 'attack' ? '⚔️' :
                                        stat === 'defense' ? '🛡️' :
                                            stat === 'criticalChance' ? '💥' : '✨';
                                    return `${icon} ${stat}: +${value}`;
                                }).join(' • ');
                            }
                        }

                        const itemName = listing.item.upgradeLevel > 0 ? `${listing.item.name} +${listing.item.upgradeLevel}` : listing.item.name;

                        itemElement.innerHTML = `
                        <div class="market-item-header">
                            <div class="market-item-name">${itemName}</div>
                            <div class="market-item-price">${listing.price} <span class="currency-icon">🍃</span></div>
                        </div>
                        <div class="market-item-stats">
                            ${statsText || 'No special stats'}
                        </div>
                        <div class="market-item-footer">
                            <div class="market-item-seller">Listed for sale</div>
                            <button class="btn btn-danger" onclick="cancelListing('${id}')">
                                <span class="btn-icon">❌</span> Cancel Listing
                            </button>
                        </div>
                    `;

                        myListings.appendChild(itemElement);
                    });
                });
            } catch (error) {
                console.error('Error loading listings:', error);
                myListings.innerHTML = '<div class="loading">Error loading listings.</div>';
            }
        }

        // Cancel listing
        function cancelListing(listingId) {
            if (!confirm('Are you sure you want to cancel this listing? The item will be returned to your inventory.')) {
                return;
            }

            try {
                const listingRef = ref(db, `market/${listingId}`);
                get(listingRef).then((snapshot) => {
                    const listing = snapshot.val();

                    // Return item to inventory
                    gameState.inventory.push(listing.item);

                    // Remove listing
                    set(listingRef, { ...listing, status: 'cancelled' });

                    // Save and update
                    saveGameState();
                    updateInventoryDisplay();
                    loadMyListings();
                    loadMarketItems();

                    alert('Listing cancelled. Item returned to inventory.');
                }).catch((error) => {
                    console.error('Error cancelling listing:', error);
                    alert('Failed to cancel listing.');
                });
            } catch (error) {
                console.error('Error processing cancellation:', error);
                alert('Failed to cancel listing.');
            }
        }

        // Get emoji for items and elements
        function getEmoji(type) {
            switch (type) {
                case 'currency': return '🍃';
                case 'rusty sword': return '🗡️';
                case 'sword breaker': return '🗡️';
                case 'valkyr sword': return '🗡️';
                case 'zweihander': return '🗡️';
                case 'rusty wand': return '🪄';
                case 'rusty launcher': return '🚀';
                case 'int flame thrower': return '🚀';
                case 'battle staff': return '🪄';
                case 'war wand': return '🪄';
                case 'red bead': return '🪄';
                case 'rusty bow': return '🏹';
                case 'assemble bow': return '🏹';
                case 'tower bow': return '🏹';
                case 'beam cross-bow': return '🏹';
                case 'rusty armor': return '🧥';
                case 'leather shirt': return '🧥';
                case 'light tunic': return '🧥';
                case 'coil armor': return '🧥';
                case 'iron tunic': return '🧥';
                case 'steel core': return '🧥';
                case 'duple armor': return '🧥';
                case 'sprits cloak': return '🧥';
                case 'soul armor': return '🧥';
                case 'glow suit': return '🧥';
                case 'red gem': return '♦️';
                case 'blue gem': return '🔷';
                case 'shiny gem': return '💎';
                case 'winter box': return '🧊';
                case 'empty box': return '📦';
                case 'exp': return '✨';
                case 'novice ring': return '💍';
                case 'mild ring': return '💍';
                case 'normal ring': return '💍';
                case 'power ring': return '💍';
                case 'mighty ring': return '💍';
                case 'cosmic ring': return '💍';
                case 'basic wings': return '🪽';
                case 'polished wings': return '🪽';
                case 'advanced wings': return '🪽';
                case 'bastard sword': return '🗡️';
                case 'claymore': return '🗡️';
                case 'big breaker': return '🗡️';
                case 'beam sword': return '🗡️';
                case 'scale sword': return '🗡️';
                case 'estoc': return '🗡️';
                case 'black wand': return '🪄';
                case 'field staff': return '🪄';
                case 'dual wand': return '🪄';
                case 'beam bead': return '🪄';
                case 'blue wand': return '🪄';
                case 'long bow': return '🏹';
                case 'battle bow': return '🏹';
                case 'dual bow': return '🏹';
                case 'beam bow': return '🏹';
                case 'siege bow': return '🏹';
                case 'beam siege bow': return '🏹';
                case 'black stick bead': return '🪄'
                case 'turncoat sword': return '𖤍🗡️';
                case 'turncoat staff': return '𖤍🪄'
                case 'turncoat armor': return '𖤍🧥';
                case 'turncoat bow': return '𖤍🏹';
                case 'arghol blade': return '𖤍🗡️';
                case 'arghol staff': return '𖤍🪄';
                case 'arghol bow': return '𖤍🏹';
                case 'arghol armor': return '𖤍🧥';
                case 't1 turncoat sword': return '𖤍🗡️';
                case 't1 turncoat staff': return '𖤍🪄';
                case 't1 turncoat bow': return '𖤍🏹';
                case 't1 turncoat armor': return '𖤍🧥';
                case 't1 arghol blade': return '𖤍🗡️';
                case 't1 arghol staff': return '𖤍🪄';
                case 't1 arghol bow': return '𖤍🏹';
                case 't1 arghol armor': return '𖤍🧥';
                case 'calliana sword': return '𖤍🗡️';
                case 'calliana staff': return '𖤍🪄';
                case 'calliana bow': return '𖤍🏹';
                case 'calliana armor': return '𖤍🧥';
                case 't1 calliana sword': return '𖤍🗡️';
                case 't1 calliana staff': return '𖤍🪄';
                case 't1 calliana bow': return '𖤍🏹';
                case 't1 calliana armor': return '𖤍🧥';
                case 'snowflake': return '❄️';
                case 'man eater': return '🗡️';
                case 'accelleon': return '🪄';
                case 'valkyrie': return '🏹';
                case 'cerberus': return '🚀';
                case 'arghol launcher': return '𖤍🚀';
                case 'turncoat launcher': return '𖤍🚀';
                case 'calliana launcher': return '𖤍🚀';
                case 't1 arghol launcher': return '𖤍🚀';
                case 't1 turncoat launcher': return '𖤍🚀';
                case 't1 calliana launcher': return '𖤍🚀';
                case 'soft launcher': return '🚀';
                case 'basic launcher': return '🚀';
                case 'light launcher ': return '🚀';
                case 'heavy launcher': return '🚀';
                case 'dusty launcher': return '🚀';
                case 'flame thrower': return '🔥';
                case 'hook launcher': return '🚀';
                case 'bazooka': return '☄️';
                case 'missile launcher': return '🚀';
                case 'int spadona': return '🗡️';
                case 'int sickle staff': return '🪄';
                case 'int sickle bow': return '🏹';
                case 'int flame thrower': return '🔥';
                case 'novice ring ★': return '💍';
                case 'mild ring ★': return '💍';
                case 'normal ring ★': return '💍';
                case 'power ring ★': return '💍';
                case 'wild herb': return '🌿';
                default: return '';
            }
        }

        function sanitizeStats() {
            const char = gameState.character;
            if (isNaN(char.attack)) char.attack = 10; // Default fallback
            if (isNaN(char.defense)) char.defense = 5; // Default fallback

            // Recalculate from base if possible
            if (classStats[char.class]) {
                const base = classStats[char.class];
                const increases = statIncrease[char.class];
                const levels = char.level - 1;

                // If stats are wildly off or NaN, reset to calculated base + equipped
                if (isNaN(char.attack) || isNaN(char.defense)) {
                    char.attack = base.attack + (levels * increases.attack);
                    char.defense = base.defense + (levels * increases.defense);

                    // Add equipped items
                    if (char.equipped.weapon) char.attack += (char.equipped.weapon.stats.attack || 0);
                    if (char.equipped.armor) char.defense += (char.equipped.armor.stats.defense || 0);
                    if (char.equipped.accessory1) {
                        char.attack += (char.equipped.accessory1.stats.attack || 0);
                        char.defense += (char.equipped.accessory1.stats.defense || 0);
                    }
                    if (char.equipped.accessory2) {
                        char.attack += (char.equipped.accessory2.stats.attack || 0);
                        char.defense += (char.equipped.accessory2.stats.defense || 0);
                    }
                    if (char.equipped.wings) {
                        char.attack += (char.equipped.wings.stats.attack || 0);
                        char.defense += (char.equipped.wings.stats.defense || 0);
                    }
                }
            }
        }

        // Crafting Functions
        function openCraftingModal() {
            craftingModal.style.display = 'flex';
            // Ensure Sword tab is active by default
            document.querySelectorAll('.craft-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.craft-tab[data-category="sword"]').classList.add('active');
            currentCategory = 'sword';
            renderRecipes('sword');
        }

        function closeCraftingModal() {
            craftingModal.style.display = 'none';
            selectedRecipe = null;
            craftConfirmBtn.disabled = true;
        }

        function renderRecipes(category = 'sword') {
            recipeList.innerHTML = '';

            Object.entries(craftingRecipes).forEach(([key, recipe]) => {
                // Filter by category
                let shouldShow = false;
                switch (category) {
                    case 'sword':
                        shouldShow = recipe.type === 'weapon' && (recipe.name.toLowerCase().includes('sword') || recipe.name.toLowerCase().includes('blade') || recipe.name.toLowerCase().includes('claymore') || recipe.name.toLowerCase().includes('breaker') || recipe.name.toLowerCase().includes('zweihander') || recipe.name.toLowerCase().includes('man eater') || recipe.name.toLowerCase().includes('eater'));
                        break;
                    case 'staff':
                        shouldShow = recipe.type === 'weapon' && (recipe.name.toLowerCase().includes('staff') || recipe.name.toLowerCase().includes('wand') || recipe.name.toLowerCase().includes('bead') || recipe.name.toLowerCase().includes('accelleon'));
                        break;
                    case 'bow':
                        shouldShow = recipe.type === 'weapon' && (recipe.name.toLowerCase().includes('bow') || recipe.name.toLowerCase().includes('valkyrie'));
                        break;
                    case 'launcher':
                        shouldShow = recipe.type === 'weapon' && recipe.name.toLowerCase().includes('launcher');
                        break;
                    case 'armor':
                        shouldShow = recipe.type === 'armor';
                        break;
                    case 'accessories':
                        shouldShow = recipe.type === 'accessory';
                        break;
                }

                if (!shouldShow) return;
                const recipeEl = document.createElement('div');
                recipeEl.className = 'recipe-item';
                if (selectedRecipe === key) recipeEl.classList.add('selected');

                // Check requirements
                const hasCurrency = gameState.currency >= recipe.requirements.currency;

                // Check materials
                let materialsMet = true;
                let materialsHtml = '';
                Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                    const playerMat = gameState.materials.find(m => m.name === matName);
                    const playerAmount = playerMat ? playerMat.quantity : 0;
                    const isMet = playerAmount >= amount;
                    if (!isMet) materialsMet = false;

                    materialsHtml += `
                        <div class="req-item ${isMet ? 'req-met' : 'req-missing'}">
                            ${getEmoji(matName.toLowerCase())} ${matName}: ${playerAmount}/${amount}
                        </div>
                    `;
                });

                // Check base item (support both single item and items array for accessories)
                let hasItem = false;
                let itemHtml = '';

                if (recipe.requirements.items) {
                    // Accessory crafting with multiple items
                    let allItemsMet = true;
                    recipe.requirements.items.forEach(reqItem => {
                        const matchingItems = gameState.inventory.filter(i => i.name === reqItem.name);
                        const hasEnough = matchingItems.length >= reqItem.quantity;
                        if (!hasEnough) allItemsMet = false;

                        itemHtml += `
                            <div class="req-item ${hasEnough ? 'req-met' : 'req-missing'}">
                                ${getEmoji(reqItem.name.toLowerCase())} ${reqItem.name} x${reqItem.quantity}: ${matchingItems.length}/${reqItem.quantity}
                            </div>
                        `;
                    });
                    hasItem = allItemsMet;
                } else if (recipe.requirements.item) {
                    // Traditional single item crafting
                    const reqItem = recipe.requirements.item;
                    const matchingItems = gameState.inventory.filter(i =>
                        i.name === reqItem.name &&
                        i.upgradeLevel >= reqItem.upgradeLevel
                    );
                    hasItem = matchingItems.length > 0;

                    itemHtml = `
                        <div class="req-item ${hasItem ? 'req-met' : 'req-missing'}">
                            ${getEmoji(reqItem.name.toLowerCase())} ${reqItem.name} +${reqItem.upgradeLevel}: ${hasItem ? 'Available' : 'Missing'}
                        </div>
                    `;
                }

                const currencyHtml = `
                    <div class="req-item ${hasCurrency ? 'req-met' : 'req-missing'}">
                        🍃 Cost: ${recipe.requirements.currency}
                    </div>
                `;

                // Stats display
                let statsDisplay = '';
                if (recipe.type === 'accessory') {
                    // Accessory stats display
                    const atk = recipe.stats.attack || 0;
                    const def = recipe.stats.defense || 0;
                    statsDisplay = `<span>+${atk} ATK +${def} DEF</span>`;
                } else if (recipe.lifesteal) {
                    statsDisplay = `
                        <div style="text-align: right;">
                            <div>ATK: ${recipe.stats.attack}</div>
                            <div style="font-size: 0.8rem; color: #00ff00;">LS: ${Math.round(recipe.lifesteal.chance * 100)}% (x${recipe.lifesteal.multiplier})</div>
                        </div>
                    `;
                } else if (recipe.damageReduction) {
                    statsDisplay = `
                        <div style="text-align: right;">
                            <div>DEF: ${recipe.stats.defense}</div>
                            <div style="font-size: 0.8rem; color: #3498db;">DMG Red: ${Math.round(recipe.damageReduction * 100)}%</div>
                        </div>
                    `;
                } else if (recipe.stats.defense) {
                    statsDisplay = `<span>DEF: ${recipe.stats.defense}</span>`;
                } else {
                    statsDisplay = `<span>ATK: ${recipe.stats.attack}</span>`;
                }

                // Success rate display for accessories
                const successRateHtml = recipe.successRate ? `
                    <div class="req-item" style="color: #f39c12;">
                        ⚠️ Success Rate: ${Math.round(recipe.successRate * 100)}%
                    </div>
                ` : '';

                recipeEl.innerHTML = `
                    <div class="recipe-header">
                        <span class="${recipe.rarity === 't1' ? 'item-rarity-t1' : ''}">${getEmoji(recipe.name.toLowerCase())} ${recipe.name}</span>
                        ${statsDisplay}
                    </div>
                    <div class="recipe-requirements">
                        ${itemHtml}
                        ${materialsHtml}
                        ${currencyHtml}
                        ${successRateHtml}
                    </div>
                `;

                recipeEl.addEventListener('click', () => {
                    selectRecipe(key);
                });

                recipeList.appendChild(recipeEl);
            });
        }

        function selectRecipe(recipeKey) {
            selectedRecipe = recipeKey;
            renderRecipes(currentCategory);

            // Check if craftable
            const recipe = craftingRecipes[recipeKey];
            const hasCurrency = gameState.currency >= recipe.requirements.currency;

            let materialsMet = true;
            Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                const playerMat = gameState.materials.find(m => m.name === matName);
                const playerAmount = playerMat ? playerMat.quantity : 0;
                if (playerAmount < amount) materialsMet = false;
            });

            // Check items (support both single item and items array)
            let hasItem = false;
            if (recipe.requirements.items) {
                // Accessory crafting - check if all required items are available
                hasItem = recipe.requirements.items.every(reqItem => {
                    const matchingItems = gameState.inventory.filter(i => i.name === reqItem.name);
                    return matchingItems.length >= reqItem.quantity;
                });
            } else if (recipe.requirements.item) {
                const reqItem = recipe.requirements.item;
                const matchingItems = gameState.inventory.filter(i =>
                    i.name === reqItem.name &&
                    i.upgradeLevel >= reqItem.upgradeLevel
                );
                hasItem = matchingItems.length > 0;
            }

            craftConfirmBtn.disabled = !(hasCurrency && materialsMet && hasItem);
        }

        function craftItem() {
            if (!selectedRecipe) return;

            const recipe = craftingRecipes[selectedRecipe];

            // 1. Consume Currency
            gameState.currency -= recipe.requirements.currency;

            // 2. Consume Materials
            Object.entries(recipe.requirements.materials).forEach(([matName, amount]) => {
                const playerMat = gameState.materials.find(m => m.name === matName);
                playerMat.quantity -= amount;
                if (playerMat.quantity <= 0) {
                    const idx = gameState.materials.indexOf(playerMat);
                    gameState.materials.splice(idx, 1);
                }
            });

            // 3. Consume Base Items (support both single item and items array)
            if (recipe.requirements.items) {
                // Accessory crafting with multiple items
                recipe.requirements.items.forEach(reqItem => {
                    for (let i = 0; i < reqItem.quantity; i++) {
                        // Find and remove unequipped items first
                        let targetItem = gameState.inventory.find(item =>
                            item.name === reqItem.name &&
                            gameState.character.equipped.accessory1 !== item &&
                            gameState.character.equipped.accessory2 !== item
                        );

                        if (!targetItem) {
                            // Use equipped item if no unequipped available
                            targetItem = gameState.inventory.find(item => item.name === reqItem.name);

                            // Unequip it first
                            if (gameState.character.equipped.accessory1 === targetItem) {
                                gameState.character.equipped.accessory1 = null;
                                gameState.character.attack -= targetItem.stats?.attack || 0;
                                gameState.character.defense -= targetItem.stats?.defense || 0;
                            } else if (gameState.character.equipped.accessory2 === targetItem) {
                                gameState.character.equipped.accessory2 = null;
                                gameState.character.attack -= targetItem.stats?.attack || 0;
                                gameState.character.defense -= targetItem.stats?.defense || 0;
                            }
                        }

                        const itemIndex = gameState.inventory.indexOf(targetItem);
                        if (itemIndex > -1) {
                            gameState.inventory.splice(itemIndex, 1);
                        }
                    }
                });

                // 4. Check success rate for accessory crafting
                const successRate = recipe.successRate || 1.0;
                const isSuccess = Math.random() < successRate;

                if (isSuccess) {
                    // Create the new accessory
                    const newItem = {
                        name: recipe.name,
                        stats: { ...recipe.stats },
                        sellValue: recipe.sellValue,
                        quantity: 1,
                        type: recipe.type,
                        upgradeLevel: 0,
                        rarity: recipe.rarity
                    };

                    gameState.inventory.push(newItem);
                    addToBattleLog(`✨ Crafted ${getEmoji(newItem.name.toLowerCase())} ${newItem.name}!`, 'success');
                } else {
                    // Failure - items already destroyed, currency already deducted
                    addToBattleLog(`❌ Crafting failed! Your materials were destroyed.`, 'danger');
                }
            } else if (recipe.requirements.item) {
                // Traditional single item crafting (always succeeds)
                const reqItem = recipe.requirements.item;
                // Prioritize unequipped items
                let targetItem = gameState.inventory.find(i =>
                    i.name === reqItem.name &&
                    i.upgradeLevel >= reqItem.upgradeLevel &&
                    gameState.character.equipped.weapon !== i
                );

                // If no unequipped item, use equipped one
                if (!targetItem) {
                    targetItem = gameState.inventory.find(i =>
                        i.name === reqItem.name &&
                        i.upgradeLevel >= reqItem.upgradeLevel
                    );

                    // Unequip it first
                    if (gameState.character.equipped.weapon === targetItem) {
                        gameState.character.equipped.weapon = null;
                        // Remove stats
                        const itemLevel = targetItem.upgradeLevel;
                        const bonus = upgradeSystem.bonuses[itemLevel]?.attack || 0;
                        gameState.character.attack -= (targetItem.stats.attack + bonus);
                    }
                }

                const itemIndex = gameState.inventory.indexOf(targetItem);
                gameState.inventory.splice(itemIndex, 1);

                // Create the new item
                const newItem = {
                    name: recipe.name,
                    stats: { ...recipe.stats },
                    sellValue: recipe.sellValue,
                    quantity: 1,
                    type: recipe.type,
                    upgradeLevel: 0,
                    rarity: recipe.rarity,
                    lifesteal: recipe.lifesteal || null,
                    damageReduction: recipe.damageReduction || null
                };

                gameState.inventory.push(newItem);
                addToBattleLog(`Crafted <span class="item-rarity-t1">${getEmoji(newItem.name.toLowerCase())} ${newItem.name}</span>!`, 'success');
            }

            // 5. Update UI
            updateInventoryDisplay();
            updateCharacterDisplay();
            renderRecipes(currentCategory);
            selectedRecipe = null;
            craftConfirmBtn.disabled = true;
            saveGameState();
        }

        // MARKET SYSTEM
        // ========================================

        let selectedSellItem = null;

        // Show market modal with unified view
        function showMarket() {
            const marketModal = document.getElementById('market-modal');
            marketModal.style.display = 'flex';
            showUnifiedView();
            loadUnifiedMarket();
        }

        // Show unified market view
        function showUnifiedView() {
            document.getElementById('market-unified-view').style.display = 'block';
            document.getElementById('market-sell-mode').style.display = 'none';
            document.getElementById('market-claim-payments').style.display = 'none';
        }

        // Show sell mode
        function showSellMode() {
            document.getElementById('market-unified-view').style.display = 'none';
            document.getElementById('market-sell-mode').style.display = 'block';
            document.getElementById('market-claim-payments').style.display = 'none';
            loadSellInventory();
        }

        // Load unified market (my listings + other players' items)
        async function loadUnifiedMarket() {
            const myListingsContainer = document.getElementById('my-listings-container');
            const marketItemsContainer = document.getElementById('market-items-container');

            myListingsContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-dim);">Loading...</div>';
            marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 1rem; color: var(--text-dim);">Loading...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'marketListings');
                const snapshot = await get(marketRef);

                if (!snapshot.exists()) {
                    myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No listings yet</div>';
                    marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No items available</div>';
                    return;
                }

                const listings = snapshot.val();
                const currentUserId = window.currentUser?.uid;

                // Separate my listings and other players' listings (only show active items)
                const myListings = [];
                const otherListings = [];

                Object.entries(listings).forEach(([id, listing]) => {
                    // Only show active listings (not sold items)
                    if (listing.status !== 'active') {
                        return;
                    }

                    if (listing.sellerId === currentUserId) {
                        myListings.push([id, listing]);
                    } else {
                        otherListings.push([id, listing]);
                    }
                });

                // Render my listings
                if (myListings.length === 0) {
                    myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">You have no active listings</div>';
                } else {
                    myListingsContainer.innerHTML = '';
                    myListings.forEach(([listingId, listing]) => {
                        const itemEl = createSingleLineItem(listingId, listing, true);
                        myListingsContainer.appendChild(itemEl);
                    });
                }

                // Render other players' items
                if (otherListings.length === 0) {
                    marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim); font-style: italic;">No items available from other players</div>';
                } else {
                    marketItemsContainer.innerHTML = '';
                    otherListings.forEach(([listingId, listing]) => {
                        const itemEl = createSingleLineItem(listingId, listing, false);
                        marketItemsContainer.appendChild(itemEl);
                    });
                }

            } catch (error) {
                console.error('Error loading market:', error);
                myListingsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--warning);">Error loading listings</div>';
                marketItemsContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--warning);">Error loading market items</div>';
            }
        }

        // Create single-line item element
        function createSingleLineItem(listingId, listing, isMyListing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = isMyListing ? 'market-item-row my-listing' : 'market-item-row';

            // Build item name with upgrade level
            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;
            const emoji = getEmoji(item.name.toLowerCase());

            // Build stats display
            let statsText = '';
            if (item.stats.attack) statsText += `ATK: ${item.stats.attack}`;
            if (item.stats.defense) {
                if (statsText) statsText += ' | ';
                statsText += `DEF: ${item.stats.defense}`;
            }
            if (!statsText) statsText = '-';

            // Build action button
            let actionButton = '';
            if (isMyListing) {
                actionButton = `<button class="btn btn-danger btn-small" onclick="cancelListing('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">✖ Cancel</button>`;
            } else {
                actionButton = `<button class="btn btn-success btn-small" onclick="buyMarketItem('${listingId}')">💰 Buy</button>`;
            }

            div.innerHTML = `
                <div class="market-item-info">
                    <div class="market-item-name">${emoji} ${itemName}</div>
                    <div class="market-item-stats">${statsText}</div>
                    <div class="market-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-action">
                    ${actionButton}
                </div>
            `;

            return div;
        }

        // Load market items from Firebase
        async function loadMarketItems() {
            const marketItemsContainer = document.getElementById('market-items');
            marketItemsContainer.innerHTML = '<div class="loading">Loading market items...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'marketListings');
                const snapshot = await get(marketRef);

                if (!snapshot.exists()) {
                    marketItemsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">🏪</div>
                            <h3>No Items Listed</h3>
                            <p>Be the first to list an item on the market!</p>
                        </div>
                    `;
                    return;
                }

                const listings = snapshot.val();
                const currentUserId = window.currentUser?.uid;

                // Filter out current user's listings and only show active items
                const otherPlayersListings = Object.entries(listings).filter(([id, listing]) =>
                    listing.sellerId !== currentUserId && listing.status === 'active'
                );

                if (otherPlayersListings.length === 0) {
                    marketItemsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">🏪</div>
                            <h3>No Items Available</h3>
                            <p>Check back later for new listings!</p>
                        </div>
                    `;
                    return;
                }

                // Render market items
                marketItemsContainer.innerHTML = '';
                otherPlayersListings.forEach(([listingId, listing]) => {
                    const itemEl = createMarketItemElement(listingId, listing);
                    marketItemsContainer.appendChild(itemEl);
                });

            } catch (error) {
                console.error('Error loading market items:', error);
                marketItemsContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">⚠️</div>
                        <h3>Error Loading Market</h3>
                        <p>Please try again later.</p>
                    </div>
                `;
            }
        }

        // Create market item element
        function createMarketItemElement(listingId, listing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = 'market-item';

            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;

            // Build stats display
            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;

            div.innerHTML = `
                <div class="market-item-header">
                    <h4 class="market-item-name">${getEmoji(item.name.toLowerCase())} ${itemName}</h4>
                    <div class="market-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-stats">${statsHtml}</div>
                <div class="market-item-footer">
                    <div class="market-item-seller">Sold by: ${listing.sellerName}</div>
                    <button class="btn btn-success" onclick="buyMarketItem('${listingId}')">
                        <span class="btn-icon">💰</span> Buy
                    </button>
                </div>
            `;

            return div;
        }


        // Load player's inventory for selling
        function loadSellInventory() {
            const sellInventory = document.getElementById('sell-inventory');
            const sellForm = document.getElementById('sell-form');

            sellInventory.innerHTML = '';
            sellForm.style.display = 'none';
            selectedSellItem = null;

            // Get sellable items (exclude equipped items)
            const sellableItems = gameState.inventory.filter(item => {
                const char = gameState.character;
                return item !== char.equipped.weapon &&
                    item !== char.equipped.armor &&
                    item !== char.equipped.accessory1 &&
                    item !== char.equipped.accessory2 &&
                    item !== char.equipped.wings;
            });

            if (sellableItems.length === 0) {
                sellInventory.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📦</div>
                        <h3>No Items to Sell</h3>
                        <p>You don't have any unequipped items to list on the market.</p>
                    </div>
                `;
                return;
            }

            // Render inventory items
            sellableItems.forEach(item => {
                const itemEl = createSellInventoryItem(item);
                sellInventory.appendChild(itemEl);
            });
        }

        // Create sell inventory item element
        function createSellInventoryItem(item) {
            const div = document.createElement('div');
            div.className = 'inventory-item';

            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack}<br>`;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense}<br>`;

            div.innerHTML = `
                <div class="inventory-item-name">${getEmoji(item.name.toLowerCase())} ${itemName}</div>
                <div class="inventory-item-stats">${statsHtml}</div>
            `;

            div.addEventListener('click', () => selectItemToSell(item, div));

            return div;
        }

        // Select item to sell
        function selectItemToSell(item, element) {
            selectedSellItem = item;

            // Update UI selection
            document.querySelectorAll('.inventory-item').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');

            // Show sell form
            const sellForm = document.getElementById('sell-form');
            const sellItemInfo = document.getElementById('sell-item-info');
            const priceInput = document.getElementById('sell-price');
            const taxDisplay = document.getElementById('sell-tax-display');
            const taxAmountEl = document.getElementById('sell-tax-amount');
            const netProfitEl = document.getElementById('sell-net-profit');

            const itemName = item.upgradeLevel > 0 ? `${item.name} +${item.upgradeLevel}` : item.name;

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;

            sellItemInfo.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color); margin-bottom: 0.5rem;">
                        ${getEmoji(item.name.toLowerCase())} ${itemName}
                    </div>
                    <div style="color: var(--text);">${statsHtml}</div>
                </div>
            `;

            sellForm.style.display = 'block';
            priceInput.value = '';
            if (taxDisplay) taxDisplay.style.display = 'none';
            priceInput.focus();

            // Add tax calculation listener
            priceInput.oninput = function () {
                // Remove non-numeric characters
                this.value = this.value.replace(/[^0-9]/g, '');

                // Limit to 6 digits
                if (this.value.length > 6) {
                    this.value = this.value.slice(0, 6);
                }

                const price = parseInt(this.value) || 0;
                if (price > 0 && taxDisplay) {
                    const tax = Math.floor(price * 0.20);
                    const net = price - tax;

                    if (taxAmountEl) taxAmountEl.textContent = `-${tax}`;
                    if (netProfitEl) netProfitEl.textContent = net;
                    taxDisplay.style.display = 'block';
                } else if (taxDisplay) {
                    taxDisplay.style.display = 'none';
                }
            };
        }

        // Confirm sell
        async function confirmSell() {
            if (!selectedSellItem) {
                addToBattleLog('Please select an item to sell!', 'warning');
                return;
            }

            const priceInput = document.getElementById('sell-price');
            const priceValue = priceInput.value.trim();

            // Validate input is a number
            if (!/^\d+$/.test(priceValue)) {
                addToBattleLog('Price must be a number only (no symbols or decimals)!', 'warning');
                return;
            }

            const price = parseInt(priceValue);

            if (!price || price <= 0) {
                addToBattleLog('Please enter a valid price!', 'warning');
                return;
            }

            if (price > 999999) {
                addToBattleLog('Price too high! Maximum is 999,999 Leaves.', 'warning');
                return;
            }

            try {
                const { ref, push } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Create listing
                const listing = {
                    sellerId: window.currentUser.uid,
                    sellerName: gameState.character.name,
                    item: selectedSellItem,
                    price: price,
                    status: 'active',
                    listedAt: Date.now()
                };

                // Add to Firebase
                const marketRef = ref(db, 'marketListings');
                await push(marketRef, listing);

                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(selectedSellItem);
                gameState.inventory.splice(itemIndex, 1);
                updateInventoryDisplay();
                saveGameState();

                addToBattleLog(`Listed ${selectedSellItem.name} for ${price} Leaves!`, 'success');

                // Return to unified view and reload
                showUnifiedView();
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error listing item:', error);
                addToBattleLog('Failed to list item. Please try again.', 'warning');
            }
        }

        // Load player's listings
        async function loadMyListings() {
            const myListingsContainer = document.getElementById('my-listings');
            myListingsContainer.innerHTML = '<div class="loading">Loading your listings...</div>';

            try {
                const { ref, get, query, orderByChild, equalTo } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const marketRef = ref(db, 'market');
                // Query for current user's listings only
                const userListingsQuery = query(marketRef, orderByChild('sellerId'), equalTo(window.currentUser?.uid));
                const snapshot = await get(userListingsQuery);

                if (!snapshot.exists()) {
                    myListingsContainer.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">📋</div>
                            <h3>No Active Listings</h3>
                            <p>You haven't listed any items yet.</p>
                        </div>
                    `;
                    return;
                }

                const listings = snapshot.val();
                const myListings = Object.entries(listings);

                // Check for sold items and collect payments
                let totalEarnings = 0;
                for (const [listingId, listing] of myListings) {
                    if (listing.status === 'sold' && listing.sellerPaid && !listing.paymentCollected) {
                        totalEarnings += listing.sellerPaid;
                        // Mark payment as collected
                        const { update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                        await update(ref(db, `market/${listingId}`), { paymentCollected: true });
                    }
                }

                // Add earnings to seller's currency if any were collected
                if (totalEarnings > 0) {
                    gameState.currency += totalEarnings;
                    saveGameState();
                    document.getElementById('currency-amount').textContent = gameState.currency;
                    addToBattleLog(`💰 +${totalEarnings} Leaves collected from sold items!`, 'success');
                }

                // Render listings
                myListingsContainer.innerHTML = '';
                myListings.forEach(([listingId, listing]) => {
                    const itemEl = createMyListingElement(listingId, listing);
                    myListingsContainer.appendChild(itemEl);
                });

            } catch (error) {
                console.error('Error loading my listings:', error);
                myListingsContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">⚠️</div>
                        <h3>Error Loading Listings</h3>
                        <p>Please try again later.</p>
                    </div>
                `;
            }
        }

        // Create my listing element
        function createMyListingElement(listingId, listing) {
            const item = listing.item;
            const div = document.createElement('div');
            div.className = 'listing-item';

            let statsHtml = '';
            if (item.stats.attack) statsHtml += `ATK: ${item.stats.attack} `;
            if (item.stats.defense) statsHtml += `DEF: ${item.stats.defense} `;
            if (item.upgradeLevel > 0) statsHtml += `+${item.upgradeLevel}`;

            div.innerHTML = `
                <div class="market-item-header">
                    <h4 class="listing-item-name">${getEmoji(item.name.toLowerCase())} ${item.name}</h4>
                    <div class="listing-item-price">${listing.price} 🍃</div>
                </div>
                <div class="market-item-stats">${statsHtml}</div>
                <div class="market-item-footer">
                    <div style="font-size: 0.85rem; color: var(--text-dim);">Listed ${getTimeAgo(listing.listedAt)}</div>
                    <button class="btn btn-danger btn-small" onclick="cancelListing('${listingId}', ${JSON.stringify(listing).replace(/"/g, '&quot;')})">
                        <span class="btn-icon">✖</span> Cancel
                    </button>
                </div>
            `;

            return div;
        }

        // Cancel listing
        async function cancelListing(listingId, listing) {
            if (!confirm('Cancel this listing and return the item to your inventory?')) {
                return;
            }

            // Check inventory space
            if (gameState.inventory.length >= 20) {
                addToBattleLog('Inventory full! Cannot cancel listing.', 'warning');
                return;
            }

            try {
                const { ref, get, remove } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Check if listing still exists and is still active before returning item (prevents duplication bug)
                const listingRef = ref(db, `marketListings/${listingId}`);
                const listingSnapshot = await get(listingRef);

                if (!listingSnapshot.exists()) {
                    addToBattleLog('This listing was already sold or removed!', 'warning');
                    // Reload unified market to update UI
                    loadUnifiedMarket();
                    return;
                }

                const currentListing = listingSnapshot.val();
                if (currentListing.status !== 'active') {
                    addToBattleLog('This item has already been sold! Cannot cancel listing.', 'warning');
                    // Reload unified market to update UI
                    loadUnifiedMarket();
                    return;
                }

                // Return item to inventory
                gameState.inventory.push(listing.item);
                updateInventoryDisplay();

                // Remove listing from Firebase
                await remove(listingRef);

                saveGameState();

                addToBattleLog(`Cancelled listing for ${listing.item.name}`, 'info');

                // Reload unified market
                loadUnifiedMarket();

            } catch (error) {
                console.error('Error cancelling listing:', error);
                addToBattleLog('Failed to cancel listing. Please try again.', 'warning');

                // Remove item from inventory on error (only if we added it)
                if (gameState.inventory.length > 0 && gameState.inventory[gameState.inventory.length - 1] === listing.item) {
                    gameState.inventory.pop();
                }
                updateInventoryDisplay();
            }
        }

        // Helper function to get time ago
        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        // Show claim payments view
        function showClaimPayments() {
            document.getElementById('market-unified-view').style.display = 'none';
            document.getElementById('market-sell-mode').style.display = 'none';
            document.getElementById('market-claim-payments').style.display = 'block';
            loadPendingPayments();
        }

        // Load and display pending payments
        async function loadPendingPayments() {
            const container = document.getElementById('pending-payments-container');
            const summaryDiv = document.getElementById('claim-summary');

            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-dim);">Loading payments...</div>';

            if (!window.currentUser || !window.db) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--warning);">You must be logged in to view payments</div>';
                summaryDiv.style.display = 'none';
                return;
            }

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const pendingPaymentsRef = ref(window.db, `pendingPayments/${window.currentUser.uid}`);
                const snapshot = await get(pendingPaymentsRef);

                if (!snapshot.exists()) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 3rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">📭</div>
                            <h3 style="color: var(--text-dim); margin-bottom: 0.5rem;">No Pending Payments</h3>
                            <p style="color: var(--text-dim); font-size: 0.95rem;">You don't have any payments to claim yet</p>
                        </div>
                    `;
                    summaryDiv.style.display = 'none';
                    return;
                }

                const pendingPayments = snapshot.val();
                const payments = Object.entries(pendingPayments).filter(([_, payment]) => payment.status === 'pending');

                if (payments.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 3rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">✅</div>
                            <h3 style="color: var(--text-dim); margin-bottom: 0.5rem;">All Caught Up!</h3>
                            <p style="color: var(--text-dim); font-size: 0.95rem;">You've claimed all your pending payments</p>
                        </div>
                    `;
                    summaryDiv.style.display = 'none';
                    return;
                }

                // Calculate total
                const totalAmount = payments.reduce((sum, [_, payment]) => sum + payment.amount, 0);

                // Display payments
                container.innerHTML = payments.map(([paymentId, payment]) => `
                    <div class="market-item-row" style="margin-bottom: 0.5rem;">
                        <div class="market-item-info">
                            <div class="market-item-name">${getEmoji(payment.itemName.toLowerCase())} ${payment.itemName}</div>
                            <div class="market-item-stats">Sold to: ${payment.buyerName}</div>
                            <div class="market-item-price" style="color: var(--success); font-weight: bold;">+${payment.amount} 🍃</div>
                        </div>
                    </div>
                `).join('');

                // Show summary
                document.getElementById('claim-total').textContent = `Total: ${totalAmount} Leaves from ${payments.length} sale${payments.length > 1 ? 's' : ''}`;
                summaryDiv.style.display = 'block';

            } catch (error) {
                console.error('Error loading pending payments:', error);
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--danger);">Error loading payments</div>';
                summaryDiv.style.display = 'none';
            }
        }

        // Process claiming all pending payments
        async function processClaimPayments() {
            if (window.processingPayments) {
                addToBattleLog('⚠️ Payment processing already in progress', 'warning');
                return;
            }
            window.processingPayments = true;

            if (!window.currentUser || !window.db) {
                addToBattleLog('❌ You must be logged in to claim payments', 'warning');
                window.processingPayments = false;
                return;
            }

            try {
                const { ref, get, remove, update, runTransaction } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const pendingPaymentsRef = ref(window.db, `pendingPayments/${window.currentUser.uid}`);
                const snapshot = await get(pendingPaymentsRef);

                if (!snapshot.exists()) {
                    addToBattleLog('📭 No pending payments to claim', 'info');
                    window.processingPayments = false;
                    return;
                }

                const pendingPayments = snapshot.val();
                const payments = Object.entries(pendingPayments).filter(([_, payment]) => payment.status === 'pending');

                if (payments.length === 0) {
                    addToBattleLog('✅ No new payments to claim', 'info');
                    window.processingPayments = false;
                    return;
                }

                const totalPayment = payments.reduce((sum, [_, payment]) => sum + payment.amount, 0);
                const itemCount = payments.length;

                // Process each payment
                for (const [paymentId, payment] of payments) {
                    const paymentRef = ref(window.db, `pendingPayments/${window.currentUser.uid}/${paymentId}`);
                    await remove(paymentRef);
                }

                // Update seller's currency in Firebase
                const currencyRef = ref(window.db, `users/${window.currentUser.uid}/currency`);

                await runTransaction(currencyRef, (currentCurrency) => {
                    if (currentCurrency === null) {
                        return { leaves: totalPayment, coins: 0 };
                    }

                    if (typeof currentCurrency === 'object') {
                        currentCurrency.leaves = (currentCurrency.leaves || 0) + totalPayment;
                    } else {
                        currentCurrency = { leaves: currentCurrency + totalPayment, coins: 0 };
                    }

                    return currentCurrency;
                });

                // Success message
                if (itemCount === 1) {
                    addToBattleLog(`💰 Claimed ${totalPayment} Leaves! (Item sold on market)`, 'success');
                } else {
                    addToBattleLog(`💰 Claimed ${totalPayment} Leaves from ${itemCount} items sold on market!`, 'success');
                }

                // Refresh the UI
                loadPendingPayments();

                console.log(`✅ Claimed ${totalPayment} Leaves from ${itemCount} items`);

            } catch (error) {
                console.error('❌ Error claiming payments:', error);
                addToBattleLog('❌ Failed to claim payments. Please try again.', 'warning');
            } finally {
                window.processingPayments = false;
            }
        }

        // Make functions globally accessible
        window.showMarket = showMarket;
        window.showUnifiedView = showUnifiedView;
        window.showSellMode = showSellMode;
        window.showClaimPayments = showClaimPayments;
        window.loadPendingPayments = loadPendingPayments;
        window.processClaimPayments = processClaimPayments;
        window.buyMarketItem = buyMarketItem;
        window.confirmSell = confirmSell;
        window.cancelListing = cancelListing;
        window.loadUnifiedMarket = loadUnifiedMarket;
        window.getEmoji = getEmoji;

        // Add message to battle log
        function addToBattleLog(message, type = 'info') {
            const now = new Date();
            const timeString = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;

            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;

            logEntry.innerHTML = `
                <span class="log-time">${timeString}</span> ${message}
            `;

            // Insert before the exploring animation to keep it at the bottom
            const exploringAnimation = document.getElementById('exploring-animation');
            if (exploringAnimation) {
                battleLog.insertBefore(logEntry, exploringAnimation);
            } else {
                battleLog.appendChild(logEntry);
            }
            requestAnimationFrame(() => {
                const target = exploringAnimation && exploringAnimation.style.display !== 'none'
                    ? exploringAnimation
                    : logEntry;
                target.scrollIntoView({ block: 'end' });
                battleLog.scrollTop = battleLog.scrollHeight;
            });

            const entries = battleLog.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        // Auto Potion Toggle Event Listener
        const autoPotionToggle = document.getElementById('auto-potion-toggle');
        if (autoPotionToggle) {
            autoPotionToggle.addEventListener('change', (e) => {
                gameState.autoPotion = e.target.checked;
                saveGameState();
                addToBattleLog(`Auto Potion ${gameState.autoPotion ? 'enabled' : 'disabled'}.`, 'info');
            });
        }

        // Debug Tools Event Listeners
        const fixExpBtn = document.getElementById('fix-exp-btn');
        if (fixExpBtn) {
            fixExpBtn.addEventListener('click', () => {
                if (!gameState.character) {
                    alert('No character found!');
                    return;
                }

                const char = gameState.character;
                const oldMaxExp = char.maxExp;

                // Recalculate maxExp based on current level using NEW formula
                char.maxExp = Math.floor(100 * Math.pow(1.15, char.level - 1));

                addToBattleLog(`🔧 Fixed EXP! Old maxExp: ${oldMaxExp}, New maxExp: ${char.maxExp}`, 'success');
                addToBattleLog(`✨ You can now gain experience toward level ${char.level + 1}!`, 'level');

                updateCharacterDisplay();
                saveGameState();
            });
        }

        // Initialize the game when the page loads
        // NOTE: initGame() is now called by the auth flow AFTER Firebase data is loaded
        // This ensures Firebase is always the source of truth, not localStorage
        console.log('Page loaded, waiting for authentication...');
        // window.addEventListener('load', () => {
        //     console.log('Window load event fired, calling initGame');
        //     initGame();
        // });

        // ============================================
        // CHIP WAR FUNCTIONS
        // ============================================

        // Get travel time based on player race and target chip
        function getChipTravelTime(playerRace, targetRace) {
            const travelTimes = {
                'Accretia': {
                    'Cora': 30,
                    'Bellato': 50
                },
                'Bellato': {
                    'Accretia': 50,
                    'Cora': 45
                },
                'Cora': {
                    'Accretia': 30,
                    'Bellato': 45
                }
            };

            return travelTimes[playerRace]?.[targetRace] || 50; // Default to 50 if not found
        }

        // Show Chip War modal
        async function showChipWar() {
            // Switch to Battle Log tab on mobile
            if (window.switchTab) switchTab('battle');

            // Removed HQ requirement - can open from any map

            // Check if player is level 30 or above
            const playerLevel = gameState.character?.level || 0;
            if (playerLevel < 20) {
                addToBattleLog('⚠️ Chip War is only available to players level 20 and above!', 'warning');
                return;
            }

            // Check if player is currently exploring or returning from exploration
            if (gameState.isExploring || gameState.stopTimer) {
                if (gameState.isExploring) {
                    addToBattleLog('⚠️ You cannot join the Chip War while exploring. Stop exploration first.', 'warning');
                } else {
                    addToBattleLog('⚠️ You are currently traveling to HQ. Please wait...', 'warning');
                }
                return;
            }

            // Check if player is currently traveling to Ether Platform
            if (gameState.isTraveling) {
                addToBattleLog('⚠️ You are in mid air and cannot join the Chip War.', 'warning');
                return;
            }

            const modal = document.getElementById('chip-war-modal');
            modal.style.display = 'flex';

            // Update player race display
            const playerRaceDisplay = document.getElementById('player-race-display');
            const playerRace = gameState.character?.race || 'Unknown';
            playerRaceDisplay.textContent = playerRace;

            // Check and reset chips if needed (12pm GMT+8 daily reset)
            await checkAndResetChips();

            // Load global chips from Firebase
            await loadGlobalChips();
            await loadLastHitters();
            await loadNukeStates();

            // Set up real-time listener for chip updates
            setupChipListener();
            setupLastHitterListener();
            setupNukeListener();

            // Start countdown timer
            startChipWarResetTimer();

            // Render chip list
            renderChipList();

            // Update UI if there's an active attack
            if (gameState.chipAttack.isAttacking) {
                updateChipAttackUI();
            }
        }

        // Load last hitters from Firebase
        async function loadLastHitters() {
            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const lastHitterRef = ref(db, 'chipLastHitter');
                const snapshot = await get(lastHitterRef);

                if (snapshot.exists()) {
                    gameState.lastHitters = snapshot.val();
                } else {
                    gameState.lastHitters = {};
                }
            } catch (error) {
                console.error('Error loading last hitters:', error);
                gameState.lastHitters = {};
            }
        }

        // Load nuke states from Firebase
        async function loadNukeStates() {
            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const nukeRef = ref(db, 'chipNuke');
                const snapshot = await get(nukeRef);

                if (snapshot.exists()) {
                    const nukeData = snapshot.val();
                    // Update local nuke cooldown based on current race
                    const playerRace = gameState.character?.race;
                    if (playerRace && nukeData[playerRace]) {
                        const raceNuke = nukeData[playerRace];
                        gameState.chipNuke.lastNukeTime = raceNuke.lastNukeTime || 0;
                        gameState.chipNuke.lastNukeTimestamp = raceNuke.lastNukeTimestamp || 0;
                    }
                }
            } catch (error) {
                console.error('Error loading nuke states:', error);
            }
        }

        // Setup listener for last hitters
        async function setupLastHitterListener() {
            try {
                const { ref, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const lastHitterRef = ref(db, 'chipLastHitter');

                onValue(lastHitterRef, (snapshot) => {
                    if (snapshot.exists()) {
                        gameState.lastHitters = snapshot.val();
                        if (document.getElementById('chip-war-modal').style.display === 'flex') {
                            renderChipList();
                        }
                    }
                });
            } catch (error) {
                console.error('Error setting up last hitter listener:', error);
            }
        }

        // Setup listener for nuke states
        async function setupNukeListener() {
            try {
                const { ref, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const nukeRef = ref(db, 'chipNuke');

                onValue(nukeRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const nukeData = snapshot.val();
                        const playerRace = gameState.character?.race;

                        if (playerRace && nukeData[playerRace]) {
                            const raceNuke = nukeData[playerRace];
                            gameState.chipNuke.lastNukeTime = raceNuke.lastNukeTime || 0;
                            gameState.chipNuke.lastNukeTimestamp = raceNuke.lastNukeTimestamp || 0;

                            if (document.getElementById('chip-war-modal').style.display === 'flex') {
                                renderChipList();
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error setting up nuke listener:', error);
            }
        }

        // Load global chips from Firebase
        async function loadGlobalChips() {
            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const chipsRef = ref(db, 'globalChips');
                const snapshot = await get(chipsRef);

                if (snapshot.exists()) {
                    gameState.chips = snapshot.val();
                } else {
                    // Initialize global chips if they don't exist
                    await initializeGlobalChips();
                }
            } catch (error) {
                console.error('Error loading global chips:', error);
                // Use local chips as fallback
            }
        }

        // Initialize global chips in Firebase
        async function initializeGlobalChips() {
            try {
                const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const chipsRef = ref(db, 'globalChips');

                const initialChips = {
                    Accretia: {
                        race: "Accretia",
                        maxHp: 50000,
                        currentHp: 50000
                    },
                    Bellato: {
                        race: "Bellato",
                        maxHp: 50000,
                        currentHp: 50000
                    },
                    Cora: {
                        race: "Cora",
                        maxHp: 50000,
                        currentHp: 50000
                    }
                };

                await set(chipsRef, initialChips);
                gameState.chips = initialChips;
                console.log('✅ Initialized global chips in Firebase');
            } catch (error) {
                console.error('Error initializing global chips:', error);
            }
        }

        // Check and reset chips at 12pm GMT+8 daily
        async function checkAndResetChips() {
            try {
                const { ref, get, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const resetTimeRef = ref(db, 'chipWarLastReset');
                const resetSnapshot = await get(resetTimeRef);

                // Get current time in GMT+8
                const now = new Date();
                const gmt8Time = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Singapore" }));
                const currentHour = gmt8Time.getHours();
                const currentDate = gmt8Time.toDateString();

                // Check if it's past 12pm GMT+8 today
                const shouldReset = currentHour >= 12;

                if (resetSnapshot.exists()) {
                    const lastReset = resetSnapshot.val();
                    const lastResetDate = new Date(lastReset.timestamp).toDateString();

                    // Reset if it's past 12pm and hasn't been reset today
                    if (shouldReset && lastResetDate !== currentDate) {
                        await resetChipHP();
                        await set(resetTimeRef, { timestamp: Date.now() });
                    }
                } else {
                    // First time - reset if past 12pm
                    if (shouldReset) {
                        await resetChipHP();
                        await set(resetTimeRef, { timestamp: Date.now() });
                    }
                }
            } catch (error) {
                console.error('Error checking chip reset:', error);
            }
        }

        // Reset all chip HP to full
        async function resetChipHP() {
            try {
                const { ref, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const chipsRef = ref(db, 'globalChips');

                await update(chipsRef, {
                    'Accretia/currentHp': 50000,
                    'Bellato/currentHp': 50000,
                    'Cora/currentHp': 50000
                });

                console.log('✅ Chip HP reset to full (12pm GMT+8 reset)');
            } catch (error) {
                console.error('Error resetting chip HP:', error);
            }
        }

        // Start countdown timer for next reset (12pm GMT+8)
        function startChipWarResetTimer() {
            const timerElement = document.getElementById('chip-war-reset-timer');
            if (!timerElement) return;

            function updateTimer() {
                const now = new Date();
                const gmt8Time = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Singapore" }));
                const currentHour = gmt8Time.getHours();
                const currentMinute = gmt8Time.getMinutes();
                const currentSecond = gmt8Time.getSeconds();

                // Calculate time until next 12pm GMT+8
                let hoursUntilReset = 12 - currentHour;
                let minutesUntilReset = 0 - currentMinute;
                let secondsUntilReset = 0 - currentSecond;

                if (hoursUntilReset < 0 || (hoursUntilReset === 0 && minutesUntilReset < 0)) {
                    // Already past 12pm, reset is tomorrow
                    hoursUntilReset = 24 + hoursUntilReset;
                }

                if (minutesUntilReset < 0) {
                    minutesUntilReset = 60 + minutesUntilReset;
                    hoursUntilReset--;
                }

                if (secondsUntilReset < 0) {
                    secondsUntilReset = 60 + secondsUntilReset;
                    minutesUntilReset--;
                }

                const hours = String(hoursUntilReset).padStart(2, '0');
                const minutes = String(minutesUntilReset).padStart(2, '0');
                const seconds = String(secondsUntilReset).padStart(2, '0');

                timerElement.textContent = `Next Reset: ${hours}:${minutes}:${seconds}`;
            }

            updateTimer();
            setInterval(updateTimer, 1000);
        }

        // Restore all chips to full HP (call from console: restoreAllChips())
        window.restoreAllChips = async function () {
            try {
                const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const chipsRef = ref(db, 'globalChips');

                const restoredChips = {
                    Accretia: {
                        race: "Accretia",
                        maxHp: 50000,
                        currentHp: 50000
                    },
                    Bellato: {
                        race: "Bellato",
                        maxHp: 50000,
                        currentHp: 50000
                    },
                    Cora: {
                        race: "Cora",
                        maxHp: 50000,
                        currentHp: 50000
                    }
                };

                await set(chipsRef, restoredChips);
                gameState.chips = restoredChips;
                console.log('✅ All chips restored to 50,000 HP!');
                alert('All chips have been restored to 50,000 HP!');

                // Refresh the modal if it's open
                if (document.getElementById('chip-war-modal').style.display === 'flex') {
                    await loadGlobalChips();
                    renderChipList();
                }
                return 'Success!';
            } catch (error) {
                console.error('Error restoring chips:', error);
                return 'Error: ' + error.message;
            }
        };

        // Set up real-time listener for chip updates
        let chipListenerUnsubscribe = null;
        function setupChipListener() {
            // Remove existing listener if any
            if (chipListenerUnsubscribe) {
                chipListenerUnsubscribe();
            }

            try {
                const chipsRef = ref(db, 'globalChips');
                chipListenerUnsubscribe = onValue(chipsRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const newChipsData = snapshot.val();

                        // Validate that we have complete chip data
                        const requiredRaces = ['Accretia', 'Bellato', 'Cora'];
                        const hasAllChips = requiredRaces.every(race =>
                            newChipsData[race] &&
                            typeof newChipsData[race].currentHp === 'number' &&
                            typeof newChipsData[race].maxHp === 'number'
                        );

                        if (!hasAllChips) {
                            console.warn('Received incomplete chip data from Firebase, ignoring update');
                            return;
                        }

                        // Only update if data actually changed and we're not in the middle of an attack
                        if (JSON.stringify(gameState.chips) !== JSON.stringify(newChipsData)) {
                            gameState.chips = newChipsData;

                            // Update UI if modal is open and we're not currently attacking
                            const modal = document.getElementById('chip-war-modal');
                            if (modal && modal.style.display === 'flex' && !gameState.chipAttack?.isAttacking) {
                                renderChipList();
                            }
                        }
                    } else {
                        console.warn('No chip data in Firebase snapshot');
                    }
                });
            } catch (error) {
                console.error('Error setting up chip listener:', error);
            }
        }

        // Render chip list
        function renderChipList() {
            const chipList = document.getElementById('chip-list');
            const playerRace = gameState.character?.race;

            if (!playerRace) {
                chipList.innerHTML = '<div style="color: var(--text-dim); text-align: center; padding: 2rem;">No character found.</div>';
                return;
            }

            chipList.innerHTML = '';

            // Ensure chips data exists
            if (!gameState.chips) {
                console.error('No chips data found, initializing...');
                gameState.chips = {
                    Accretia: { race: "Accretia", maxHp: 50000, currentHp: 50000 },
                    Bellato: { race: "Bellato", maxHp: 50000, currentHp: 50000 },
                    Cora: { race: "Cora", maxHp: 50000, currentHp: 50000 }
                };
            }

            // Get all chips in order
            const races = ['Accretia', 'Bellato', 'Cora'];
            const isAttacking = gameState.chipAttack.isAttacking;
            const attackingRace = gameState.chipAttack.targetRace;

            // Check if ANY chip is destroyed (chip war is over)
            const anyChipDestroyed = races.some(r => gameState.chips[r] && gameState.chips[r].currentHp <= 0);

            races.forEach(race => {
                const chip = gameState.chips[race];
                const isOwnChip = race === playerRace;

                // Safely calculate HP percentage with fallbacks
                let hpPercentage = 0;
                let displayChip = chip;

                if (chip && chip.maxHp && chip.maxHp > 0) {
                    hpPercentage = Math.max(0, Math.min(100, Math.round((chip.currentHp / chip.maxHp) * 100)));
                } else {
                    console.warn(`Invalid chip data for ${race}, using defaults`);
                    // Create a fallback chip object
                    displayChip = {
                        race: race,
                        maxHp: 50000,
                        currentHp: 50000
                    };
                    hpPercentage = 100;
                }
                const isAttackingThisChip = isAttacking && attackingRace === race;

                // Determine HP bar gradient based on percentage
                let hpGradient;
                if (hpPercentage > 75) {
                    hpGradient = 'linear-gradient(90deg, #28a745, #5cb85c)'; // Green
                } else if (hpPercentage > 50) {
                    hpGradient = 'linear-gradient(90deg, #ffc107, #ffdb4d)'; // Yellow
                } else if (hpPercentage > 25) {
                    hpGradient = 'linear-gradient(90deg, #fd7e14, #ff9147)'; // Orange
                } else {
                    hpGradient = 'linear-gradient(90deg, #dc3545, #e74c3c)'; // Red
                }

                // Determine button state
                let buttonHTML = '';
                if (isOwnChip) {
                    // Own chip - show Nuke button (only when HP <= 50% and not destroyed)
                    const chipHpPercentage = displayChip.currentHp / displayChip.maxHp * 100;
                    const canNuke = !isAttacking && !anyChipDestroyed && chipHpPercentage <= 50 && displayChip.currentHp > 0;

                    // Check cooldown
                    const now = Date.now();
                    const nextNukeTime = (gameState.chipNuke?.lastNukeTime || 0) + (180 * 1000); // 180 seconds
                    const onCooldown = now < nextNukeTime;

                    if (onCooldown) {
                        const remainingSeconds = Math.ceil((nextNukeTime - now) / 1000);
                        buttonHTML = `
                            <div style="display: flex; justify-content: flex-end;">
                                <button class="btn" disabled style="background-color: var(--secondary); padding: 0.3rem 0.6rem; font-size: 0.8rem;">
                                    🚀 Nuke (${remainingSeconds}s)
                                </button>
                            </div>
                        `;
                    } else {
                        buttonHTML = `
                            <div style="display: flex; justify-content: flex-end;">
                                <button class="btn" onclick="nukeChip()" ${canNuke ? '' : 'disabled'} style="background-color: ${canNuke ? '#e74c3c' : 'var(--accent)'}; padding: 0.3rem 0.6rem; font-size: 0.8rem;">
                                    🚀 Nuke
                                </button>
                            </div>
                        `;
                    }
                } else {
                    // Enemy chip - show Attack/Stop button
                    if (isAttackingThisChip) {
                        buttonHTML = `
                            <div style="display: flex; justify-content: flex-end;">
                                <button class="btn btn-stop" onclick="stopChipAttack()" style="padding: 0.3rem 0.6rem; font-size: 0.8rem; background-color: #dc3545;">
                                    🛑 Stop
                                </button>
                            </div>
                        `;
                    } else {
                        // Disable attack if ANY chip is destroyed or currently attacking
                        const canAttack = !isAttacking && !anyChipDestroyed;
                        const thisChipDestroyed = displayChip.currentHp <= 0;
                        buttonHTML = `
                            <div style="display: flex; justify-content: flex-end;">
                                <button 
                                    class="btn ${canAttack ? '' : 'btn-secondary'}" 
                                    onclick="attackChip('${race}')"
                                    ${canAttack ? '' : 'disabled'}
                                    style="padding: 0.3rem 0.6rem; font-size: 0.8rem; ${canAttack ? 'background-color: #007bff;' : ''}">
                                    ${thisChipDestroyed ? '💀 Destroyed' : '⚔️ Attack'}
                                </button>
                            </div>
                        `;
                    }
                }

                const chipCard = document.createElement('div');
                chipCard.style.cssText = 'background: var(--accent); padding: 1rem 1.5rem; border-radius: 8px; border: 2px solid rgba(255, 255, 255, 0.1); margin-bottom: 1rem;';

                // Simple chip label
                const chipLabel = `<div style="font-size: 1.1rem; font-weight: bold; color: var(--text);">${race} Chip</div>`;

                // Ensure HP display always shows something
                const displayHpPercentage = isNaN(hpPercentage) ? 0 : hpPercentage;
                const displayHpGradient = hpGradient || 'linear-gradient(90deg, #dc3545, #e74c3c)';

                chipCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem;">
                        ${chipLabel}
                        ${buttonHTML}
                    </div>
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <span style="color: var(--text-dim); font-size: 0.9rem; min-width: 30px;">HP</span>
                        <div style="flex: 1; height: 18px; background: var(--darker-bg); border-radius: 9px; overflow: hidden; position: relative;">
                            <div style="width: ${displayHpPercentage}%; height: 100%; background: ${displayHpGradient}; transition: width 0.3s ease;"></div>
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; color: white; text-shadow: 0 0 4px rgba(0,0,0,0.8);">
                                ${displayHpPercentage}%
                            </div>
                        </div>
                    </div>
                `;

                chipList.appendChild(chipCard);
            });
        }

        // Global listener unsubscribe for attacker results
        let attackerListenerUnsubscribe = null;

        // Setup listener for battle results
        async function setupAttackerListener(targetRace) {
            try {
                const { ref, onValue, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const user = window.currentUser;
                if (!user) return;

                const resultRef = ref(db, `chipAttacks/${targetRace}/${user.uid}/result`);

                // Unsubscribe previous if exists
                if (attackerListenerUnsubscribe) {
                    attackerListenerUnsubscribe();
                    attackerListenerUnsubscribe = null;
                }

                attackerListenerUnsubscribe = onValue(resultRef, (snapshot) => {
                    const result = snapshot.val();
                    if (result) {
                        if (result.type === 'defeat') {
                            gameState.stats.pvpPoints = Math.max(0, (gameState.stats.pvpPoints || 0) - 5);
                            addToBattleLog(`💀 You were attacked by ${result.defenderName} and got defeated. -5 PVP Points`, 'danger');
                            addToBattleLog('You have been kicked from the chip war.', 'info');
                            stopChipAttack();
                        } else if (result.type === 'win') {
                            gameState.stats.pvpPoints = (gameState.stats.pvpPoints || 0) + 5;
                            addToBattleLog(`🛡️ You were attacked by ${result.defenderName} but unsuccessful. +5 PVP Points`, 'success');
                            addToBattleLog('You defended your position and continue attacking!', 'info');
                        }

                        // Update local UI
                        if (document.getElementById('pvp-points-display')) {
                            document.getElementById('pvp-points-display').textContent = gameState.stats.pvpPoints;
                        }
                        saveGameState();

                        // Clear result
                        set(resultRef, null);
                    }
                });
            } catch (error) {
                console.error('Error setting up attacker listener:', error);
            }
        }

        // Stop attacking chip
        function stopChipAttack() {
            const targetRace = gameState.chipAttack.targetRace;

            gameState.chipAttack = {
                isAttacking: false,
                targetRace: null,
                startTime: null,
                travelTime: 0,
                damage: 0
            };

            // Reset exploration status to AFK when stopping chip attack
            document.getElementById('explore-selected-time').textContent = 'AFK';
            document.getElementById('explore-timer').textContent = '';

            // Remove attacker from Firebase
            if (targetRace) {
                try {
                    const user = window.currentUser;
                    if (user) {
                        const attackerRef = ref(db, `chipAttacks/${targetRace}/${user.uid}`);
                        set(attackerRef, null); // Remove entry
                    }
                } catch (error) {
                    console.error('Error removing attacker:', error);
                }
            }

            // Cleanup listener
            if (attackerListenerUnsubscribe) {
                attackerListenerUnsubscribe();
                attackerListenerUnsubscribe = null;
            }

            // Return player to HQ when stopping attack
            gameState.currentMap = 'HQ';
            gameState.character.location = 'HQ';
            document.getElementById('char-location').textContent = 'HQ';

            saveGameState();
            updateChipAttackUI();
            renderChipList();
            addToBattleLog('🛑 Stopped attacking chip. Returned to HQ.', 'info');
        }

        // Attack a chip
        function attackChip(targetRace) {
            const playerRace = gameState.character?.race;

            if (!playerRace) {
                addToBattleLog('⚠️ No character found!', 'warning');
                return;
            }

            // Check if player is at HQ or Crag Mine
            if (gameState.currentMap !== 'HQ' && gameState.currentMap !== 'Crag Mine') {
                addToBattleLog('⚠️ You must be at HQ or Crag Mine to attack chips!', 'warning');
                alert('You must be at HQ or Crag Mine to attack chips!\nReturn to HQ first.');
                return;
            }

            if (gameState.chipAttack.isAttacking) {
                addToBattleLog('⚠️ Already attacking a chip!', 'warning');
                return;
            }

            if (playerRace === targetRace) {
                addToBattleLog('⚠️ Cannot attack your own race chip!', 'warning');
                return;
            }

            const targetChip = gameState.chips[targetRace];
            if (targetChip.currentHp <= 0) {
                addToBattleLog(`⚠️ ${targetRace} chip is already destroyed!`, 'warning');
                return;
            }

            // Calculate travel time
            const travelTime = getChipTravelTime(playerRace, targetRace);

            // Calculate damage (based on player's attack stat)
            const damage = gameState.character?.attack || 100;

            // Set attack state
            gameState.chipAttack = {
                isAttacking: true,
                targetRace: targetRace,
                startTime: Date.now(),
                travelTime: travelTime * 1000, // Convert to milliseconds
                damage: damage
            };

            // Update exploration status to show Chip War participation
            document.getElementById('explore-selected-time').textContent = 'Participating in Chip War...';
            document.getElementById('explore-timer').textContent = '';

            // Track attacker in Firebase for defend mechanics
            try {
                const user = window.currentUser;
                if (user) {
                    const attackerRef = ref(db, `chipAttacks/${targetRace}/${user.uid}`);
                    set(attackerRef, {
                        name: gameState.character?.name || 'Unknown',
                        attack: gameState.character?.attack || 0,
                        defense: gameState.character?.defense || 0,
                        timestamp: serverTimestamp()
                    });

                    // Setup listener for PvP results
                    setupAttackerListener(targetRace);
                }
            } catch (error) {
                console.error('Error tracking attacker:', error);
            }

            // Change location to Crag Mine when starting attack
            gameState.currentMap = 'Crag Mine';
            gameState.character.location = 'Crag Mine';
            document.getElementById('char-location').textContent = 'Crag Mine';

            // Save game state
            saveGameState();

            // Log the attack
            addToBattleLog(`🗡️ Traveling to Crag Mine to attack ${targetRace} chip (${travelTime}s)...`, 'info');

            // Update UI
            updateChipAttackUI();
            renderChipList();
        }

        // Update chip attack UI
        function updateChipAttackUI() {
            const activeAttackDisplay = document.getElementById('active-attack-display');
            const targetNameSpan = document.getElementById('attack-target-name');

            if (gameState.chipAttack.isAttacking) {
                activeAttackDisplay.style.display = 'block';
                targetNameSpan.textContent = `${gameState.chipAttack.targetRace} Chip`;
            } else {
                activeAttackDisplay.style.display = 'none';
            }
        }

        // Update chip attack timer (called every second)
        function updateChipAttackTimer() {
            if (!gameState.chipAttack.isAttacking) return;

            const now = Date.now();
            const elapsed = now - gameState.chipAttack.startTime;
            const remaining = Math.max(0, gameState.chipAttack.travelTime - elapsed);

            // Update timer display
            const timerDisplay = document.getElementById('attack-timer-display');
            if (timerDisplay) {
                const seconds = Math.ceil(remaining / 1000);
                timerDisplay.textContent = `${seconds}s`;
            }

            // Check if attack is complete
            if (remaining <= 0) {
                completeChipAttack();
            }
        }

        // Complete chip attack
        async function completeChipAttack() {
            const targetRace = gameState.chipAttack.targetRace;
            const damage = gameState.chipAttack.damage;
            const attackStartTime = gameState.chipAttack.startTime;

            // Check if attack was disrupted by nuke (nuke used after attack started)
            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const nukeRef = ref(db, `chipNuke/${targetRace}`);
                const nukeSnapshot = await get(nukeRef);

                if (nukeSnapshot.exists()) {
                    const nukeData = nukeSnapshot.val();
                    const lastNukeTimestamp = nukeData.lastNukeTimestamp || 0;

                    // If nuke was used after this attack started, disrupt it
                    if (lastNukeTimestamp > attackStartTime) {
                        addToBattleLog('🚀 Your attack was disrupted by a nuclear strike! You must restart your attack.', 'warning');

                        // Reset attack state
                        gameState.chipAttack = {
                            isAttacking: false,
                            targetRace: null,
                            startTime: 0,
                            travelTime: 0,
                            damage: 0
                        };
                        saveGameState();
                        renderChipList();
                        updateChipAttackUI();
                        return;
                    }
                }
            } catch (error) {
                console.error('Error checking nuke disruption:', error);
            }

            // Apply damage to chip locally
            const targetChip = gameState.chips[targetRace];
            const oldHp = targetChip.currentHp;
            const newHp = Math.max(0, targetChip.currentHp - damage);

            // Update global chip HP in Firebase
            try {
                const { ref, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const chipRef = ref(db, `globalChips/${targetRace}`);

                await update(chipRef, {
                    currentHp: newHp
                });

                // Update local state
                targetChip.currentHp = newHp;

                // Log the result
                addToBattleLog(`⚔️ Attacked ${targetRace} chip for ${damage.toLocaleString()} damage!`, 'damage');
                addToBattleLog(`⚔️ Attacked ${targetRace} chip for ${damage.toLocaleString()} damage!`, 'damage');
                if (newHp <= 0) {
                    addToBattleLog(`💀 ${targetRace} chip has been destroyed!`, 'success');

                    // Track last hitter and award coin
                    const user = window.currentUser;
                    if (user) {
                        const lastHitterRef = ref(db, 'chipLastHitter');
                        const currentLastHitters = gameState.lastHitters || {};
                        currentLastHitters[targetRace] = {
                            playerId: user?.uid || 'unknown',
                            name: gameState.character?.name || 'Unknown',
                            race: gameState.character?.race || 'Unknown'
                        };
                        await set(lastHitterRef, currentLastHitters);

                        // Update local state immediately
                        gameState.lastHitters = currentLastHitters;

                        // Award 1 coin to destroyer
                        gameState.coins += 1;
                        document.getElementById('coins-amount').textContent = gameState.coins;


                        saveGameState();

                        // Re-render chip list to show updated breaker info
                        renderChipList();
                    }
                } else {
                    addToBattleLog(`${targetRace} chip HP: ${newHp.toLocaleString()} / ${targetChip.maxHp.toLocaleString()}`, 'info');
                }

                // Check if chip still has HP - if yes, continue attacking
                if (newHp > 0) {
                    // Continue attacking immediately (no travel time needed)
                    // Just reset the timer for 1 second between attacks
                    gameState.chipAttack = {
                        isAttacking: true,
                        targetRace: targetRace,
                        startTime: Date.now(),
                        travelTime: 1000, // 1 second cooldown between attacks
                        damage: damage
                    };

                    // Save and update UI
                    saveGameState();
                    updateChipAttackUI();
                    if (document.getElementById('chip-war-modal').style.display === 'flex') {
                        renderChipList();
                    }

                    // Log that we're continuing the attack
                    addToBattleLog(`⚔️ Attacking ${targetRace} chip...`, 'info');
                } else {
                    // Chip destroyed - reset attack state and remove from Firebase
                    gameState.chipAttack = {
                        isAttacking: false,
                        targetRace: null,
                        startTime: null,
                        travelTime: 0,
                        damage: 0
                    };

                    // Remove attacker from Firebase
                    const user = window.currentUser;
                    if (user) {
                        const attackerRef = ref(db, `chipAttacks/${targetRace}/${user.uid}`);
                        await set(attackerRef, null);
                    }

                    // Reset everyone's location to HQ when chip is destroyed
                    await resetAllPlayersToHQ();

                    // Reset own location to HQ
                    gameState.currentMap = 'HQ';
                    gameState.character.location = 'HQ';
                    document.getElementById('char-location').textContent = 'HQ';
                    addToBattleLog('🏛️ Chip destroyed! All players returned to HQ.', 'success');

                    // Save game state
                    saveGameState();

                    // Update UI
                    updateChipAttackUI();
                    if (document.getElementById('chip-war-modal').style.display === 'flex') {
                        renderChipList();
                    }
                }
            } catch (error) {
                console.error('Error updating global chip HP:', error);
                addToBattleLog('⚠️ Failed to update chip HP. Please try again.', 'warning');

                // Rollback local change
                targetChip.currentHp = oldHp;

                // Reset attack state on error
                gameState.chipAttack = {
                    isAttacking: false,
                    targetRace: null,
                    startTime: null,
                    travelTime: 0,
                    damage: 0
                };

                saveGameState();
                updateChipAttackUI();
                if (document.getElementById('chip-war-modal').style.display === 'flex') {
                    renderChipList();
                }
            }
        }

        // Defend chip function
        async function nukeChip() {
            const playerRace = gameState.character?.race;
            if (!playerRace) return;

            // Check if player is at HQ or Crag Mine
            if (gameState.currentMap !== 'HQ' && gameState.currentMap !== 'Crag Mine') {
                addToBattleLog('⚠️ You must be at HQ or Crag Mine to use nuke!', 'warning');
                alert('You must be at HQ or Crag Mine to use nuke!\nReturn to HQ first.');
                return;
            }

            // Check if already attacking (can't nuke while attacking)
            if (gameState.chipAttack.isAttacking) {
                addToBattleLog('⚠️ Cannot nuke while attacking!', 'warning');
                return;
            }

            // Check HP requirement
            const chip = gameState.chips[playerRace];
            if (!chip || chip.currentHp <= 0) {
                addToBattleLog('⚠️ Cannot nuke with destroyed chip!', 'warning');
                return;
            }
            const hpPercentage = chip.currentHp / chip.maxHp * 100;
            if (hpPercentage > 50) {
                addToBattleLog('⚠️ Chip must be at 50% HP or below to nuke!', 'warning');
                return;
            }

            // Check cooldown
            const now = Date.now();
            const lastNuke = gameState.chipNuke.lastNukeTime || 0;
            if (now - lastNuke < 180 * 1000) {
                const remaining = Math.ceil(((lastNuke + 180 * 1000) - now) / 1000);
                addToBattleLog(`⚠️ Nuke is on cooldown! (${remaining}s)`, 'warning');
                return;
            }

            // Set nuke timestamp to track when nuke was used
            gameState.chipNuke.lastNukeTime = now;
            gameState.chipNuke.lastNukeTimestamp = now;

            // Save to Firebase - both cooldown and disruption timestamp
            try {
                const { ref, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const nukeRef = ref(db, `chipNuke/${playerRace}`);
                await update(nukeRef, {
                    lastNukeTime: gameState.chipNuke.lastNukeTime,
                    lastNukeTimestamp: gameState.chipNuke.lastNukeTimestamp
                });
            } catch (error) {
                console.error('Error saving nuke data:', error);
            }

            saveGameState();
            renderChipList();

            // Force all attackers of this race to restart their attacks
            await disruptAllAttackers(playerRace);

            addToBattleLog('🚀 NUCLEAR STRIKE! All attackers of your chip have been disrupted and must restart!', 'success');
        }


        async function disruptAllAttackers(targetRace) {
            try {
                const { ref, remove, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Clear all attack records for this race (immediate disruption)
                const attacksRef = ref(db, `chipAttacks/${targetRace}`);
                await remove(attacksRef);

                console.log(`Cleared all attack records against ${targetRace} chip`);
                addToBattleLog('🚀 All ongoing attacks against your chip have been disrupted!', 'success');

            } catch (error) {
                console.error('Error disrupting attackers:', error);
                addToBattleLog('⚠️ Error during nuclear disruption!', 'warning');
            }
        }


        async function resetAllPlayersToHQ() {
            try {
                const { ref, get, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Get all users
                const usersRef = ref(db, 'users');
                const usersSnapshot = await get(usersRef);

                if (usersSnapshot.exists()) {
                    const users = usersSnapshot.val();
                    const updates = {};

                    // Update each user's location to HQ
                    for (const userId in users) {
                        updates[`${userId}/gameData/currentMap`] = 'HQ';
                        updates[`${userId}/gameData/profile/location`] = 'HQ';
                    }

                    // Apply all updates at once
                    await update(usersRef, updates);
                    console.log('✅ Reset all players to HQ');
                }
            } catch (error) {
                console.error('Error resetting players to HQ:', error);
            }
        }


        // Complete defend action (PvP Combat)
        async function completeChipDefend() {
            // Reset defend state but keep cooldown
            gameState.chipDefend.isDefending = false;
            gameState.chipDefend.startTime = null;

            if (window.defendInterval) {
                clearInterval(window.defendInterval);
                window.defendInterval = null;
            }

            saveGameState();
            renderChipList(); // Update button state

            // PvP Logic
            const myRace = gameState.character.race;
            try {
                const { ref, get, set, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Get attackers for my race chip
                const attackersRef = ref(db, `chipAttacks/${myRace}`);
                const snapshot = await get(attackersRef);

                if (!snapshot.exists()) {
                    addToBattleLog('🛡️ You arrived to defend, but no one is attacking!', 'info');
                    return;
                }

                const attackers = snapshot.val();
                const attackerIds = Object.keys(attackers);

                if (attackerIds.length === 0) {
                    addToBattleLog('🛡️ You arrived to defend, but no one is attacking!', 'info');
                    return;
                }

                // Select random attacker
                const randomId = attackerIds[Math.floor(Math.random() * attackerIds.length)];
                const attacker = attackers[randomId];

                // Calculate stats
                const myStats = (gameState.character.attack || 0) + (gameState.character.defense || 0);
                const enemyStats = (attacker.attack || 0) + (attacker.defense || 0);

                addToBattleLog(`⚔️ PvP Initiated against ${attacker.name}! Comparing stats...`, 'info');

                if (myStats >= enemyStats) {
                    // WIN
                    gameState.stats.pvpPoints = (gameState.stats.pvpPoints || 0) + 10;
                    addToBattleLog(`🏆 You attacked ${attacker.name} and WON! +10 PVP Points`, 'success');

                    // Notify attacker of defeat
                    const attackerResultRef = ref(db, `chipAttacks/${myRace}/${randomId}/result`);
                    await set(attackerResultRef, {
                        type: 'defeat',
                        defenderName: gameState.character.name,
                        pPointsChange: -5,
                        timestamp: Date.now()
                    });

                } else {
                    // LOSE
                    gameState.stats.pvpPoints = Math.max(0, (gameState.stats.pvpPoints || 0) - 5);
                    addToBattleLog(`💀 You attacked ${attacker.name} and LOST! -5 PVP Points`, 'danger');
                    addToBattleLog('You have been sent back to HQ.', 'info');

                    // Notify attacker of win
                    const attackerResultRef = ref(db, `chipAttacks/${myRace}/${randomId}/result`);
                    await set(attackerResultRef, {
                        type: 'win',
                        defenderName: gameState.character.name,
                        pPointsChange: 5,
                        timestamp: Date.now()
                    });
                }

                // Update currency/points display
                if (document.getElementById('pvp-points-display')) {
                    document.getElementById('pvp-points-display').textContent = gameState.stats.pvpPoints;
                }
                saveGameState();

            } catch (error) {
                console.error('Error in PvP defend:', error);
                addToBattleLog('⚠️ PvP Error: ' + error.message, 'warning');
            }
        }

        // Make chip war functions globally accessible
        window.showChipWar = showChipWar;
        window.attackChip = attackChip;
        window.nukeChip = nukeChip;
        window.renderChipList = renderChipList;

        // Add chip war button event listener
        const chipWarBtn = document.getElementById('chip-war-btn');
        if (chipWarBtn) {
            chipWarBtn.addEventListener('click', showChipWar);
        }

        // Update chip attack timer every second
        setInterval(updateChipAttackTimer, 1000);

        // Update nuke countdown every second
        setInterval(updateNukeCountdown, 1000);

        // Function to update nuke countdown in real-time
        function updateNukeCountdown() {
            const modal = document.getElementById('chip-war-modal');
            if (!modal || modal.style.display !== 'flex') return;

            const playerRace = gameState.character?.race;
            if (!playerRace) return;

            const now = Date.now();
            const nextNukeTime = (gameState.chipNuke?.lastNukeTime || 0) + (180 * 1000); // 180 seconds
            const onCooldown = now < nextNukeTime;

            if (onCooldown) {
                // Only re-render the chip list if nuke is on cooldown
                // This will update the countdown display
                renderChipList();
            }
        }

        // ============================================
        // GUILD SYSTEM
        // ============================================

        // Show Guild modal
        async function showGuild() {
            const modal = document.getElementById('guild-modal');
            modal.style.display = 'flex';

            // Check if player is already in a guild
            if (gameState.guild && gameState.guild.guildId) {
                // Show guild detail view
                await showGuildDetailView();
            } else {
                // Show menu for create/join
                showGuildMenu();
            }
        }

        // Show the main guild menu (create/join options)
        function showGuildMenu() {
            document.getElementById('guild-menu-view').style.display = 'block';
            document.getElementById('guild-create-view').style.display = 'none';
            document.getElementById('guild-join-view').style.display = 'none';
            document.getElementById('guild-detail-view').style.display = 'none';
        }

        // Show create guild form
        function showCreateGuildForm() {
            document.getElementById('guild-menu-view').style.display = 'none';
            document.getElementById('guild-create-view').style.display = 'block';
            document.getElementById('guild-join-view').style.display = 'none';
            document.getElementById('guild-detail-view').style.display = 'none';
            document.getElementById('guild-name-input').value = '';
        }

        // Show join guild list
        async function showJoinGuildList() {
            document.getElementById('guild-menu-view').style.display = 'none';
            document.getElementById('guild-create-view').style.display = 'none';
            document.getElementById('guild-join-view').style.display = 'block';
            document.getElementById('guild-detail-view').style.display = 'none';

            // Load available guilds
            await loadGuildList();
        }

        // Show guild detail view (when in a guild)
        async function showGuildDetailView() {
            document.getElementById('guild-menu-view').style.display = 'none';
            document.getElementById('guild-create-view').style.display = 'none';
            document.getElementById('guild-join-view').style.display = 'none';
            document.getElementById('guild-detail-view').style.display = 'block';

            // Load guild details
            await loadGuildDetails();
        }

        // Load list of available guilds
        async function loadGuildList() {
            const guildListContainer = document.getElementById('guild-list');
            guildListContainer.innerHTML = '<div class="guild-empty">Loading guilds...</div>';

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                const guildsRef = ref(db, 'guilds');
                const snapshot = await get(guildsRef);

                if (!snapshot.exists()) {
                    guildListContainer.innerHTML = '<div class="guild-empty">No guilds available. Be the first to create one!</div>';
                    return;
                }

                const guilds = snapshot.val();
                const guildEntries = Object.entries(guilds);

                if (guildEntries.length === 0) {
                    guildListContainer.innerHTML = '<div class="guild-empty">No guilds available. Be the first to create one!</div>';
                    return;
                }

                guildListContainer.innerHTML = '';

                guildEntries.forEach(([guildId, guildData]) => {
                    const memberCount = guildData.members ? Object.keys(guildData.members).length : 0;

                    const guildItem = document.createElement('div');
                    guildItem.className = 'guild-list-item';
                    guildItem.innerHTML = `
                        <div class="guild-list-info">
                            <div class="guild-list-name">🏰 ${guildData.name}</div>
                            <div class="guild-list-leader">Leader: ${guildData.leaderName}</div>
                            <div class="guild-list-members">Members: ${memberCount}/10</div>
                        </div>
                        <button class="btn-join-guild" onclick="joinGuild('${guildId}')">Join</button>
                    `;

                    guildListContainer.appendChild(guildItem);
                });

            } catch (error) {
                console.error('Error loading guilds:', error);
                guildListContainer.innerHTML = '<div class="guild-empty">Error loading guilds. Please try again.</div>';
            }
        }

        // Create a new guild
        async function createGuild() {
            const guildNameInput = document.getElementById('guild-name-input');
            const guildName = guildNameInput.value.trim();

            if (!guildName) {
                alert('Please enter a guild name!');
                return;
            }

            if (guildName.length < 3) {
                alert('Guild name must be at least 3 characters!');
                return;
            }

            if (guildName.length > 10) {
                alert('Guild name cannot exceed 10 characters!');
                return;
            }

            // Check for letters and numbers only
            const alphanumericRegex = /^[A-Za-z0-9]+$/;
            if (!alphanumericRegex.test(guildName)) {
                alert('Guild name can only contain letters and numbers!');
                return;
            }

            // Check if player has enough leaves
            if (gameState.currency < 1000) {
                alert('You need 1,000 Leaves to create a guild!');
                addToBattleLog('⚠️ Not enough Leaves to create a guild. Need 1,000.', 'warning');
                return;
            }

            // Check if already in a guild
            if (gameState.guild && gameState.guild.guildId) {
                alert('You are already in a guild! Leave your current guild first.');
                return;
            }

            try {
                const { ref, push, set, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Check if guild name already exists
                const guildsRef = ref(db, 'guilds');
                const snapshot = await get(guildsRef);

                if (snapshot.exists()) {
                    const guilds = snapshot.val();
                    const nameExists = Object.values(guilds).some(g =>
                        g.name.toLowerCase() === guildName.toLowerCase()
                    );

                    if (nameExists) {
                        alert('A guild with this name already exists!');
                        return;
                    }
                }

                // Deduct currency
                gameState.currency -= 1000;
                document.getElementById('currency-amount').textContent = gameState.currency;

                // Create guild in Firebase
                const newGuildRef = push(guildsRef);
                const guildId = newGuildRef.key;

                const guildData = {
                    name: guildName,
                    leaderId: window.currentUser.uid,
                    leaderName: gameState.character.name,
                    createdAt: Date.now(),
                    members: {
                        [window.currentUser.uid]: {
                            name: gameState.character.name,
                            joinedAt: Date.now(),
                            role: 'leader'
                        }
                    }
                };

                await set(newGuildRef, guildData);

                // Update local gameState
                gameState.guild = {
                    guildId: guildId,
                    guildName: guildName,
                    role: 'leader'
                };

                // Apply guild bonus
                applyGuildBonus();

                saveGameState();

                addToBattleLog(`🏰 Created guild "${guildName}"! You are now the Guild Leader.`, 'success');
                addToBattleLog('✨ Guild Bonus Applied: +5 ATK, +5 DEF', 'success');

                // Show guild detail view
                await showGuildDetailView();

            } catch (error) {
                console.error('Error creating guild:', error);
                alert('Failed to create guild. Please try again.');

                // Refund leaves on error
                gameState.currency += 1000;
                document.getElementById('currency-amount').textContent = gameState.currency;
            }
        }

        // Join an existing guild
        async function joinGuild(guildId) {
            // Check if already in a guild
            if (gameState.guild && gameState.guild.guildId) {
                alert('You are already in a guild! Leave your current guild first.');
                return;
            }

            try {
                const { ref, get, update } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const guildRef = ref(db, `guilds/${guildId}`);
                const snapshot = await get(guildRef);

                if (!snapshot.exists()) {
                    alert('Guild no longer exists!');
                    await loadGuildList();
                    return;
                }

                const guildData = snapshot.val();

                // Check member limit
                const memberCount = guildData.members ? Object.keys(guildData.members).length : 0;
                if (memberCount >= 10) {
                    alert('This guild is full! (10/10 members)');
                    return;
                }

                // Add member to guild
                const updates = {};
                updates[`guilds/${guildId}/members/${window.currentUser.uid}`] = {
                    name: gameState.character.name,
                    joinedAt: Date.now(),
                    role: 'member'
                };

                await update(ref(db), updates);

                // Update local gameState
                gameState.guild = {
                    guildId: guildId,
                    guildName: guildData.name,
                    role: 'member'
                };

                // Apply guild bonus
                applyGuildBonus();

                saveGameState();

                addToBattleLog(`🏰 Joined guild "${guildData.name}"!`, 'success');
                addToBattleLog('✨ Guild Bonus Applied: +5 ATK, +5 DEF', 'success');

                // Show guild detail view
                await showGuildDetailView();

            } catch (error) {
                console.error('Error joining guild:', error);
                alert('Failed to join guild. Please try again.');
            }
        }

        // Leave current guild
        async function leaveGuild() {
            if (!gameState.guild || !gameState.guild.guildId) {
                alert('You are not in a guild!');
                return;
            }

            const confirmLeave = confirm('Are you sure you want to leave the guild? You will lose the +5 ATK/DEF bonus.');
            if (!confirmLeave) return;

            try {
                const { ref, get, remove, set } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const guildId = gameState.guild.guildId;
                const guildRef = ref(db, `guilds/${guildId}`);
                const snapshot = await get(guildRef);

                if (snapshot.exists()) {
                    const guildData = snapshot.val();
                    const isLeader = guildData.leaderId === window.currentUser.uid;

                    // Remove member from guild
                    const memberRef = ref(db, `guilds/${guildId}/members/${window.currentUser.uid}`);
                    await remove(memberRef);

                    // If we were the leader, check if there are remaining members
                    if (isLeader) {
                        const updatedSnapshot = await get(guildRef);
                        if (updatedSnapshot.exists()) {
                            const updatedGuildData = updatedSnapshot.val();
                            const remainingMembers = updatedGuildData.members ? Object.entries(updatedGuildData.members) : [];

                            if (remainingMembers.length > 0) {
                                // Promote the first remaining member to leader
                                const [newLeaderId, newLeaderData] = remainingMembers[0];
                                const updates = {
                                    leaderId: newLeaderId,
                                    leaderName: newLeaderData.name
                                };
                                await set(ref(db, `guilds/${guildId}/leaderId`), newLeaderId);
                                await set(ref(db, `guilds/${guildId}/leaderName`), newLeaderData.name);
                                await set(ref(db, `guilds/${guildId}/members/${newLeaderId}/role`), 'leader');

                                addToBattleLog(`${newLeaderData.name} is now the Guild Leader.`, 'info');
                            } else {
                                // No remaining members, delete the guild
                                await remove(guildRef);
                                addToBattleLog('The guild has been disbanded (no remaining members).', 'info');
                            }
                        }
                    }
                }

                // Remove guild bonus
                removeGuildBonus();

                // Clear local guild data
                const oldGuildName = gameState.guild.guildName;
                gameState.guild = null;

                saveGameState();
                updateCharacterDisplay();

                addToBattleLog(`🚪 Left guild "${oldGuildName}".`, 'info');
                addToBattleLog('❌ Guild Bonus Removed: -5 ATK, -5 DEF', 'warning');

                // Show guild menu
                showGuildMenu();

            } catch (error) {
                console.error('Error leaving guild:', error);
                alert('Failed to leave guild. Please try again.');
            }
        }

        // Load guild details for the detail view
        async function loadGuildDetails() {
            if (!gameState.guild || !gameState.guild.guildId) {
                showGuildMenu();
                return;
            }

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const guildRef = ref(db, `guilds/${gameState.guild.guildId}`);
                const snapshot = await get(guildRef);

                if (!snapshot.exists()) {
                    // Guild no longer exists
                    removeGuildBonus();
                    gameState.guild = null;
                    saveGameState();
                    addToBattleLog('⚠️ Your guild has been disbanded.', 'warning');
                    showGuildMenu();
                    return;
                }

                const guildData = snapshot.val();

                // Check if current player is the leader
                const isLeader = guildData.leaderId === window.currentUser.uid;

                // Update guild name display
                document.getElementById('guild-name-display').textContent = `🏰 ${guildData.name}`;

                // Update member count
                const members = guildData.members ? Object.entries(guildData.members) : [];
                document.getElementById('guild-member-count').textContent = `${members.length}/10`;

                // Show appropriate button based on role
                const leaveBtn = document.getElementById('btn-leave-guild');
                const disbandBtn = document.getElementById('btn-disband-guild');

                if (isLeader) {
                    leaveBtn.style.display = 'none';
                    disbandBtn.style.display = 'block';
                } else {
                    leaveBtn.style.display = 'block';
                    disbandBtn.style.display = 'none';
                }

                // Render members list
                const membersList = document.getElementById('guild-members-list');
                membersList.innerHTML = '';

                // Sort members: leader first, then by join date
                members.sort((a, b) => {
                    if (a[1].role === 'leader') return -1;
                    if (b[1].role === 'leader') return 1;
                    return a[1].joinedAt - b[1].joinedAt;
                });

                members.forEach(([memberId, memberData]) => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'guild-member-item';

                    const isMemberLeader = memberData.role === 'leader';
                    const roleClass = isMemberLeader ? 'leader' : 'member';
                    const roleText = isMemberLeader ? '👑 Leader' : 'Member';

                    memberItem.innerHTML = `
                        <span class="guild-member-name">${memberData.name}</span>
                        <span class="guild-member-role ${roleClass}">${roleText}</span>
                    `;

                    membersList.appendChild(memberItem);
                });

            } catch (error) {
                console.error('Error loading guild details:', error);
                addToBattleLog('⚠️ Error loading guild details.', 'warning');
            }
        }

        // Disband guild (leader only)
        async function disbandGuild() {
            if (!gameState.guild || !gameState.guild.guildId) {
                alert('You are not in a guild!');
                return;
            }

            const confirmDisband = confirm('⚠️ Are you sure you want to DISBAND the guild?\n\nThis will remove ALL members and delete the guild permanently!\n\nThis action cannot be undone.');
            if (!confirmDisband) return;

            try {
                const { ref, get, remove } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const guildId = gameState.guild.guildId;
                const guildRef = ref(db, `guilds/${guildId}`);
                const snapshot = await get(guildRef);

                if (!snapshot.exists()) {
                    removeGuildBonus();
                    gameState.guild = null;
                    saveGameState();
                    showGuildMenu();
                    return;
                }

                const guildData = snapshot.val();

                // Verify caller is the leader
                if (guildData.leaderId !== window.currentUser.uid) {
                    alert('Only the Guild Leader can disband the guild!');
                    return;
                }

                const oldGuildName = guildData.name;

                // Delete the entire guild
                await remove(guildRef);

                // Remove guild bonus
                removeGuildBonus();

                // Clear local guild data
                gameState.guild = null;

                saveGameState();
                updateCharacterDisplay();

                addToBattleLog(`💥 Disbanded guild "${oldGuildName}".`, 'danger');
                addToBattleLog('❌ Guild Bonus Removed: -5 ATK, -5 DEF', 'warning');

                // Show guild menu
                showGuildMenu();

            } catch (error) {
                console.error('Error disbanding guild:', error);
                alert('Failed to disband guild. Please try again.');
            }
        }

        // Apply guild bonus (+5 ATK, +5 DEF)
        function applyGuildBonus() {
            if (!gameState.character) return;

            gameState.character.attack += 5;
            gameState.character.defense += 5;

            updateCharacterDisplay();
        }

        // Remove guild bonus (-5 ATK, -5 DEF)
        function removeGuildBonus() {
            if (!gameState.character) return;

            gameState.character.attack -= 5;
            gameState.character.defense -= 5;

            updateCharacterDisplay();
        }

        // Make guild functions globally accessible
        window.showGuild = showGuild;
        window.showGuildMenu = showGuildMenu;
        window.showCreateGuildForm = showCreateGuildForm;
        window.showJoinGuildList = showJoinGuildList;
        window.createGuild = createGuild;
        window.joinGuild = joinGuild;
        window.leaveGuild = leaveGuild;
        window.disbandGuild = disbandGuild;

        // Add guild button event listener
        const guildBtn = document.getElementById('guild-btn');
        if (guildBtn) {
            guildBtn.addEventListener('click', (e) => {
                e.preventDefault();
                showGuild();
            });
        }

        // ============================================
        // RANKINGS SYSTEM
        // ============================================

        let currentRankingsTab = 'level';

        // Show Rankings modal
        async function showRankings() {
            const modal = document.getElementById('rankings-modal');
            modal.style.display = 'flex';

            // Reset to first tab
            currentRankingsTab = 'level';
            updateRankingsTabUI();
            await loadTopLevelRankings();
        }

        // Switch between ranking tabs
        async function switchRankingsTab(tab) {
            currentRankingsTab = tab;
            updateRankingsTabUI();

            const rankingsList = document.getElementById('rankings-list');
            rankingsList.innerHTML = '<div class="rankings-loading">Loading...</div>';

            if (tab === 'level') {
                await loadTopLevelRankings();
            } else if (tab === 'leaves') {
                await loadLeavesRankings();
            } else if (tab === 'pvp') {
                await loadPVPRankings();
            } else if (tab === 'guilds') {
                await loadGuildRankings();
            }
        }

        // Update tab active state
        function updateRankingsTabUI() {
            const tabs = document.querySelectorAll('.rankings-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
                // Extract tab type from onclick attribute
                const onclick = tab.getAttribute('onclick');
                if (onclick && onclick.includes(`'${currentRankingsTab}'`)) {
                    tab.classList.add('active');
                }
            });
        }

        // Load Top Level Rankings
        async function loadTopLevelRankings() {
            const rankingsList = document.getElementById('rankings-list');

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const usersRef = ref(db, 'users');
                const snapshot = await get(usersRef);

                if (!snapshot.exists()) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No players found.</div>';
                    return;
                }

                const users = snapshot.val();
                const players = [];

                // Collect player data
                Object.entries(users).forEach(([uid, userData]) => {
                    if (userData.profile && userData.stats) {
                        players.push({
                            uid: uid,
                            name: userData.profile.name || 'Unknown',
                            race: userData.profile.race || '',
                            class: userData.profile.class || '',
                            level: userData.stats.level || 1
                        });
                    }
                });

                // Sort by level (highest first)
                players.sort((a, b) => b.level - a.level);

                // Take top 20
                const top20 = players.slice(0, 20);

                if (top20.length === 0) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No players found.</div>';
                    return;
                }

                // Render rankings
                rankingsList.innerHTML = top20.map((player, index) => {
                    const rank = index + 1;
                    let rowClass = 'rankings-row';
                    if (rank === 1) rowClass += ' top-1';
                    else if (rank === 2) rowClass += ' top-2';
                    else if (rank === 3) rowClass += ' top-3';

                    return `
                            <div class="${rowClass}">
                                <div class="rankings-rank">#${rank}</div>
                                <div class="rankings-name">
                                    ${player.name}
                                    <span class="race-class">${player.race} ${player.class}</span>
                                </div>
                                <div class="rankings-value">Lv ${player.level}</div>
                            </div>
                        `;
                }).join('');

            } catch (error) {
                console.error('Error loading level rankings:', error);
                rankingsList.innerHTML = '<div class="rankings-empty">Failed to load rankings.</div>';
            }
        }

        // Load Leaves Rankings (players with highest leaves)
        async function loadLeavesRankings() {
            const rankingsList = document.getElementById('rankings-list');

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const usersRef = ref(db, 'users');
                const snapshot = await get(usersRef);

                if (!snapshot.exists()) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No players found.</div>';
                    return;
                }

                const users = snapshot.val();
                const players = [];

                // Collect player data with leaves count
                Object.entries(users).forEach(([uid, userData]) => {
                    if (userData.profile) {
                        // Get leaves from currency object (new structure) or directly (legacy)
                        let leaves = 0;
                        if (userData.currency && typeof userData.currency === 'object') {
                            leaves = userData.currency.leaves || 0;
                        } else if (typeof userData.currency === 'number') {
                            leaves = userData.currency;
                        }

                        players.push({
                            uid: uid,
                            name: userData.profile.name || 'Unknown',
                            race: userData.profile.race || '',
                            class: userData.profile.class || '',
                            leaves: leaves
                        });
                    }
                });

                // Sort by leaves (highest first)
                players.sort((a, b) => b.leaves - a.leaves);

                // Take top 20
                const top20 = players.slice(0, 20);

                if (top20.length === 0) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No players found.</div>';
                    return;
                }

                // Render rankings
                rankingsList.innerHTML = top20.map((player, index) => {
                    const rank = index + 1;
                    let rowClass = 'rankings-row';
                    if (rank === 1) rowClass += ' top-1';
                    else if (rank === 2) rowClass += ' top-2';
                    else if (rank === 3) rowClass += ' top-3';

                    return `
                            <div class="${rowClass}">
                                <div class="rankings-rank">#${rank}</div>
                                <div class="rankings-name">
                                    ${player.name}
                                    <span class="race-class">${player.race} ${player.class}</span>
                                </div>
                                <div class="rankings-value">🍃 ${player.leaves.toLocaleString()}</div>
                            </div>
                        `;
                }).join('');

            } catch (error) {
                console.error('Error loading leaves rankings:', error);
                rankingsList.innerHTML = '<div class="rankings-empty">Failed to load rankings.</div>';
            }
        }

        // Load PVP Points Rankings
        async function loadPVPRankings() {
            const rankingsList = document.getElementById('rankings-list');

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                // Get arena player stats
                const arenaRef = ref(db, 'arena/playerStats');
                const arenaSnapshot = await get(arenaRef);

                // Get user profiles for names
                const usersRef = ref(db, 'users');
                const usersSnapshot = await get(usersRef);

                if (!arenaSnapshot.exists()) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No PVP data found.</div>';
                    return;
                }

                const arenaData = arenaSnapshot.val();
                const usersData = usersSnapshot.exists() ? usersSnapshot.val() : {};

                const players = [];

                // Collect player PVP data
                Object.entries(arenaData).forEach(([uid, stats]) => {
                    const userData = usersData[uid];
                    const playerName = userData?.profile?.name || 'Unknown';
                    const playerRace = userData?.profile?.race || '';
                    const playerClass = userData?.profile?.class || '';

                    players.push({
                        uid: uid,
                        name: playerName,
                        race: playerRace,
                        class: playerClass,
                        pvpPoints: stats.pvpPoints || 100,
                        wins: stats.totalWins || 0,
                        losses: stats.totalLosses || 0
                    });
                });

                // Sort by PVP points (highest first)
                players.sort((a, b) => b.pvpPoints - a.pvpPoints);

                // Take top 20
                const top20 = players.slice(0, 20);

                if (top20.length === 0) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No PVP data found.</div>';
                    return;
                }

                // Render rankings
                rankingsList.innerHTML = top20.map((player, index) => {
                    const rank = index + 1;
                    let rowClass = 'rankings-row';
                    if (rank === 1) rowClass += ' top-1';
                    else if (rank === 2) rowClass += ' top-2';
                    else if (rank === 3) rowClass += ' top-3';

                    return `
                            <div class="${rowClass}">
                                <div class="rankings-rank">#${rank}</div>
                                <div class="rankings-name">
                                    ${player.name}
                                    <span class="race-class">${player.wins}W - ${player.losses}L</span>
                                </div>
                                <div class="rankings-value">${player.pvpPoints} pts</div>
                            </div>
                        `;
                }).join('');

            } catch (error) {
                console.error('Error loading PVP rankings:', error);
                rankingsList.innerHTML = '<div class="rankings-empty">Failed to load rankings.</div>';
            }
        }

        // Load Guild Rankings (just list guilds)
        async function loadGuildRankings() {
            const rankingsList = document.getElementById('rankings-list');

            try {
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');

                const guildsRef = ref(db, 'guilds');
                const snapshot = await get(guildsRef);

                if (!snapshot.exists()) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No guilds found.</div>';
                    return;
                }

                const guildsData = snapshot.val();
                const guilds = [];

                // Collect guild data
                Object.entries(guildsData).forEach(([guildId, guild]) => {
                    const memberCount = guild.members ? Object.keys(guild.members).length : 0;
                    guilds.push({
                        id: guildId,
                        name: guild.name,
                        leaderName: guild.leaderName || 'Unknown',
                        memberCount: memberCount,
                        createdAt: guild.createdAt || 0
                    });
                });

                // Sort by member count (highest first), then by creation date
                guilds.sort((a, b) => {
                    if (b.memberCount !== a.memberCount) {
                        return b.memberCount - a.memberCount;
                    }
                    return a.createdAt - b.createdAt;
                });

                if (guilds.length === 0) {
                    rankingsList.innerHTML = '<div class="rankings-empty">No guilds found.</div>';
                    return;
                }

                // Render guild list
                rankingsList.innerHTML = guilds.map((guild, index) => {
                    const rank = index + 1;
                    let rowClass = 'rankings-guild-row';
                    if (rank === 1) rowClass += ' top-1';
                    else if (rank === 2) rowClass += ' top-2';
                    else if (rank === 3) rowClass += ' top-3';

                    return `
                            <div class="${rowClass}">
                                <div class="rankings-rank">#${rank}</div>
                                <div class="rankings-name">${guild.name}</div>
                                <div class="guild-leader-name">👑 ${guild.leaderName}</div>
                                <div class="guild-member-count">${guild.memberCount}/10</div>
                            </div>
                        `;
                }).join('');

            } catch (error) {
                console.error('Error loading guild rankings:', error);
                rankingsList.innerHTML = '<div class="rankings-empty">Failed to load guilds.</div>';
            }
        }

        // Make ranking functions globally accessible
        window.showRankings = showRankings;
        window.switchRankingsTab = switchRankingsTab;

        // Add rankings button event listener
        const rankingsBtn = document.getElementById('rankings-btn');
        if (rankingsBtn) {
            rankingsBtn.addEventListener('click', (e) => {
                e.preventDefault();
                showRankings();
            });
        }

    </script>
    <!-- Chatbox -->
    <div id="chatbox" class="chatbox minimized">
        <div class="chatbox-header" onclick="toggleChatbox()">
            <span class="chatbox-title">💬 World Chat</span>
            <span class="chatbox-toggle">▲</span>
        </div>
        <div class="chatbox-content">
            <div id="chat-messages" class="chat-messages">
                <!-- Messages will appear here -->
                <div class="chat-message system">
                    <span class="msg-time">System:</span> Welcome to World Chat!
                </div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type a message..." maxlength="50"
                    onkeypress="handleChatInput(event)">
                <button id="chat-send-btn" onclick="sendChatMessage()">Send</button>
            </div>
        </div>
    </div>

    <style>
        /* Chatbox Styles */
        .chatbox {
            position: fixed;
            bottom: 0;
            right: 20px;
            width: 350px;
            background-color: var(--panel-bg);
            border: 1px solid var(--accent);
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            transition: transform 0.25s ease;
            display: flex;
            flex-direction: column;
        }

        .chatbox.minimized {
            transform: translateY(calc(100% - 40px));
            /* Slower closing animation */
            transition: transform 0.6s ease;
        }

        .chatbox-header {
            background-color: var(--accent);
            padding: 10px 15px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 40px;
            user-select: none;
        }

        .chatbox-header:hover {
            background-color: var(--highlight);
        }

        .chatbox-title {
            font-weight: bold;
            color: var(--accent-color);
            font-size: 0.9rem;
        }

        .chatbox-toggle {
            color: var(--text-dim);
            font-size: 0.8rem;
            transition: transform 0.1s ease-out;
        }

        .chatbox.minimized .chatbox-toggle {
            transform: rotate(180deg);
        }

        .chatbox-content {
            height: 500px;
            display: flex;
            flex-direction: column;
            background-color: var(--darker-bg);
            border-top: 1px solid var(--accent);
        }

        .chatbox.minimized .chatbox-content {
            position: absolute;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.85rem;
        }

        .chat-message {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-message.system {
            color: var(--warning);
            font-style: italic;
        }

        .msg-time {
            color: var(--text-dim);
            font-size: 0.75rem;
            margin-right: 4px;
        }

        .msg-sender {
            color: #ffcc80;
            margin-right: 4px;
            font-size: 0.9rem;
        }

        .msg-text {
            color: var(--text);
            font-size: 0.9rem;
        }

        .chat-input-area {
            padding: 12px;
            background-color: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            gap: 8px;
        }

        #chat-input {
            flex: 1;
            background-color: var(--dark-bg);
            border: 1px solid var(--accent);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            outline: none;
        }

        #chat-input:focus {
            border-color: var(--accent-color);
        }

        #chat-send-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
        }

        #chat-send-btn:hover {
            background-color: var(--accent-hover);
        }

        /* Mobile Responsiveness for Chatbox */
        @media (max-width: 768px) {
            .chatbox {
                width: 70%;
                /* Mobile width */
                right: 2%;
                /* Center it approximately */
            }

            .chatbox-content {
                height: 500px;
                /* Mobile height */
            }
        }

        @media (min-width: 769px) {
            .chatbox-content {
                height: 500px;
                /* Desktop height */
            }
        }
    </style>

    <script type="module">
        import { ref, push, onChildAdded, query, limitToLast, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Function to update online count in chat title
        function updateOnlineCount() {
            try {
                const presenceRef = ref(window.db, 'publicPresence');
                onValue(presenceRef, (snapshot) => {
                    try {
                        const allPresence = snapshot.val() || {};
                        const onlineUsers = Object.values(allPresence).filter(player =>
                            player && player.online
                        ).length;

                        const chatTitle = document.querySelector('.chatbox-title');
                        if (chatTitle) {
                            chatTitle.textContent = `💬 World Chat (${onlineUsers})`;
                        }
                    } catch (error) {
                        console.error('Error updating online count:', error);
                        const chatTitle = document.querySelector('.chatbox-title');
                        if (chatTitle) {
                            chatTitle.textContent = '💬 World Chat';
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to initialize online count listener:', error);
            }
        }

        // Wait for the main Firebase to be initialized
        function initChat() {
            if (!window.db) {
                console.log('Waiting for Firebase to initialize...');
                setTimeout(initChat, 100);
                return;
            }

            console.log('Chat initializing with existing Firebase instance...');
            const chatRef = ref(window.db, 'global_chat');

            // Initialize online count tracking
            updateOnlineCount();

            // UI Elements
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatbox = document.getElementById('chatbox');

            // Toggle Chatbox
            window.toggleChatbox = function () {
                chatbox.classList.toggle('minimized');
            };

            // Handle Input Enter Key
            window.handleChatInput = function (event) {
                if (event.key === 'Enter') {
                    sendChatMessage();
                }
            };

            // Send Message
            window.sendChatMessage = async function () {
                const text = chatInput.value.trim();
                if (!text) return;

                // Get character name safely - try multiple paths
                let senderName = "Unknown";

                // Try gameState.character.name (most common)
                if (typeof gameState !== 'undefined' && gameState?.character?.name) {
                    senderName = gameState.character.name;
                }
                // Fallback to window.gameState
                else if (window.gameState?.character?.name) {
                    senderName = window.gameState.character.name;
                }
                // Fallback to currentUser if available
                else if (window.currentUser?.displayName) {
                    senderName = window.currentUser.displayName;
                }

                // Get Arena rank and title if user is logged in
                let arenaRank = null;
                let arenaTitle = null;

                if (window.currentUser && window.currentUser.uid) {
                    try {
                        const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js');
                        const playerStatsRef = ref(window.db, `arena/playerStats/${window.currentUser.uid}`);
                        const statsSnapshot = await get(playerStatsRef);

                        if (statsSnapshot.exists()) {
                            const stats = statsSnapshot.val();
                            arenaRank = stats.currentRank || null;
                            arenaTitle = stats.title || null;
                        }
                    } catch (error) {
                        console.error('Error fetching arena stats for chat:', error);
                    }
                }

                console.log('Sending chat message as:', senderName, 'Rank:', arenaRank, 'Title:', arenaTitle);

                push(chatRef, {
                    sender: senderName,
                    text: text,
                    timestamp: serverTimestamp(),
                    arenaRank: arenaRank,
                    arenaTitle: arenaTitle
                });

                chatInput.value = '';
            };

            // Listen for new messages
            const recentMessagesQuery = query(chatRef, limitToLast(100));
            onChildAdded(recentMessagesQuery, (snapshot) => {
                const msg = snapshot.val();
                displayMessage(msg);
            });

            function displayMessage(msg) {
                const div = document.createElement('div');
                div.className = 'chat-message';

                // Format time
                const date = msg.timestamp ? new Date(msg.timestamp) : new Date();
                const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Get rank and title from message
                const arenaRank = msg.arenaRank || null;
                const arenaTitle = msg.arenaTitle || null;

                // Title color mapping
                const titleColors = {
                    'Warlord': '#e74c3c',
                    'Conqueror': '#e67e22',
                    'Slayer': '#8e44ad',
                    'Fighter': '#2980b9',
                    'Aspirant': '#27ae60'
                };

                // Build sender display with rank, title, and name
                let senderDisplay = escapeHtml(msg.sender);
                const prefixParts = [];

                // GM Check
                const gmNames = ['2MuchSauce'];
                const isGM = gmNames.includes(msg.sender);

                // Add rank if present (format: #1)
                if (arenaRank !== null && arenaRank !== undefined) {
                    prefixParts.push(`#${arenaRank}`);
                }

                // Add title if present
                if (arenaTitle) {
                    prefixParts.push(escapeHtml(arenaTitle));
                }

                // Apply GM Styling if applicable
                let messageClass = 'msg-text';

                if (isGM) {
                    // Override sender display for GMs
                    senderDisplay = `<span class="gm-user-container"><span class="gm-tag">GM</span><span class="gm-name-animated">${escapeHtml(msg.sender)}</span></span>`;
                    messageClass = 'msg-text gm-message-text';
                } else if (prefixParts.length > 0) {
                    // Only apply rank/title logic if NOT GM (or mix them if you prefer, but override is cleaner)
                    let prefixHtml = '';

                    // Always color rank with default color (#ffb74d)
                    const rankColor = '#ffb74d';
                    prefixHtml += `<span style="color: ${rankColor};">${prefixParts[0]}</span>`;

                    // Add title with its specific color if present
                    if (arenaTitle && prefixParts.length > 1) {
                        const titleColor = titleColors[arenaTitle] || '#ffffff';
                        prefixHtml += ` <span style="color: ${titleColor}; font-weight: bold;">${prefixParts[1]}</span>`;
                    }

                    // Add space and apply title color to name if there's a title
                    if (arenaTitle && titleColors[arenaTitle]) {
                        const titleColor = titleColors[arenaTitle];
                        senderDisplay = `${prefixHtml} <span style="color: ${titleColor}; font-weight: bold;">${senderDisplay}</span>`;
                    } else {
                        senderDisplay = `${prefixHtml} ${senderDisplay}`;
                    }
                }

                div.innerHTML = `
                    <span class="msg-time">[${timeStr}]</span>
                    <span class="msg-sender">${senderDisplay}:</span>
                    <span class="${messageClass}">${escapeHtml(msg.text)}</span>
                `;

                chatMessages.appendChild(div);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Limit DOM elements to 100
                if (chatMessages.children.length > 100) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }

            function escapeHtml(text) {
                if (!text) return '';
                return text
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            console.log('✅ Chat initialized successfully!');
        }

        // Start initialization
        initChat();
    </script>
</body>

</html>